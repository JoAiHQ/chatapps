/* __CHATGPT_APP_CSS_START__ */
@layer properties;
@layer theme, base, components, utilities;
@layer theme {
  :root, :host {
    --font-sans: ui-sans-serif, -apple-system, system-ui, "Segoe UI", "Noto Sans", "Helvetica",
    "Arial", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", sans-serif;
    --font-mono: ui-monospace, "SFMono-Regular", "SF Mono", "Menlo", "Monaco", "Consolas",
    "Liberation Mono", "DejaVu Sans Mono", "Courier New", monospace;
    --spacing: 0.25rem;
    --breakpoint-sm: 576px;
    --breakpoint-md: 768px;
    --breakpoint-lg: 1024px;
    --breakpoint-xl: 1280px;
    --breakpoint-2xl: 1536px;
    --container-sm: 24rem;
    --container-lg: 32rem;
    --default-transition-duration: 150ms;
    --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
    --default-font-family: var(--font-sans);
    --default-mono-font-family: var(--font-mono);
    --breakpoint-xs: 380px;
    --font-weight-normal: 400;
    --font-weight-medium: 500;
    --font-weight-semibold: 600;
    --font-weight-bold: 700;
    --radius-2xs: 0.125rem;
    --radius-xs: 0.25rem;
    --radius-sm: 0.375rem;
    --radius-md: 0.5rem;
    --radius-lg: 0.625rem;
    --radius-xl: 0.75rem;
    --radius-2xl: 1rem;
    --radius-3xl: 1.25rem;
    --radius-4xl: 1.5rem;
    --radius-full: 9999px;
    --text-lg: var(--font-text-lg-size);
    --text-lg--line-height: var(--font-text-lg-line-height);
    --text-lg--font-weight: var(--font-text-lg-weight);
    --text-lg--letter-spacing: var(--font-text-lg-tracking);
    --text-sm: var(--font-text-sm-size);
    --text-sm--line-height: var(--font-text-sm-line-height);
    --text-sm--font-weight: var(--font-text-sm-weight);
    --text-sm--letter-spacing: var(--font-text-sm-tracking);
    --text-xs: var(--font-text-xs-size);
    --text-xs--line-height: var(--font-text-xs-line-height);
    --text-xs--font-weight: var(--font-text-xs-weight);
    --text-xs--letter-spacing: var(--font-text-xs-tracking);
    --text-xl: var(--font-heading-md-size);
    --text-xl--line-height: var(--font-heading-md-line-height);
    --text-xl--font-weight: var(--font-text-lg-weight);
    --text-xl--letter-spacing: var(--font-heading-md-tracking);
    --text-2xl: var(--font-heading-lg-size);
    --text-2xl--line-height: var(--font-heading-lg-line-height);
    --text-2xl--font-weight: var(--font-text-lg-weight);
    --text-2xl--letter-spacing: var(--font-heading-lg-tracking);
    --text-6xl: var(--font-heading-4xl-size);
    --text-6xl--line-height: var(--font-heading-4xl-line-height);
    --text-6xl--font-weight: var(--font-text-lg-weight);
    --text-6xl--letter-spacing: var(--font-heading-4xl-tracking);
    --tracking-wide: var(--font-tracking-wide);
    --tracking-normal: var(--font-tracking-normal);
    --tracking-tight: var(--font-tracking-tight);
    --shadow-hairline: var(--shadow-hairline);
    --color-gray-100: var(--gray-100);
    --color-gray-200: var(--gray-200);
    --color-gray-400: var(--gray-400);
    --color-gray-500: var(--gray-500);
    --color-gray-600: var(--gray-600);
    --color-gray-700: var(--gray-700);
    --color-gray-800: var(--gray-800);
    --color-green-50: var(--green-50);
    --color-green-200: var(--green-200);
    --color-green-400: var(--green-400);
    --color-green-600: var(--green-600);
    --color-green-900: var(--green-900);
    --color-orange-50: var(--orange-50);
    --color-orange-200: var(--orange-200);
    --color-orange-900: var(--orange-900);
    --color-purple-50: var(--purple-50);
    --color-purple-200: var(--purple-200);
    --color-purple-900: var(--purple-900);
    --color-blue-50: var(--blue-50);
    --color-blue-200: var(--blue-200);
    --color-blue-400: var(--blue-400);
    --color-blue-600: var(--blue-600);
    --color-blue-900: var(--blue-900);
    --color-white: var(--white);
  }
}
@layer base {
  *,
  ::after,
  ::before,
  ::backdrop,
  ::file-selector-button {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
    border: 0 solid;
  }
  html,
  :host {
    line-height: 1.5;
    -webkit-text-size-adjust: 100%;
    -moz-tab-size: 4;
      -o-tab-size: 4;
         tab-size: 4;
    font-family: var(--default-font-family, ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji");
    font-feature-settings: var(--default-font-feature-settings, normal);
    font-variation-settings: var(--default-font-variation-settings, normal);
    -webkit-tap-highlight-color: transparent;
  }
  hr {
    height: 0;
    color: inherit;
    border-top-width: 1px;
  }
  abbr:where([title]) {
    -webkit-text-decoration: underline dotted;
    text-decoration: underline dotted;
  }
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-size: inherit;
    font-weight: inherit;
  }
  a {
    color: inherit;
    -webkit-text-decoration: inherit;
    text-decoration: inherit;
  }
  b,
  strong {
    font-weight: bolder;
  }
  code,
  kbd,
  samp,
  pre {
    font-family: var(--default-mono-font-family, ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace);
    font-feature-settings: var(--default-mono-font-feature-settings, normal);
    font-variation-settings: var(--default-mono-font-variation-settings, normal);
    font-size: 1em;
  }
  small {
    font-size: 80%;
  }
  sub,
  sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
  }
  sub {
    bottom: -0.25em;
  }
  sup {
    top: -0.5em;
  }
  table {
    text-indent: 0;
    border-color: inherit;
    border-collapse: collapse;
  }
  :-moz-focusring {
    outline: auto;
  }
  progress {
    vertical-align: baseline;
  }
  summary {
    display: list-item;
  }
  ol,
  ul,
  menu {
    list-style: none;
  }
  img,
  svg,
  video,
  canvas,
  audio,
  iframe,
  embed,
  object {
    display: block;
    vertical-align: middle;
  }
  img,
  video {
    max-width: 100%;
    height: auto;
  }
  button,
  input,
  select,
  optgroup,
  textarea,
  ::file-selector-button {
    font: inherit;
    font-feature-settings: inherit;
    font-variation-settings: inherit;
    letter-spacing: inherit;
    color: inherit;
    border-radius: 0;
    background-color: transparent;
    opacity: 1;
  }
  :where(select:is([multiple], [size])) optgroup {
    font-weight: bolder;
  }
  :where(select:is([multiple], [size])) optgroup option {
    padding-inline-start: 20px;
  }
  ::file-selector-button {
    margin-inline-end: 4px;
  }
  ::-moz-placeholder {
    opacity: 1;
  }
  ::placeholder {
    opacity: 1;
  }
  @supports (not (-webkit-appearance: -apple-pay-button))  or
    (contain-intrinsic-size: 1px) {
    ::-moz-placeholder {
      color: currentcolor;
      @supports (color: color-mix(in lab, red, red)) {
        color: color-mix(in oklab, currentcolor 50%, transparent);
      }
    }
    ::placeholder {
      color: currentcolor;
      @supports (color: color-mix(in lab, red, red)) {
        color: color-mix(in oklab, currentcolor 50%, transparent);
      }
    }
  }
  textarea {
    resize: vertical;
  }
  ::-webkit-search-decoration {
    -webkit-appearance: none;
  }
  ::-webkit-date-and-time-value {
    min-height: 1lh;
    text-align: inherit;
  }
  ::-webkit-datetime-edit {
    display: inline-flex;
  }
  ::-webkit-datetime-edit-fields-wrapper {
    padding: 0;
  }
  ::-webkit-datetime-edit,
  ::-webkit-datetime-edit-year-field,
  ::-webkit-datetime-edit-month-field,
  ::-webkit-datetime-edit-day-field,
  ::-webkit-datetime-edit-hour-field,
  ::-webkit-datetime-edit-minute-field,
  ::-webkit-datetime-edit-second-field,
  ::-webkit-datetime-edit-millisecond-field,
  ::-webkit-datetime-edit-meridiem-field {
    padding-block: 0;
  }
  ::-webkit-calendar-picker-indicator {
    line-height: 1;
  }
  :-moz-ui-invalid {
    box-shadow: none;
  }
  button,
  input:where([type="button"], [type="reset"], [type="submit"]),
  ::file-selector-button {
    -webkit-appearance: button;
       -moz-appearance: button;
            appearance: button;
  }
  ::-webkit-inner-spin-button,
  ::-webkit-outer-spin-button {
    height: auto;
  }
  [hidden]:where(:not([hidden="until-found"])) {
    display: none !important;
  }
}
@layer utilities {
  .pointer-events-none {
    pointer-events: none;
  }
  .visible {
    visibility: visible;
  }
  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip-path: inset(50%);
    white-space: nowrap;
    border-width: 0;
  }
  .absolute {
    position: absolute;
  }
  .fixed {
    position: fixed;
  }
  .relative {
    position: relative;
  }
  .static {
    position: static;
  }
  .sticky {
    position: sticky;
  }
  .bottom-0 {
    bottom: calc(var(--spacing) * 0);
  }
  .left-0 {
    left: calc(var(--spacing) * 0);
  }
  .container {
    width: 100%;
    @media (width >= 380px) {
      max-width: 380px;
    }
    @media (width >= 576px) {
      max-width: 576px;
    }
    @media (width >= 768px) {
      max-width: 768px;
    }
    @media (width >= 1024px) {
      max-width: 1024px;
    }
    @media (width >= 1280px) {
      max-width: 1280px;
    }
    @media (width >= 1536px) {
      max-width: 1536px;
    }
  }
  .mx-auto {
    margin-inline: auto;
  }
  .mx-px {
    margin-inline: 1px;
  }
  .mt-1 {
    margin-top: calc(var(--spacing) * 1);
  }
  .mt-2 {
    margin-top: calc(var(--spacing) * 2);
  }
  .mt-3 {
    margin-top: calc(var(--spacing) * 3);
  }
  .mt-4 {
    margin-top: calc(var(--spacing) * 4);
  }
  .mb-1 {
    margin-bottom: calc(var(--spacing) * 1);
  }
  .mb-2 {
    margin-bottom: calc(var(--spacing) * 2);
  }
  .mb-3 {
    margin-bottom: calc(var(--spacing) * 3);
  }
  .ml-2 {
    margin-left: calc(var(--spacing) * 2);
  }
  .block {
    display: block;
  }
  .contents {
    display: contents;
  }
  .flex {
    display: flex;
  }
  .grid {
    display: grid;
  }
  .hidden {
    display: none;
  }
  .inline {
    display: inline;
  }
  .inline-block {
    display: inline-block;
  }
  .inline-flex {
    display: inline-flex;
  }
  .table {
    display: table;
  }
  .size-4 {
    width: calc(var(--spacing) * 4);
    height: calc(var(--spacing) * 4);
  }
  .size-5 {
    width: calc(var(--spacing) * 5);
    height: calc(var(--spacing) * 5);
  }
  .h-0 {
    height: calc(var(--spacing) * 0);
  }
  .h-\[var\(--button-icon-size\)\] {
    height: var(--button-icon-size);
  }
  .w-\[var\(--button-icon-size\)\] {
    width: var(--button-icon-size);
  }
  .w-full {
    width: 100%;
  }
  .max-w-lg {
    max-width: var(--container-lg);
  }
  .max-w-sm {
    max-width: var(--container-sm);
  }
  .min-w-0 {
    min-width: calc(var(--spacing) * 0);
  }
  .min-w-\[120px\] {
    min-width: 120px;
  }
  .flex-1 {
    flex: 1;
  }
  .flex-shrink {
    flex-shrink: 1;
  }
  .shrink-0 {
    flex-shrink: 0;
  }
  .flex-grow {
    flex-grow: 1;
  }
  .border-collapse {
    border-collapse: collapse;
  }
  .transform {
    transform: var(--tw-rotate-x,) var(--tw-rotate-y,) var(--tw-rotate-z,) var(--tw-skew-x,) var(--tw-skew-y,);
  }
  .cursor-help {
    cursor: help;
  }
  .resize {
    resize: both;
  }
  .list-inside {
    list-style-position: inside;
  }
  .list-disc {
    list-style-type: disc;
  }
  .grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
  .grid-cols-\[auto_1fr\] {
    grid-template-columns: auto 1fr;
  }
  .flex-col {
    flex-direction: column;
  }
  .flex-wrap {
    flex-wrap: wrap;
  }
  .items-center {
    align-items: center;
  }
  .items-start {
    align-items: flex-start;
  }
  .justify-between {
    justify-content: space-between;
  }
  .justify-center {
    justify-content: center;
  }
  .gap-0 {
    gap: calc(var(--spacing) * 0);
  }
  .gap-0\.5 {
    gap: calc(var(--spacing) * 0.5);
  }
  .gap-1 {
    gap: calc(var(--spacing) * 1);
  }
  .gap-1\.5 {
    gap: calc(var(--spacing) * 1.5);
  }
  .gap-2 {
    gap: calc(var(--spacing) * 2);
  }
  .gap-3 {
    gap: calc(var(--spacing) * 3);
  }
  .gap-4 {
    gap: calc(var(--spacing) * 4);
  }
  .space-y-1 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 1) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 1) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-2 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 2) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 2) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-3 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 3) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 3) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .space-y-4 {
    :where(& > :not(:last-child)) {
      --tw-space-y-reverse: 0;
      margin-block-start: calc(calc(var(--spacing) * 4) * var(--tw-space-y-reverse));
      margin-block-end: calc(calc(var(--spacing) * 4) * calc(1 - var(--tw-space-y-reverse)));
    }
  }
  .gap-x-3 {
    -moz-column-gap: calc(var(--spacing) * 3);
         column-gap: calc(var(--spacing) * 3);
  }
  .gap-y-2 {
    row-gap: calc(var(--spacing) * 2);
  }
  .truncate {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .overflow-hidden {
    overflow: hidden;
  }
  .rounded-2xl {
    border-radius: var(--radius-2xl);
  }
  .rounded-lg {
    border-radius: var(--radius-lg);
  }
  .rounded-sm {
    border-radius: var(--radius-sm);
  }
  .border {
    border-style: var(--tw-border-style);
    border-width: 1px;
  }
  .border-t {
    border-top-style: var(--tw-border-style);
    border-top-width: 1px;
  }
  .border-blue-200 {
    border-color: var(--color-blue-200);
  }
  .border-default {
    border-color: var(--color-border);
  }
  .border-gray-200 {
    border-color: var(--color-gray-200);
  }
  .border-green-200 {
    border-color: var(--color-green-200);
  }
  .border-orange-200 {
    border-color: var(--color-orange-200);
  }
  .border-purple-200 {
    border-color: var(--color-purple-200);
  }
  .border-subtle {
    border-color: var(--color-border-subtle);
  }
  .bg-blue-50 {
    background-color: var(--color-blue-50);
  }
  .bg-gray-100 {
    background-color: var(--color-gray-100);
  }
  .bg-green-50 {
    background-color: var(--color-green-50);
  }
  .bg-orange-50 {
    background-color: var(--color-orange-50);
  }
  .bg-purple-50 {
    background-color: var(--color-purple-50);
  }
  .bg-surface {
    background-color: var(--color-surface);
  }
  .bg-surface-secondary {
    background-color: var(--color-surface-secondary);
  }
  .bg-white {
    background-color: var(--color-white);
  }
  .bg-gradient-to-r {
    --tw-gradient-position: to right in oklab;
    background-image: linear-gradient(var(--tw-gradient-stops));
  }
  .from-blue-50 {
    --tw-gradient-from: var(--color-blue-50);
    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));
  }
  .to-green-50 {
    --tw-gradient-to: var(--color-green-50);
    --tw-gradient-stops: var(--tw-gradient-via-stops, var(--tw-gradient-position), var(--tw-gradient-from) var(--tw-gradient-from-position), var(--tw-gradient-to) var(--tw-gradient-to-position));
  }
  .fill-secondary {
    fill: var(--color-text-secondary);
  }
  .p-4 {
    padding: calc(var(--spacing) * 4);
  }
  .p-8 {
    padding: calc(var(--spacing) * 8);
  }
  .pt-3 {
    padding-top: calc(var(--spacing) * 3);
  }
  .pt-4 {
    padding-top: calc(var(--spacing) * 4);
  }
  .text-center {
    text-align: center;
  }
  .text-right {
    text-align: right;
  }
  .font-mono {
    font-family: var(--font-mono);
  }
  .heading-lg {
    font-size: var(--font-heading-lg-size);
    font-weight: var(--font-heading-lg-weight);
    letter-spacing: var(--font-heading-lg-tracking);
    line-height: var(--font-heading-lg-line-height);
  }
  .heading-md {
    font-size: var(--font-heading-md-size);
    font-weight: var(--font-heading-md-weight);
    letter-spacing: var(--font-heading-md-tracking);
    line-height: var(--font-heading-md-line-height);
  }
  .heading-sm {
    font-size: var(--font-heading-sm-size);
    font-weight: var(--font-heading-sm-weight);
    letter-spacing: var(--font-heading-sm-tracking);
    line-height: var(--font-heading-sm-line-height);
  }
  .text-2xl {
    font-size: var(--text-2xl);
    line-height: var(--tw-leading, var(--text-2xl--line-height));
    letter-spacing: var(--tw-tracking, var(--text-2xl--letter-spacing));
    font-weight: var(--tw-font-weight, var(--text-2xl--font-weight));
  }
  .text-6xl {
    font-size: var(--text-6xl);
    line-height: var(--tw-leading, var(--text-6xl--line-height));
    letter-spacing: var(--tw-tracking, var(--text-6xl--letter-spacing));
    font-weight: var(--tw-font-weight, var(--text-6xl--font-weight));
  }
  .text-lg {
    font-size: var(--text-lg);
    line-height: var(--tw-leading, var(--text-lg--line-height));
    letter-spacing: var(--tw-tracking, var(--text-lg--letter-spacing));
    font-weight: var(--tw-font-weight, var(--text-lg--font-weight));
  }
  .text-sm {
    font-size: var(--text-sm);
    line-height: var(--tw-leading, var(--text-sm--line-height));
    letter-spacing: var(--tw-tracking, var(--text-sm--letter-spacing));
    font-weight: var(--tw-font-weight, var(--text-sm--font-weight));
  }
  .text-xl {
    font-size: var(--text-xl);
    line-height: var(--tw-leading, var(--text-xl--line-height));
    letter-spacing: var(--tw-tracking, var(--text-xl--letter-spacing));
    font-weight: var(--tw-font-weight, var(--text-xl--font-weight));
  }
  .text-xs {
    font-size: var(--text-xs);
    line-height: var(--tw-leading, var(--text-xs--line-height));
    letter-spacing: var(--tw-tracking, var(--text-xs--letter-spacing));
    font-weight: var(--tw-font-weight, var(--text-xs--font-weight));
  }
  .font-bold {
    --tw-font-weight: var(--font-weight-bold);
    font-weight: var(--font-weight-bold);
  }
  .font-medium {
    --tw-font-weight: var(--font-weight-medium);
    font-weight: var(--font-weight-medium);
  }
  .font-semibold {
    --tw-font-weight: var(--font-weight-semibold);
    font-weight: var(--font-weight-semibold);
  }
  .tracking-wide {
    --tw-tracking: var(--tracking-wide);
    letter-spacing: var(--tracking-wide);
  }
  .text-wrap {
    text-wrap: wrap;
  }
  .text-ellipsis {
    text-overflow: ellipsis;
  }
  .text-blue-600 {
    color: var(--color-blue-600);
  }
  .text-blue-900 {
    color: var(--color-blue-900);
  }
  .text-danger {
    color: var(--color-text-danger);
  }
  .text-gray-500 {
    color: var(--color-gray-500);
  }
  .text-gray-600 {
    color: var(--color-gray-600);
  }
  .text-green-600 {
    color: var(--color-green-600);
  }
  .text-green-900 {
    color: var(--color-green-900);
  }
  .text-orange-900 {
    color: var(--color-orange-900);
  }
  .text-primary {
    color: var(--color-text-primary);
  }
  .text-purple-900 {
    color: var(--color-purple-900);
  }
  .text-secondary {
    color: var(--color-text-secondary);
  }
  .text-success {
    color: var(--color-text-success);
  }
  .text-warning {
    color: var(--color-text-warning);
  }
  .capitalize {
    text-transform: capitalize;
  }
  .lowercase {
    text-transform: lowercase;
  }
  .uppercase {
    text-transform: uppercase;
  }
  .italic {
    font-style: italic;
  }
  .tabular-nums {
    --tw-numeric-spacing: tabular-nums;
    font-variant-numeric: var(--tw-ordinal,) var(--tw-slashed-zero,) var(--tw-numeric-figure,) var(--tw-numeric-spacing,) var(--tw-numeric-fraction,);
  }
  .overline {
    text-decoration-line: overline;
  }
  .underline {
    text-decoration-line: underline;
  }
  .shadow-lg {
    --tw-shadow: var(--shadow-300);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .ring {
    --tw-ring-shadow: var(--tw-ring-inset,) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color, currentcolor);
    box-shadow: var(--tw-inset-shadow), var(--tw-inset-ring-shadow), var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow);
  }
  .outline {
    outline-style: var(--tw-outline-style);
    outline-width: 1px;
  }
  .blur {
    --tw-blur: blur(8px);
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .filter {
    filter: var(--tw-blur,) var(--tw-brightness,) var(--tw-contrast,) var(--tw-grayscale,) var(--tw-hue-rotate,) var(--tw-invert,) var(--tw-saturate,) var(--tw-sepia,) var(--tw-drop-shadow,);
  }
  .transition {
    transition-property: color, background-color, border-color, outline-color, text-decoration-color, fill, stroke, --tw-gradient-from, --tw-gradient-via, --tw-gradient-to, opacity, box-shadow, transform, translate, scale, rotate, filter, backdrop-filter, display, content-visibility, overlay, pointer-events;
    transition-timing-function: var(--tw-ease, var(--default-transition-timing-function));
    transition-duration: var(--tw-duration, var(--default-transition-duration));
  }
  .hover\:underline {
    @media (hover: hover) and (pointer: fine) {
      &:hover {
        text-decoration-line: underline;
      }
    }
  }
  .sm\:grid-cols-2 {
    @media (width >= 576px) {
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }
  }
}
@layer base {
  html,
  :host {
    font-synthesis-weight: none;
  }
  textarea {
    resize: none;
  }
  img,
  svg {
    flex-grow: 0;
    flex-shrink: 0;
  }
  input,
  textarea,
  select,
  optgroup {
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    box-shadow: none;
    filter: none;
    outline-offset: 0;
    outline-width: 2px;
  }
  a,
  button,
  input,
  label,
  select,
  textarea,
  :where([aria-role="button"]) {
    touch-action: manipulation;
  }
  button {
    text-transform: none;
    vertical-align: middle;
  }
  button:not(:disabled),
  [role="button"]:not(:disabled) {
    cursor: pointer;
  }
  pre {
    white-space: pre-wrap;
  }
  table {
    border-spacing: 0;
  }
  blockquote,
  q {
    quotes: none;
  }
  blockquote::before,
  blockquote::after,
  q::before,
  q::after {
    content: none;
  }
}
@layer theme {
  :root,
  :where([data-theme]) {
    --gray-500: #5d5d5d;
    --alpha-0: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-0: color-mix(in oklab, var(--alpha-base) 0%, transparent);
    }
    --alpha-02: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-02: color-mix(in oklab, var(--alpha-base) 2%, transparent);
    }
    --alpha-04: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-04: color-mix(in oklab, var(--alpha-base) 4%, transparent);
    }
    --alpha-05: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-05: color-mix(in oklab, var(--alpha-base) 5%, transparent);
    }
    --alpha-06: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-06: color-mix(in oklab, var(--alpha-base) 6%, transparent);
    }
    --alpha-08: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-08: color-mix(in oklab, var(--alpha-base) 8%, transparent);
    }
    --alpha-10: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-10: color-mix(in oklab, var(--alpha-base) 10%, transparent);
    }
    --alpha-12: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-12: color-mix(in oklab, var(--alpha-base) 12%, transparent);
    }
    --alpha-15: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-15: color-mix(in oklab, var(--alpha-base) 15%, transparent);
    }
    --alpha-16: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-16: color-mix(in oklab, var(--alpha-base) 16%, transparent);
    }
    --alpha-20: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-20: color-mix(in oklab, var(--alpha-base) 20%, transparent);
    }
    --alpha-25: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-25: color-mix(in oklab, var(--alpha-base) 25%, transparent);
    }
    --alpha-30: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-30: color-mix(in oklab, var(--alpha-base) 30%, transparent);
    }
    --alpha-35: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-35: color-mix(in oklab, var(--alpha-base) 35%, transparent);
    }
    --alpha-40: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-40: color-mix(in oklab, var(--alpha-base) 40%, transparent);
    }
    --alpha-50: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-50: color-mix(in oklab, var(--alpha-base) 50%, transparent);
    }
    --alpha-60: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-60: color-mix(in oklab, var(--alpha-base) 60%, transparent);
    }
    --alpha-70: var(--alpha-base);
    @supports (color: color-mix(in lab, red, red)) {
      --alpha-70: color-mix(in oklab, var(--alpha-base) 70%, transparent);
    }
    --white: #ffffff;
    --black: #000000;
    --green-25: #edfaf2;
    --green-50: #d9f4e4;
    --green-75: #b8ebcc;
    --green-100: #8cdfad;
    --green-200: #66d492;
    --green-300: #40c977;
    --green-400: #04b84c;
    --green-500: #00a240;
    --green-600: #008635;
    --green-700: #00692a;
    --green-800: #004f1f;
    --green-900: #003716;
    --green-950: #011c0b;
    --green-1000: #001207;
    --green-a25: var(--green-400);
    @supports (color: color-mix(in lab, red, red)) {
      --green-a25: color-mix(in oklab, var(--green-400) 8%, transparent);
    }
    --green-a50: var(--green-400);
    @supports (color: color-mix(in lab, red, red)) {
      --green-a50: color-mix(in oklab, var(--green-400) 15%, transparent);
    }
    --green-a75: var(--green-400);
    @supports (color: color-mix(in lab, red, red)) {
      --green-a75: color-mix(in oklab, var(--green-400) 29%, transparent);
    }
    --green-a100: var(--green-400);
    @supports (color: color-mix(in lab, red, red)) {
      --green-a100: color-mix(in oklab, var(--green-400) 45%, transparent);
    }
    --green-a200: var(--green-400);
    @supports (color: color-mix(in lab, red, red)) {
      --green-a200: color-mix(in oklab, var(--green-400) 60%, transparent);
    }
    --green-a300: var(--green-400);
    @supports (color: color-mix(in lab, red, red)) {
      --green-a300: color-mix(in oklab, var(--green-400) 75%, transparent);
    }
    --red-25: #fff0f0;
    --red-50: #ffd9d9;
    --red-75: #ffc6c5;
    --red-100: #ffa4a2;
    --red-200: #ff8583;
    --red-300: #ff6764;
    --red-400: #fa423e;
    --red-500: #e02e2a;
    --red-600: #ba2623;
    --red-700: #911e1b;
    --red-800: #6e1615;
    --red-900: #4d100e;
    --red-950: #280b0a;
    --red-1000: #1f0909;
    --red-a25: var(--red-400);
    @supports (color: color-mix(in lab, red, red)) {
      --red-a25: color-mix(in oklab, var(--red-400) 8%, transparent);
    }
    --red-a50: var(--red-400);
    @supports (color: color-mix(in lab, red, red)) {
      --red-a50: color-mix(in oklab, var(--red-400) 16%, transparent);
    }
    --red-a75: var(--red-400);
    @supports (color: color-mix(in lab, red, red)) {
      --red-a75: color-mix(in oklab, var(--red-400) 30%, transparent);
    }
    --red-a100: var(--red-400);
    @supports (color: color-mix(in lab, red, red)) {
      --red-a100: color-mix(in oklab, var(--red-400) 48%, transparent);
    }
    --red-a200: var(--red-400);
    @supports (color: color-mix(in lab, red, red)) {
      --red-a200: color-mix(in oklab, var(--red-400) 64%, transparent);
    }
    --red-a300: var(--red-400);
    @supports (color: color-mix(in lab, red, red)) {
      --red-a300: color-mix(in oklab, var(--red-400) 79%, transparent);
    }
    --pink-25: #fff4f9;
    --pink-50: #ffe8f3;
    --pink-75: #ffd4e8;
    --pink-100: #ffbada;
    --pink-200: #ffa3ce;
    --pink-300: #ff8cc1;
    --pink-400: #ff66ad;
    --pink-500: #e04c91;
    --pink-600: #ba437a;
    --pink-700: #963c67;
    --pink-800: #6e2c4a;
    --pink-900: #4d1f34;
    --pink-950: #29101c;
    --pink-1000: #1a0a11;
    --pink-a25: var(--pink-400);
    @supports (color: color-mix(in lab, red, red)) {
      --pink-a25: color-mix(in oklab, var(--pink-400) 8%, transparent);
    }
    --pink-a50: var(--pink-400);
    @supports (color: color-mix(in lab, red, red)) {
      --pink-a50: color-mix(in oklab, var(--pink-400) 16%, transparent);
    }
    --pink-a75: var(--pink-400);
    @supports (color: color-mix(in lab, red, red)) {
      --pink-a75: color-mix(in oklab, var(--pink-400) 28%, transparent);
    }
    --pink-a100: var(--pink-400);
    @supports (color: color-mix(in lab, red, red)) {
      --pink-a100: color-mix(in oklab, var(--pink-400) 45%, transparent);
    }
    --pink-a200: var(--pink-400);
    @supports (color: color-mix(in lab, red, red)) {
      --pink-a200: color-mix(in oklab, var(--pink-400) 60%, transparent);
    }
    --pink-a300: var(--pink-400);
    @supports (color: color-mix(in lab, red, red)) {
      --pink-a300: color-mix(in oklab, var(--pink-400) 76%, transparent);
    }
    --orange-25: #fff5f0;
    --orange-50: #ffe7d9;
    --orange-75: #ffcfb4;
    --orange-100: #ffb790;
    --orange-200: #ff9e6c;
    --orange-300: #ff8549;
    --orange-400: #fb6a22;
    --orange-500: #e25507;
    --orange-600: #b9480d;
    --orange-700: #923b0f;
    --orange-800: #6d2e0f;
    --orange-900: #4a2206;
    --orange-950: #281105;
    --orange-1000: #211107;
    --orange-a25: var(--orange-400);
    @supports (color: color-mix(in lab, red, red)) {
      --orange-a25: color-mix(in oklab, var(--orange-400) 7%, transparent);
    }
    --orange-a50: var(--orange-400);
    @supports (color: color-mix(in lab, red, red)) {
      --orange-a50: color-mix(in oklab, var(--orange-400) 16%, transparent);
    }
    --orange-a75: var(--orange-400);
    @supports (color: color-mix(in lab, red, red)) {
      --orange-a75: color-mix(in oklab, var(--orange-400) 33%, transparent);
    }
    --orange-a100: var(--orange-400);
    @supports (color: color-mix(in lab, red, red)) {
      --orange-a100: color-mix(in oklab, var(--orange-400) 48%, transparent);
    }
    --orange-a200: var(--orange-400);
    @supports (color: color-mix(in lab, red, red)) {
      --orange-a200: color-mix(in oklab, var(--orange-400) 65%, transparent);
    }
    --orange-a300: var(--orange-400);
    @supports (color: color-mix(in lab, red, red)) {
      --orange-a300: color-mix(in oklab, var(--orange-400) 81%, transparent);
    }
    --yellow-25: #fffbed;
    --yellow-50: #fff6d9;
    --yellow-75: #ffeeb8;
    --yellow-100: #ffe48c;
    --yellow-200: #ffdb66;
    --yellow-300: #ffd240;
    --yellow-400: #ffc300;
    --yellow-500: #e0ac00;
    --yellow-600: #ba8e00;
    --yellow-700: #916f00;
    --yellow-800: #6e5400;
    --yellow-900: #4d3b00;
    --yellow-950: #261d00;
    --yellow-1000: #1a1400;
    --yellow-a25: var(--yellow-400);
    @supports (color: color-mix(in lab, red, red)) {
      --yellow-a25: color-mix(in oklab, var(--yellow-400) 8%, transparent);
    }
    --yellow-a50: var(--yellow-400);
    @supports (color: color-mix(in lab, red, red)) {
      --yellow-a50: color-mix(in oklab, var(--yellow-400) 15%, transparent);
    }
    --yellow-a75: var(--yellow-400);
    @supports (color: color-mix(in lab, red, red)) {
      --yellow-a75: color-mix(in oklab, var(--yellow-400) 27%, transparent);
    }
    --yellow-a100: var(--yellow-400);
    @supports (color: color-mix(in lab, red, red)) {
      --yellow-a100: color-mix(in oklab, var(--yellow-400) 45%, transparent);
    }
    --yellow-a200: var(--yellow-400);
    @supports (color: color-mix(in lab, red, red)) {
      --yellow-a200: color-mix(in oklab, var(--yellow-400) 59%, transparent);
    }
    --yellow-a300: var(--yellow-400);
    @supports (color: color-mix(in lab, red, red)) {
      --yellow-a300: color-mix(in oklab, var(--yellow-400) 74%, transparent);
    }
    --purple-25: #f9f5fe;
    --purple-50: #efe5fe;
    --purple-75: #e0cefd;
    --purple-100: #ceb0fb;
    --purple-200: #be95fa;
    --purple-300: #ad7bf9;
    --purple-400: #924ff7;
    --purple-500: #8046d9;
    --purple-600: #6b3ab4;
    --purple-700: #532d8d;
    --purple-800: #3f226a;
    --purple-900: #2c184a;
    --purple-950: #160c25;
    --purple-1000: #100a19;
    --purple-a25: var(--purple-400);
    @supports (color: color-mix(in lab, red, red)) {
      --purple-a25: color-mix(in oklab, var(--purple-400) 6%, transparent);
    }
    --purple-a50: var(--purple-400);
    @supports (color: color-mix(in lab, red, red)) {
      --purple-a50: color-mix(in oklab, var(--purple-400) 15%, transparent);
    }
    --purple-a75: var(--purple-400);
    @supports (color: color-mix(in lab, red, red)) {
      --purple-a75: color-mix(in oklab, var(--purple-400) 28%, transparent);
    }
    --purple-a100: var(--purple-400);
    @supports (color: color-mix(in lab, red, red)) {
      --purple-a100: color-mix(in oklab, var(--purple-400) 45%, transparent);
    }
    --purple-a200: var(--purple-400);
    @supports (color: color-mix(in lab, red, red)) {
      --purple-a200: color-mix(in oklab, var(--purple-400) 60%, transparent);
    }
    --purple-a300: var(--purple-400);
    @supports (color: color-mix(in lab, red, red)) {
      --purple-a300: color-mix(in oklab, var(--purple-400) 75%, transparent);
    }
    --blue-25: #f5faff;
    --blue-50: #e5f3ff;
    --blue-75: #cce6ff;
    --blue-100: #99ceff;
    --blue-200: #66b5ff;
    --blue-300: #339cff;
    --blue-400: #0285ff;
    --blue-500: #0169cc;
    --blue-600: #004f99;
    --blue-700: #003f7a;
    --blue-800: #013566;
    --blue-900: #00284d;
    --blue-950: #000e1a;
    --blue-1000: #000d19;
    --blue-a25: var(--blue-400);
    @supports (color: color-mix(in lab, red, red)) {
      --blue-a25: color-mix(in oklab, var(--blue-400) 4%, transparent);
    }
    --blue-a50: var(--blue-400);
    @supports (color: color-mix(in lab, red, red)) {
      --blue-a50: color-mix(in oklab, var(--blue-400) 13%, transparent);
    }
    --blue-a75: var(--blue-400);
    @supports (color: color-mix(in lab, red, red)) {
      --blue-a75: color-mix(in oklab, var(--blue-400) 25%, transparent);
    }
    --blue-a100: var(--blue-400);
    @supports (color: color-mix(in lab, red, red)) {
      --blue-a100: color-mix(in oklab, var(--blue-400) 40%, transparent);
    }
    --blue-a200: var(--blue-400);
    @supports (color: color-mix(in lab, red, red)) {
      --blue-a200: color-mix(in oklab, var(--blue-400) 60%, transparent);
    }
    --blue-a300: var(--blue-400);
    @supports (color: color-mix(in lab, red, red)) {
      --blue-a300: color-mix(in oklab, var(--blue-400) 80%, transparent);
    }
    --hairline: 1px;
  }
  :where(:root), :where([data-theme="light"]) {
    --gray-0: #ffffff;
    --gray-25: #fcfcfc;
    --gray-50: #f9f9f9;
    --gray-75: #f3f3f3;
    --gray-100: #ededed;
    --gray-150: #dfdfdf;
    --gray-200: #cdcdcd;
    --gray-250: #b9b9b9;
    --gray-300: #afafaf;
    --gray-350: #9f9f9f;
    --gray-400: #8f8f8f;
    --gray-450: #767676;
    --gray-550: #4f4f4f;
    --gray-600: #414141;
    --gray-650: #393939;
    --gray-700: #303030;
    --gray-750: #282828;
    --gray-800: #212121;
    --gray-850: #1c1c1c;
    --gray-900: #181818;
    --gray-925: #161616;
    --gray-950: #131313;
    --gray-975: #101010;
    --gray-1000: #0d0d0d;
    --alpha-base: #0d0d0d;
  }
  :where([data-theme="dark"]) {
    --gray-0: #0d0d0d;
    --gray-25: #101010;
    --gray-50: #131313;
    --gray-75: #161616;
    --gray-100: #181818;
    --gray-150: #1c1c1c;
    --gray-200: #212121;
    --gray-250: #282828;
    --gray-300: #303030;
    --gray-350: #393939;
    --gray-400: #414141;
    --gray-450: #4f4f4f;
    --gray-550: #767676;
    --gray-600: #8f8f8f;
    --gray-650: #9f9f9f;
    --gray-700: #afafaf;
    --gray-750: #b9b9b9;
    --gray-800: #cdcdcd;
    --gray-850: #dcdcdc;
    --gray-900: #ededed;
    --gray-925: #f3f3f3;
    --gray-950: #f3f3f3;
    --gray-975: #f9f9f9;
    --gray-1000: #ffffff;
    --alpha-base: #ffffff;
  }
  @media (resolution >= 150dpi), (resolution >= 1.5dppx) {
    :root,
  :where([data-theme]) {
      --hairline: 0.5px;
    }
  }
  :root,
  :where([data-theme]) {
    --shadow-color: 0 0 0;
    --elevation-100-geo: 0 1px 2px -1px;
    --elevation-200-geo: 0 2px 4px -1px;
    --elevation-300-geo: 0 4px 8px -2px;
    --elevation-400-geo: 0 8px 16px -4px;
  }
  :where(:root),
  :where([data-theme="light"]) {
    --shadow-alpha-100: 0.08;
    --shadow-alpha-200: 0.08;
    --shadow-alpha-300: 0.1;
    --shadow-alpha-400: 0.12;
    --shadow-hairline-width: 1px;
    --shadow-hairline-color: rgb(0 0 0 / 8%);
  }
  @media (resolution >= 150dpi), (resolution >= 1.5dppx) {
    :where(:root),
  :where([data-theme="light"]) {
      --shadow-hairline-width: 0.5px;
      --shadow-hairline-color: rgb(0 0 0 / 10%)
  ;
    }
  }
  :where([data-theme="dark"]) {
    --shadow-alpha-100: 0.2;
    --shadow-alpha-200: 0.2;
    --shadow-alpha-300: 0.36;
    --shadow-alpha-400: 0.3;
    --shadow-hairline-width: 1px;
    --shadow-hairline-color: rgb(255 255 255 / 10%);
  }
  @media (resolution >= 150dpi), (resolution >= 1.5dppx) {
    :where([data-theme="dark"]) {
      --shadow-hairline-width: 0.5px;
      --shadow-hairline-color: rgb(255 255 255 / 12%)
  ;
    }
  }
  :where([data-theme="dark"]) [data-surface="elevated"] {
    --shadow-hairline: 0 0 rgb(0 0 0 / 0%);
  }
}
@layer theme {
  :root,
  :where([data-theme]) {
    --color-text: var(--gray-1000);
    --color-text-inverse: var(--gray-0);
    --color-text-primary: var(--color-text);
    --color-text-primary-soft: var(--color-text);
    --color-background-primary-soft-alt: var(--alpha-02);
    --color-border-primary-soft-alt: var(--alpha-06);
    --color-text-primary-soft-alt: var(--color-text);
    --color-text-primary-surface: var(--color-text);
    --color-text-primary-solid: var(--color-text-inverse);
    --color-text-primary-outline: var(--color-text);
    --color-text-primary-outline-hover: var(--color-text);
    --color-text-primary-ghost: var(--color-text);
    --color-text-primary-ghost-hover: var(--color-text);
    --color-ring-primary: var(--color-ring);
    --color-ring-primary-soft: var(--color-ring-primary);
    --color-ring-primary-solid: var(--color-ring-primary);
    --color-ring-primary-outline: var(--color-ring-primary);
    --color-ring-primary-ghost: var(--color-ring-primary);
    --color-text-secondary-soft: var(--color-text);
    --color-background-secondary-soft-alt: var(--alpha-02);
    --color-border-secondary-soft-alt: var(--alpha-06);
    --color-text-secondary-soft-alt: var(--color-text);
    --color-text-secondary-solid: var(--white);
    --color-text-secondary-outline: var(--color-text-secondary);
    --color-text-secondary-outline-hover: var(--color-text);
    --color-text-secondary-ghost: var(--color-text-secondary);
    --color-text-secondary-ghost-hover: var(--color-text);
    --color-ring-secondary: var(--color-ring);
    --color-ring-secondary-soft: var(--color-ring-secondary);
    --color-ring-secondary-solid: var(--color-ring-secondary);
    --color-ring-secondary-outline: var(--color-ring-secondary);
    --color-ring-secondary-ghost: var(--color-ring-secondary);
    --color-background-info-soft: var(--blue-50);
    --color-background-info-soft-hover: var(--blue-75);
    --color-background-info-soft-active: var(--blue-75);
    --color-background-info-soft-alpha: var(--blue-a50);
    --color-background-info-soft-alpha-hover: var(--blue-a75);
    --color-background-info-soft-alpha-active: var(--blue-a75);
    --color-background-info-solid: var(--blue-400);
    --color-background-info-solid-hover: var(--blue-500);
    --color-background-info-solid-active: var(--blue-500);
    --color-text-info-solid: var(--white);
    --color-background-info-outline-hover: var(--blue-a25);
    --color-background-info-outline-active: var(--blue-a25);
    --color-border-info-outline: var(--blue-500);
    --color-border-info-outline-hover: var(--blue-500);
    --color-text-info-outline: var(--blue-500);
    --color-text-info-outline-hover: var(--blue-500);
    --color-background-info-ghost-hover: var(--blue-a50);
    --color-background-info-ghost-active: var(--blue-a50);
    --color-ring-info: var(--color-ring);
    --color-ring-info-soft: var(--color-ring-info);
    --color-ring-info-solid: var(--color-ring-info);
    --color-ring-info-outline: var(--color-ring-info);
    --color-ring-info-ghost: var(--color-ring-info);
    --color-background-warning-soft: var(--orange-50);
    --color-background-warning-soft-hover: var(--orange-75);
    --color-background-warning-soft-active: var(--orange-75);
    --color-background-warning-soft-alpha: var(--orange-a50);
    --color-background-warning-soft-alpha-hover: var(--orange-a75);
    --color-background-warning-soft-alpha-active: var(--orange-a75);
    --color-background-warning-solid: var(--orange-500);
    --color-background-warning-solid-hover: var(--orange-600);
    --color-background-warning-solid-active: var(--orange-600);
    --color-text-warning-solid: var(--white);
    --color-background-warning-outline-hover: var(--orange-a25);
    --color-background-warning-outline-active: var(--orange-a25);
    --color-border-warning-outline: var(--orange-500);
    --color-border-warning-outline-hover: var(--orange-500);
    --color-text-warning-outline: var(--orange-500);
    --color-text-warning-outline-hover: var(--orange-500);
    --color-background-warning-ghost-hover: var(--orange-a50);
    --color-background-warning-ghost-active: var(--orange-a50);
    --color-text-warning-ghost: var(--orange-500);
    --color-text-warning-ghost-hover: var(--orange-500);
    --color-ring-warning: var(--color-ring);
    --color-ring-warning-soft: var(--color-ring-warning);
    --color-ring-warning-solid: var(--color-ring-warning);
    --color-ring-warning-outline: var(--color-ring-warning);
    --color-ring-warning-ghost: var(--color-ring-warning);
    --color-text-caution-hover: var(--yellow-800);
    --color-background-caution-soft: var(--yellow-50);
    --color-background-caution-soft-hover: var(--yellow-75);
    --color-background-caution-soft-active: var(--yellow-75);
    --color-background-caution-soft-alpha: var(--yellow-a50);
    --color-background-caution-soft-alpha-hover: var(--yellow-a75);
    --color-background-caution-soft-alpha-active: var(--yellow-a75);
    --color-background-caution-solid: var(--yellow-600);
    --color-background-caution-solid-hover: var(--yellow-700);
    --color-background-caution-solid-active: var(--yellow-700);
    --color-text-caution-solid: var(--white);
    --color-background-caution-outline-hover: var(--yellow-a25);
    --color-background-caution-outline-active: var(--yellow-a25);
    --color-border-caution-outline: var(--yellow-700);
    --color-border-caution-outline-hover: var(--yellow-700);
    --color-text-caution-outline: var(--yellow-700);
    --color-text-caution-outline-hover: var(--yellow-700);
    --color-background-caution-ghost-hover: var(--yellow-a50);
    --color-background-caution-ghost-active: var(--yellow-a50);
    --color-text-caution-ghost: var(--yellow-700);
    --color-text-caution-ghost-hover: var(--yellow-700);
    --color-ring-caution: var(--color-ring);
    --color-ring-caution-soft: var(--color-ring-caution);
    --color-ring-caution-solid: var(--color-ring-caution);
    --color-ring-caution-outline: var(--color-ring-caution);
    --color-ring-caution-ghost: var(--color-ring-caution);
    --color-background-danger-soft: var(--red-50);
    --color-background-danger-soft-hover: var(--red-75);
    --color-background-danger-soft-active: var(--red-75);
    --color-background-danger-soft-alpha: var(--red-a50);
    --color-background-danger-soft-alpha-hover: var(--red-a75);
    --color-background-danger-soft-alpha-active: var(--red-a75);
    --color-background-danger-solid: var(--red-500);
    --color-background-danger-solid-hover: var(--red-600);
    --color-background-danger-solid-active: var(--red-600);
    --color-text-danger-solid: var(--white);
    --color-background-danger-outline-hover: var(--red-a25);
    --color-background-danger-outline-active: var(--red-a25);
    --color-border-danger-outline: var(--red-500);
    --color-border-danger-outline-hover: var(--red-500);
    --color-text-danger-outline: var(--red-500);
    --color-text-danger-outline-hover: var(--red-500);
    --color-background-danger-ghost-hover: var(--red-a50);
    --color-background-danger-ghost-active: var(--red-a50);
    --color-text-danger-ghost: var(--red-500);
    --color-text-danger-ghost-hover: var(--red-500);
    --color-ring-danger: var(--red-200);
    --color-ring-danger-soft: var(--color-ring-danger);
    --color-ring-danger-solid: var(--color-ring-danger);
    --color-ring-danger-outline: var(--color-ring-danger);
    --color-ring-danger-ghost: var(--color-ring-danger);
    --color-background-success-soft: var(--green-50);
    --color-background-success-soft-hover: var(--green-75);
    --color-background-success-soft-active: var(--green-75);
    --color-background-success-soft-alpha: var(--green-a50);
    --color-background-success-soft-alpha-hover: var(--green-a75);
    --color-background-success-soft-alpha-active: var(--green-a75);
    --color-text-success-solid: var(--white);
    --color-background-success-outline-hover: var(--green-a25);
    --color-background-success-outline-active: var(--green-a25);
    --color-text-success-outline: var(--green-500);
    --color-text-success-outline-hover: var(--green-500);
    --color-background-success-ghost-hover: var(--green-a50);
    --color-background-success-ghost-active: var(--green-a50);
    --color-text-success-ghost: var(--green-500);
    --color-text-success-ghost-hover: var(--green-500);
    --color-ring-success: var(--color-ring);
    --color-ring-success-soft: var(--color-ring-info);
    --color-ring-success-solid: var(--color-ring-info);
    --color-ring-success-outline: var(--color-ring-info);
    --color-ring-success-ghost: var(--color-ring-info);
    --color-background-discovery-soft: var(--purple-50);
    --color-background-discovery-soft-hover: var(--purple-75);
    --color-background-discovery-soft-active: var(--purple-75);
    --color-background-discovery-soft-alpha: var(--purple-a50);
    --color-background-discovery-soft-alpha-hover: var(--purple-a75);
    --color-background-discovery-soft-alpha-active: var(--purple-a75);
    --color-background-discovery-solid: var(--purple-400);
    --color-background-discovery-solid-hover: var(--purple-500);
    --color-background-discovery-solid-active: var(--purple-500);
    --color-text-discovery-solid: var(--white);
    --color-background-discovery-outline-hover: var(--purple-a25);
    --color-background-discovery-outline-active: var(--purple-a25);
    --color-border-discovery-outline: var(--purple-500);
    --color-border-discovery-outline-hover: var(--purple-500);
    --color-background-discovery-ghost-hover: var(--purple-a50);
    --color-background-discovery-ghost-active: var(--purple-a50);
    --color-text-discovery-ghost: var(--purple-500);
    --color-text-discovery-ghost-hover: var(--purple-500);
    --color-ring-discovery: var(--color-ring);
    --color-ring-discovery-soft: var(--color-ring);
    --color-ring-discovery-solid: var(--color-ring);
    --color-ring-discovery-outline: var(--color-ring);
    --color-ring-discovery-ghost: var(--color-ring);
    --color-background-disabled: var(--alpha-05);
    --color-border-disabled: var(--alpha-06);
    --font-tracking-wide: 0em;
    --font-tracking-normal: 0em;
    --font-tracking-tight: 0em;
    --font-heading-5xl-size: 4.5rem;
    --font-heading-5xl-line-height: 4.5rem;
    --font-heading-5xl-weight: var(--font-weight-semibold);
    --font-heading-5xl-tracking: var(--tracking-tight);
    --font-heading-4xl-size: 3.75rem;
    --font-heading-4xl-line-height: 3.75rem;
    --font-heading-4xl-weight: var(--font-weight-semibold);
    --font-heading-4xl-tracking: var(--tracking-tight);
    --font-heading-3xl-size: 3rem;
    --font-heading-3xl-line-height: 3rem;
    --font-heading-3xl-weight: var(--font-weight-semibold);
    --font-heading-3xl-tracking: var(--tracking-tight);
    --font-heading-2xl-size: 2.25rem;
    --font-heading-2xl-line-height: 2.625rem;
    --font-heading-2xl-weight: var(--font-weight-semibold);
    --font-heading-2xl-tracking: var(--tracking-tight);
    --font-heading-xl-size: 2rem;
    --font-heading-xl-line-height: 2.375rem;
    --font-heading-xl-weight: var(--font-weight-semibold);
    --font-heading-xl-tracking: var(--tracking-tight);
    --font-heading-lg-size: 1.5rem;
    --font-heading-lg-line-height: 1.75rem;
    --font-heading-lg-weight: var(--font-weight-semibold);
    --font-heading-lg-tracking: var(--tracking-normal);
    --font-heading-md-size: 1.25rem;
    --font-heading-md-line-height: 1.625rem;
    --font-heading-md-weight: var(--font-weight-semibold);
    --font-heading-md-tracking: var(--tracking-normal);
    --font-heading-sm-size: 1.125rem;
    --font-heading-sm-line-height: 1.625rem;
    --font-heading-sm-weight: var(--font-weight-semibold);
    --font-heading-sm-tracking: var(--tracking-normal);
    --font-heading-xs-size: 1rem;
    --font-heading-xs-line-height: 1.5rem;
    --font-heading-xs-weight: var(--font-weight-semibold);
    --font-heading-xs-tracking: var(--tracking-normal);
    --font-text-lg-size: 1.125rem;
    --font-text-lg-line-height: 1.8125rem;
    --font-text-lg-weight: var(--font-weight-normal);
    --font-text-lg-tracking: var(--tracking-normal);
    --font-text-md-size: 1rem;
    --font-text-md-line-height: 1.5rem;
    --font-text-md-weight: var(--font-weight-normal);
    --font-text-md-tracking: var(--tracking-normal);
    --font-text-sm-size: 0.875rem;
    --font-text-sm-line-height: 1.25rem;
    --font-text-sm-weight: var(--font-weight-normal);
    --font-text-sm-tracking: var(--tracking-normal);
    --font-text-xs-size: 0.75rem;
    --font-text-xs-line-height: 1.125rem;
    --font-text-xs-weight: var(--font-weight-normal);
    --font-text-xs-tracking: var(--tracking-wide);
    --font-text-2xs-size: 0.625rem;
    --font-text-2xs-line-height: 0.875rem;
    --font-text-2xs-weight: var(--font-weight-normal);
    --font-text-2xs-tracking: var(--tracking-wide);
    --font-text-3xs-size: 0.5rem;
    --font-text-3xs-line-height: 0.75rem;
    --font-text-3xs-weight: var(--font-weight-normal);
    --font-text-3xs-tracking: var(--tracking-wide);
    --control-size-3xs: 1.375rem;
    --control-size-2xs: 1.5rem;
    --control-size-xs: 1.625rem;
    --control-size-sm: 1.75rem;
    --control-size-md: 2rem;
    --control-size-lg: 2.25rem;
    --control-size-xl: 2.5rem;
    --control-size-2xl: 2.75rem;
    --control-size-3xl: 3rem;
    --control-gutter-2xs: 0.375rem;
    --control-gutter-xs: 0.5rem;
    --control-gutter-sm: 0.625rem;
    --control-gutter-md: 0.75rem;
    --control-gutter-lg: 0.875rem;
    --control-gutter-xl: 1rem;
    --control-gutter-pill-scaling: 1.33;
    --control-radius-sm: var(--radius-sm);
    --control-radius-md: var(--radius-md);
    --control-radius-lg: var(--radius-lg);
    --control-radius-xl: var(--radius-xl);
    --control-font-size-sm: var(--font-text-xs-size);
    --control-font-size-md: var(--font-text-sm-size);
    --control-font-size-lg: var(--font-text-md-size);
    --control-icon-size-xs: 0.875rem;
    --control-icon-size-sm: 1rem;
    --control-icon-size-md: 1.125rem;
    --control-icon-size-lg: 1.25rem;
    --control-icon-size-xl: 1.375rem;
    --control-icon-size-2xl: 1.5rem;
    --cubic-enter: cubic-bezier(0.19, 1, 0.22, 1);
    --cubic-exit: cubic-bezier(0.8, 0, 0.4, 1);
    --cubic-exit-snappy: cubic-bezier(0.65, 0, 0.4, 1);
    --cubic-move: cubic-bezier(0.65, 0, 0.35, 1);
    --transition-duration-basic: 150ms;
    --transition-ease-basic: ease;
    --scrollbar-color: var(--alpha-30);
    --shadow-hairline: 0 0 0 var(--shadow-hairline-width) var(--shadow-hairline-color);
    --shadow-100: var(--elevation-100-geo) rgb(var(--shadow-color) / var(--shadow-alpha-100));
    --shadow-100-strong: var(--elevation-100-geo)
      rgb(var(--shadow-color) / calc(var(--shadow-alpha-100) * 1.25));
    --shadow-100-stronger: var(--elevation-100-geo)
      rgb(var(--shadow-color) / calc(var(--shadow-alpha-100) * 1.6));
    --shadow-200: var(--elevation-200-geo) rgb(var(--shadow-color) / var(--shadow-alpha-200));
    --shadow-200-strong: var(--elevation-200-geo)
      rgb(var(--shadow-color) / calc(var(--shadow-alpha-200) * 1.25));
    --shadow-200-stronger: var(--elevation-200-geo)
      rgb(var(--shadow-color) / calc(var(--shadow-alpha-200) * 1.6));
    --shadow-300: var(--elevation-300-geo) rgb(var(--shadow-color) / var(--shadow-alpha-300));
    --shadow-300-strong: var(--elevation-300-geo)
      rgb(var(--shadow-color) / calc(var(--shadow-alpha-300) * 1.25));
    --shadow-300-stronger: var(--elevation-300-geo)
      rgb(var(--shadow-color) / calc(var(--shadow-alpha-300) * 1.6));
    --shadow-400: var(--elevation-400-geo) rgb(var(--shadow-color) / var(--shadow-alpha-400));
    --shadow-400-strong: var(--elevation-400-geo)
      rgb(var(--shadow-color) / calc(var(--shadow-alpha-400) * 1.25));
    --shadow-400-stronger: var(--elevation-400-geo)
      rgb(var(--shadow-color) / calc(var(--shadow-alpha-400) * 1.6));
  }
  :where(:root), :where([data-theme="light"]) {
    --color-text-secondary: var(--gray-500);
    --color-text-tertiary: var(--gray-400);
    --color-ring: var(--blue-500);
    --color-background-primary-soft: var(--gray-100);
    --color-background-primary-soft-hover: var(--gray-150);
    --color-background-primary-soft-active: var(--gray-200);
    --color-background-primary-soft-alpha: var(--alpha-08);
    --color-background-primary-soft-alpha-hover: var(--alpha-12);
    --color-background-primary-soft-alpha-active: var(--alpha-16);
    --color-background-primary-surface: var(--alpha-05);
    --color-border-primary-surface: var(--alpha-05);
    --color-background-primary-solid: var(--gray-900);
    --color-background-primary-solid-hover: var(--gray-700);
    --color-background-primary-solid-active: var(--gray-600);
    --color-background-primary-outline-hover: var(--alpha-02);
    --color-background-primary-outline-active: var(--alpha-04);
    --color-border-primary-outline: var(--alpha-16);
    --color-border-primary-outline-hover: var(--alpha-20);
    --color-background-primary-ghost-hover: var(--alpha-08);
    --color-background-primary-ghost-active: var(--alpha-12);
    --color-background-secondary-soft: var(--gray-100);
    --color-background-secondary-soft-hover: var(--gray-150);
    --color-background-secondary-soft-active: var(--gray-200);
    --color-background-secondary-soft-alpha: var(--alpha-08);
    --color-background-secondary-soft-alpha-hover: var(--alpha-12);
    --color-background-secondary-soft-alpha-active: var(--alpha-16);
    --color-background-secondary-solid: var(--gray-500);
    --color-background-secondary-solid-hover: var(--gray-600);
    --color-background-secondary-solid-active: var(--gray-700);
    --color-background-secondary-outline-hover: var(--alpha-02);
    --color-background-secondary-outline-active: var(--alpha-04);
    --color-border-secondary-outline: var(--alpha-16);
    --color-border-secondary-outline-hover: var(--alpha-20);
    --color-background-secondary-ghost-hover: var(--alpha-08);
    --color-background-secondary-ghost-active: var(--alpha-12);
    --color-text-info: var(--blue-500);
    --color-text-info-soft: var(--blue-600);
    --color-background-info-surface: var(--blue-a25);
    --color-border-info-surface: var(--blue-a25);
    --color-text-info-surface: var(--blue-600);
    --color-text-info-ghost: var(--blue-500);
    --color-text-info-ghost-hover: var(--blue-500);
    --color-text-warning: var(--orange-700);
    --color-text-warning-soft: var(--orange-700);
    --color-background-warning-surface: var(--orange-a25);
    --color-border-warning-surface: var(--orange-a25);
    --color-text-warning-surface: var(--orange-700);
    --color-text-caution: var(--yellow-700);
    --color-text-caution-soft: var(--yellow-800);
    --color-background-caution-surface: var(--yellow-a25);
    --color-border-caution-surface: var(--yellow-a25);
    --color-text-caution-surface: var(--yellow-800);
    --color-text-danger: var(--red-700);
    --color-text-danger-soft: var(--red-600);
    --color-background-danger-surface: var(--red-a25);
    --color-border-danger-surface: var(--red-a25);
    --color-text-danger-surface: var(--red-600);
    --color-text-success: var(--green-700);
    --color-text-success-soft: var(--green-600);
    --color-background-success-surface: var(--green-a25);
    --color-border-success-surface: var(--green-a25);
    --color-text-success-surface: var(--green-600);
    --color-background-success-solid: var(--green-500);
    --color-background-success-solid-hover: var(--green-500);
    --color-background-success-solid-active: var(--green-500);
    --color-border-success-outline: var(--green-500);
    --color-border-success-outline-hover: var(--green-500);
    --color-text-discovery: var(--purple-700);
    --color-text-discovery-soft: var(--purple-600);
    --color-background-discovery-surface: var(--purple-a25);
    --color-border-discovery-surface: var(--purple-a25);
    --color-text-discovery-surface: var(--purple-600);
    --color-text-discovery-outline: var(--purple-500);
    --color-text-discovery-outline-hover: var(--purple-500);
    --color-text-disabled: var(--gray-400);
    --color-border-subtle: var(--alpha-05);
    --color-border: var(--alpha-10);
    --color-border-strong: var(--alpha-15);
    --shadow: 0 10px 15px -3px rgba(0 0 0 / 10%),
      0 4px 6px -4px rgba(0 0 0 / 10%);
    --color-surface: var(--gray-0);
    --color-surface-secondary: var(--gray-50);
    --color-surface-tertiary: var(--gray-75);
    --color-surface-elevated: var(--gray-0);
    --color-surface-elevated-secondary: var(--gray-50)
  ;
  }
  :where([data-theme="dark"]) {
    --color-text-secondary: var(--gray-700);
    --color-text-tertiary: var(--gray-600);
    --color-ring: var(--blue-400);
    --color-background-primary-soft: var(--gray-300);
    --color-background-primary-soft-hover: var(--gray-350);
    --color-background-primary-soft-active: var(--gray-400);
    --color-background-primary-soft-alpha: var(--alpha-12);
    --color-background-primary-soft-alpha-hover: var(--alpha-16);
    --color-background-primary-soft-alpha-active: var(--alpha-20);
    --color-background-primary-surface: var(--alpha-08);
    --color-border-primary-surface: var(--alpha-08);
    --color-background-primary-solid: var(--gray-950);
    --color-background-primary-solid-hover: var(--gray-900);
    --color-background-primary-solid-active: var(--gray-850);
    --color-background-primary-outline-hover: var(--alpha-04);
    --color-background-primary-outline-active: var(--alpha-06);
    --color-border-primary-outline: var(--alpha-25);
    --color-border-primary-outline-hover: var(--alpha-30);
    --color-background-primary-ghost-hover: var(--alpha-12);
    --color-background-primary-ghost-active: var(--alpha-16);
    --color-background-secondary-soft: var(--gray-300);
    --color-background-secondary-soft-hover: var(--gray-350);
    --color-background-secondary-soft-active: var(--gray-400);
    --color-background-secondary-soft-alpha: var(--alpha-12);
    --color-background-secondary-soft-alpha-hover: var(--alpha-16);
    --color-background-secondary-soft-alpha-active: var(--alpha-20);
    --color-background-secondary-solid: var(--gray-400);
    --color-background-secondary-solid-hover: var(--gray-450);
    --color-background-secondary-solid-active: var(--gray-500);
    --color-background-secondary-outline-hover: var(--alpha-04);
    --color-background-secondary-outline-active: var(--alpha-06);
    --color-border-secondary-outline: var(--alpha-25);
    --color-border-secondary-outline-hover: var(--alpha-30);
    --color-background-secondary-ghost-hover: var(--alpha-12);
    --color-background-secondary-ghost-active: var(--alpha-16);
    --color-text-info: var(--blue-200);
    --color-text-info-soft: var(--blue-300);
    --color-background-info-surface: var(--blue-a50);
    --color-border-info-surface: var(--blue-a50);
    --color-text-info-surface: var(--blue-300);
    --color-text-info-ghost: var(--blue-200);
    --color-text-info-ghost-hover: var(--blue-200);
    --color-text-warning: var(--orange-500);
    --color-text-warning-soft: var(--orange-400);
    --color-background-warning-surface: var(--orange-a50);
    --color-border-warning-surface: var(--orange-a50);
    --color-text-warning-surface: var(--orange-400);
    --color-text-caution: var(--yellow-500);
    --color-text-caution-soft: var(--yellow-400);
    --color-background-caution-surface: var(--yellow-a50);
    --color-border-caution-surface: var(--yellow-a50);
    --color-text-caution-surface: var(--yellow-400);
    --color-text-danger: var(--red-500);
    --color-text-danger-soft: var(--red-400);
    --color-background-danger-surface: var(--red-a50);
    --color-border-danger-surface: var(--red-a50);
    --color-text-danger-surface: var(--red-400);
    --color-text-success: var(--green-400);
    --color-text-success-soft: var(--green-400);
    --color-background-success-surface: var(--green-a50);
    --color-border-success-surface: var(--green-a50);
    --color-text-success-surface: var(--green-400);
    --color-background-success-solid: var(--green-600);
    --color-background-success-solid-hover: var(--green-600);
    --color-background-success-solid-active: var(--green-600);
    --color-border-success-outline: var(--green-600);
    --color-border-success-outline-hover: var(--green-600);
    --color-text-discovery: var(--purple-500);
    --color-text-discovery-soft: var(--purple-200);
    --color-background-discovery-surface: var(--purple-a50);
    --color-border-discovery-surface: var(--purple-a50);
    --color-text-discovery-surface: var(--purple-200);
    --color-text-discovery-outline: var(--purple-400);
    --color-text-discovery-outline-hover: var(--purple-400);
    --color-text-disabled: var(--gray-500);
    --color-border-subtle: var(--alpha-06);
    --color-border: var(--alpha-12);
    --color-border-strong: var(--alpha-20);
    --shadow: 0 10px 15px -3px rgba(0 0 0 / 20%),
      0 4px 6px -4px rgba(0 0 0 / 20%);
    --color-surface: var(--gray-200);
    --color-surface-secondary: var(--gray-100);
    --color-surface-tertiary: var(--gray-50);
    --color-surface-elevated: var(--gray-300);
    --color-surface-elevated-secondary: var(--gray-400)
  ;
  }
}
@layer theme {
  :root,
  :where([data-theme]) {
    --alert-border-radius: var(--radius-xl);
    --alert-gap: calc(var(--spacing) * 3);
    --alert-gutter: calc(var(--spacing) * 4);
    --alert-font-size: var(--font-text-sm-size);
    --alert-line-height: var(--font-text-sm-line-height);
    --alert-title-font-weight: var(--font-weight-semibold);
    --avatar-radius: var(--radius-full);
    --avatar-size: 28px;
    --avatar-font-size-scaling: 0.5;
    --avatar-overflow-font-size-scaling-one: 0.45;
    --avatar-overflow-font-size-scaling-two: 0.37;
    --avatar-overflow-font-size-scaling-three: 0.3;
    --avatar-group-cutout-width: 3px;
    --avatar-group-cutout-color: var(--color-surface);
    --avatar-group-spacing: -8px;
    --badge-gutter-sm: calc(var(--control-gutter-2xs) - 1px);
    --badge-gutter-md: var(--control-gutter-2xs);
    --badge-gutter-lg: var(--control-gutter-xs);
    --badge-size-sm: calc(var(--control-size-3xs) - 2px);
    --badge-size-md: var(--control-size-3xs);
    --badge-size-lg: var(--control-size-2xs);
    --badge-radius-sm: var(--radius-xs);
    --badge-radius-md: var(--radius-xs);
    --badge-radius-lg: var(--radius-sm);
    --badge-font-size-sm: var(--font-text-xs-size);
    --badge-font-size-md: var(--font-text-sm-size);
    --badge-font-size-lg: var(--font-text-sm-size);
    --badge-tracking-sm: var(--tracking-wide);
    --badge-tracking-md: var(--tracking-normal);
    --badge-tracking-lg: var(--tracking-normal);
    --badge-font-weight-sm: var(--font-weight-semibold);
    --badge-font-weight-md: var(--font-weight-semibold);
    --badge-font-weight-lg: var(--font-weight-semibold);
    --badge-icon-font-size-sm: var(--font-text-xs-size);
    --badge-icon-font-size-md: var(--font-text-md-size);
    --badge-icon-font-size-lg: var(--font-text-md-size);
    --badge-indicator-size-sm: var(--font-text-xs-size);
    --badge-indicator-size-md: var(--font-text-xs-size);
    --badge-indicator-size-lg: var(--font-text-sm-size);
    --button-gap-sm: 3px;
    --button-gap-md: 4px;
    --button-gap-lg: 6px;
    --button-font-weight: var(--font-weight-medium);
    --input-gap-xs: 4px;
    --input-gap-sm: 6px;
    --input-gap-md: 8px;
    --input-gap-lg: 10px;
    --input-text-color: var(--color-text);
    --input-placeholder-text-color: var(--color-text-tertiary);
    --input-outline-border-color: var(--color-border-primary-outline);
    --input-outline-border-color-focus: var(--alpha-50);
    --input-soft-background-color: var(--color-background-primary-soft-alpha);
    --input-soft-border-color-focus: var(--alpha-20);
    --link-font-weight: inherit;
    --link-gap: calc(var(--spacing) * 0.5);
    --link-radius: var(--radius-sm);
    --link-underline-decoration-offset: 0.1em;
    --chat-max-width: 800px;
    --chat-gutter: calc(var(--spacing) * 5);
    --chat-background-color: var(--color-surface);
    --thread-gutter: calc(var(--spacing) * 4);
    --composer-gutter: calc(var(--spacing) * 3);
    --composer-compact-gutter: calc(var(--spacing) * 2);
    --composer-radius: var(--radius-4xl);
    --composer-background-color: var(--color-surface-elevated);
    --smoothing-background-color: var(--color-surface);
    --user-message-text-color: var(--color-text);
    --source-list-gutter: var(--thread-gutter);
    --codeblock-background-color: var(--gray-25);
    --codeblock-syntax-4: var(--pink-500);
    --dialog-min-width: 250px;
    --dialog-max-width: 450px;
    --dialog-container-inner-padding: calc(var(--spacing) * 5);
    --dialog-backdrop-fade-background: var(--color-surface-elevated);
    @supports (color: color-mix(in lab, red, red)) {
      --dialog-backdrop-fade-background: color-mix(in oklab, var(--color-surface-elevated) 60%, transparent);
    }
    --menu-gutter: calc(var(--spacing) * 1.5);
    --menu-radius: var(--radius-xl);
    --menu-font-size: var(--font-text-sm-size);
    --menu-line-height: var(--font-text-sm-line-height);
    --menu-item-padding: calc(var(--spacing) * 1.5) calc(var(--spacing) * 2);
    --menu-item-gap: calc(var(--spacing) * 1.5);
    --menu-separator-gutter: var(--menu-gutter) calc(-1 * var(--menu-gutter));
    --menu-separator-background-color: var(--color-border);
    --menu-radio-indicator-size: var(--font-text-lg-size);
    --menu-radio-indicator-hole-size: var(--font-text-3xs-size);
    --menu-checkbox-indicator-size: var(--font-text-lg-size);
    --modal-container-inner-padding: calc(var(--spacing) * 5);
    --popover-radius: var(--radius-xl);
    --radio-group-col-gap: calc(var(--spacing) * 2.5);
    --radio-group-row-gap: calc(var(--spacing) * 5);
    --radio-group-item-gap: calc(var(--spacing) * 1.5);
    --radio-group-item-font-size: var(--font-text-sm-size);
    --radio-group-item-line-height: var(--font-text-sm-line-height);
    --radio-group-indicator-size: var(--font-text-md-size);
    --radio-group-indicator-border-color: var(--color-border-primary-outline);
    --radio-group-indicator-border-color-hover: var(--alpha-25);
    --radio-group-indicator-background-color: var(--color-background-primary-solid);
    --radio-group-indicator-hole-size: 0.375rem;
    --radio-group-indicator-hole-background-color: var(--color-text-primary-solid);
    --segmented-control-gap: 2px;
    --segmented-control-gutter: 2px;
    --segmented-control-font-weight: var(--font-weight-semibold);
    --segmented-control-thumb-shadow: 0 1px 4px -1px rgb(0 0 0 / 20%);
    --segmented-control-option-highlight-gutter: 1px;
    --select-control-font-weight: var(--font-weight-medium);
    --switch-track-width: 32px;
    --switch-track-height: 19px;
    --switch-thumb-offset: 3px;
    --switch-thumb-size: calc(var(--switch-track-height) - 2 * var(--switch-thumb-offset));
    --switch-thumb-shadow: 0 1px 2px rgb(0 0 0 / 20%);
    --switch-label-gap: calc(var(--spacing) * 2);
  }
  :where(:root), :where([data-theme="light"]) {
    --avatar-image-border-color: var(--alpha-04);
    --input-outline-border-color-hover: var(--alpha-25);
    --input-border-color-invalid: var(--red-500);
    --link-primary-text-color: var(--blue-500);
    --link-primary-text-color-hover: var(--blue-800);
    --user-message-background-color: var(--alpha-05);
    --codeblock-syntax-1: #c0660d;
    --codeblock-syntax-2: var(--blue-500);
    --codeblock-syntax-3: var(--green-600);
    --codeblock-syntax-5: var(--purple-500);
    --dialog-backdrop-dim-background: rgb(0 0 0 / 30%);
    --menu-item-background-color: var(--alpha-08);
    --modal-backdrop-background: rgb(0 0 0 / 30%);
    --segmented-control-background: var(--gray-100);
    --segmented-control-thumb-background: var(--gray-0);
    --segmented-control-option-highlight-background-color: var(--gray-200);
    --slider-track-color: var(--gray-150);
    --slider-range-color: var(--gray-450);
    --switch-track-color: var(--gray-150);
    --switch-track-color-hover: var(--gray-200);
    --switch-track-color-checked: var(--gray-900);
    --switch-track-color-checked-disabled: var(--gray-300);
    --switch-track-color-disabled: var(--gray-100);
    --switch-thumb-color: var(--gray-0);
    --switch-thumb-color-disabled: var(--gray-0);
  }
  :where([data-theme="dark"]) {
    --avatar-image-border-color: var(--alpha-15);
    --input-outline-border-color-hover: var(--alpha-30);
    --input-border-color-invalid: var(--red-600);
    --link-primary-text-color: var(--blue-300);
    --link-primary-text-color-hover: var(--blue-400);
    --user-message-background-color: var(--alpha-08);
    --codeblock-syntax-1: var(--yellow-100);
    --codeblock-syntax-2: var(--blue-200);
    --codeblock-syntax-3: var(--green-300);
    --codeblock-syntax-5: var(--purple-300);
    --dialog-backdrop-dim-background: rgb(0 0 0 / 50%);
    --menu-item-background-color: var(--alpha-10);
    --modal-backdrop-background: rgb(0 0 0 / 50%);
    --segmented-control-background: var(--gray-0);
    --segmented-control-thumb-background: var(--gray-300);
    --segmented-control-option-highlight-background-color: var(--gray-300);
    --slider-track-color: var(--gray-400);
    --slider-range-color: var(--gray-600);
    --switch-track-color: var(--gray-400);
    --switch-track-color-hover: var(--gray-450);
    --switch-track-color-checked: var(--blue-400);
    --switch-track-color-checked-disabled: var(--blue-700);
    --switch-track-color-disabled: var(--gray-300);
    --switch-thumb-color: var(--gray-1000);
    --switch-thumb-color-disabled: var(--gray-800);
  }
}
@layer base {
  html,
  :host {
    color: var(--color-text);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    letter-spacing: var(--tracking-normal);
  }
  [data-theme="light"] {
    color-scheme: light;
  }
  [data-theme="dark"] {
    color-scheme: dark;
  }
  * {
    scrollbar-color: var(--scrollbar-color) transparent;
    scrollbar-width: thin;
  }
  [data-exiting] {
    pointer-events: none;
  }
  ::-moz-placeholder {
    color: var(--color-text-tertiary);
  }
  ::placeholder {
    color: var(--color-text-tertiary);
  }
  b,
  strong {
    font-weight: var(--font-weight-semibold);
  }
}
@layer base {
  @font-face {
    font-family: "KaTeX_AMS";
    font-style: normal;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_AMS-Regular.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Caligraphic";
    font-style: normal;
    font-weight: 700;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Caligraphic-Bold.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Caligraphic";
    font-style: normal;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Caligraphic-Regular.woff2")
    format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Fraktur";
    font-style: normal;
    font-weight: 700;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Fraktur-Bold.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Fraktur";
    font-style: normal;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Fraktur-Regular.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Main";
    font-style: normal;
    font-weight: 700;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Main-Bold.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Main";
    font-style: italic;
    font-weight: 700;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Main-BoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Main";
    font-style: italic;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Main-Italic.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Main";
    font-style: normal;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Main-Regular.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Math";
    font-style: italic;
    font-weight: 700;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Math-BoldItalic.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Math";
    font-style: italic;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Math-Italic.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_SansSerif";
    font-style: normal;
    font-weight: 700;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_SansSerif-Bold.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_SansSerif";
    font-style: italic;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_SansSerif-Italic.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_SansSerif";
    font-style: normal;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_SansSerif-Regular.woff2")
    format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Script";
    font-style: normal;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Script-Regular.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Size1";
    font-style: normal;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Size1-Regular.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Size2";
    font-style: normal;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Size2-Regular.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Size3";
    font-style: normal;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Size3-Regular.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Size4";
    font-style: normal;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Size4-Regular.woff2") format("woff2");
  }
  @font-face {
    font-family: "KaTeX_Typewriter";
    font-style: normal;
    font-weight: 400;
    src: url("https://cdn.openai.com/common/fonts/katex/KaTeX_Typewriter-Regular.woff2")
    format("woff2");
  }
  .katex {
    font: normal 1.21em "KaTeX_Main",
    "Times New Roman",
    serif;
    line-height: 1.2;
    text-indent: 0;
    text-rendering: auto;
  }
  .katex * {
    border-color: currentcolor;
    -ms-high-contrast-adjust: none !important;
  }
  .katex .katex-version::after {
    content: "0.16.0";
  }
  .katex .katex-mathml {
    position: absolute;
    overflow: hidden;
    width: 1px;
    height: 1px;
    padding: 0;
    border: 0;
    clip: rect(1px, 1px, 1px, 1px);
  }
  .katex .katex-html > .newline {
    display: block;
  }
  .katex .base {
    position: relative;
    width: -moz-min-content;
    width: min-content;
    white-space: nowrap;
  }
  .katex .base,
.katex .strut {
    display: inline-block;
  }
  .katex .textbf {
    font-weight: 700;
  }
  .katex .textit {
    font-style: italic;
  }
  .katex .textrm {
    font-family: "KaTeX_Main";
  }
  .katex .textsf {
    font-family: "KaTeX_SansSerif";
  }
  .katex .texttt {
    font-family: "KaTeX_Typewriter";
  }
  .katex .mathnormal {
    font-family: "KaTeX_Math";
    font-style: italic;
  }
  .katex .mathit {
    font-family: "KaTeX_Main";
    font-style: italic;
  }
  .katex .mathrm {
    font-style: normal;
  }
  .katex .mathbf {
    font-family: "KaTeX_Main";
    font-weight: 700;
  }
  .katex .boldsymbol {
    font-family: "KaTeX_Math";
    font-style: italic;
    font-weight: 700;
  }
  .katex .amsrm,
.katex .mathbb,
.katex .textbb {
    font-family: "KaTeX_AMS";
  }
  .katex .mathcal {
    font-family: "KaTeX_Caligraphic";
  }
  .katex .mathfrak,
.katex .textfrak {
    font-family: "KaTeX_Fraktur";
  }
  .katex .mathtt {
    font-family: "KaTeX_Typewriter";
  }
  .katex .mathscr,
.katex .textscr {
    font-family: "KaTeX_Script";
  }
  .katex .mathsf,
.katex .textsf {
    font-family: "KaTeX_SansSerif";
  }
  .katex .mathboldsf,
.katex .textboldsf {
    font-family: "KaTeX_SansSerif";
    font-weight: 700;
  }
  .katex .mathitsf,
.katex .textitsf {
    font-family: "KaTeX_SansSerif";
    font-style: italic;
  }
  .katex .mainrm {
    font-family: "KaTeX_Main";
    font-style: normal;
  }
  .katex .vlist-t {
    display: inline-table;
    border-collapse: collapse;
    table-layout: fixed;
  }
  .katex .vlist-r {
    display: table-row;
  }
  .katex .vlist {
    position: relative;
    display: table-cell;
    vertical-align: bottom;
  }
  .katex .vlist > span {
    position: relative;
    display: block;
    height: 0;
  }
  .katex .vlist > span > span {
    display: inline-block;
  }
  .katex .vlist > span > .pstrut {
    overflow: hidden;
    width: 0;
  }
  .katex .vlist-t2 {
    margin-right: -2px;
  }
  .katex .vlist-s {
    display: table-cell;
    width: 2px;
    min-width: 2px;
    font-size: 1px;
    vertical-align: bottom;
  }
  .katex .vbox {
    display: inline-flex;
    flex-direction: column;
    align-items: baseline;
  }
  .katex .hbox {
    width: 100%;
  }
  .katex .hbox,
.katex .thinbox {
    display: inline-flex;
    flex-direction: row;
  }
  .katex .thinbox {
    width: 0;
    max-width: 0;
  }
  .katex .msupsub {
    text-align: left;
  }
  .katex .mfrac > span > span {
    text-align: center;
  }
  .katex .mfrac .frac-line {
    display: inline-block;
    width: 100%;
    border-bottom-style: solid;
  }
  .katex .hdashline,
.katex .hline,
.katex .mfrac .frac-line,
.katex .overline .overline-line,
.katex .rule,
.katex .underline .underline-line {
    min-height: 1px;
  }
  .katex .mspace {
    display: inline-block;
  }
  .katex .clap,
.katex .llap,
.katex .rlap {
    position: relative;
    width: 0;
  }
  .katex .clap > .inner,
.katex .llap > .inner,
.katex .rlap > .inner {
    position: absolute;
  }
  .katex .clap > .fix,
.katex .llap > .fix,
.katex .rlap > .fix {
    display: inline-block;
  }
  .katex .llap > .inner {
    right: 0;
  }
  .katex .clap > .inner,
.katex .rlap > .inner {
    left: 0;
  }
  .katex .clap > .inner > span {
    margin-right: 50%;
    margin-left: -50%;
  }
  .katex .rule {
    position: relative;
    display: inline-block;
    border: 0 solid;
  }
  .katex .hline,
.katex .overline .overline-line,
.katex .underline .underline-line {
    display: inline-block;
    width: 100%;
    border-bottom-style: solid;
  }
  .katex .hdashline {
    display: inline-block;
    width: 100%;
    border-bottom-style: dashed;
  }
  .katex .sqrt > .root {
    margin-right: -0.55555556em;
    margin-left: 0.27777778em;
  }
  .katex .fontsize-ensurer.reset-size1.size1,
.katex .sizing.reset-size1.size1 {
    font-size: 1em;
  }
  .katex .fontsize-ensurer.reset-size1.size2,
.katex .sizing.reset-size1.size2 {
    font-size: 1.2em;
  }
  .katex .fontsize-ensurer.reset-size1.size3,
.katex .sizing.reset-size1.size3 {
    font-size: 1.4em;
  }
  .katex .fontsize-ensurer.reset-size1.size4,
.katex .sizing.reset-size1.size4 {
    font-size: 1.6em;
  }
  .katex .fontsize-ensurer.reset-size1.size5,
.katex .sizing.reset-size1.size5 {
    font-size: 1.8em;
  }
  .katex .fontsize-ensurer.reset-size1.size6,
.katex .sizing.reset-size1.size6 {
    font-size: 2em;
  }
  .katex .fontsize-ensurer.reset-size1.size7,
.katex .sizing.reset-size1.size7 {
    font-size: 2.4em;
  }
  .katex .fontsize-ensurer.reset-size1.size8,
.katex .sizing.reset-size1.size8 {
    font-size: 2.88em;
  }
  .katex .fontsize-ensurer.reset-size1.size9,
.katex .sizing.reset-size1.size9 {
    font-size: 3.456em;
  }
  .katex .fontsize-ensurer.reset-size1.size10,
.katex .sizing.reset-size1.size10 {
    font-size: 4.148em;
  }
  .katex .fontsize-ensurer.reset-size1.size11,
.katex .sizing.reset-size1.size11 {
    font-size: 4.976em;
  }
  .katex .fontsize-ensurer.reset-size2.size1,
.katex .sizing.reset-size2.size1 {
    font-size: 0.83333333em;
  }
  .katex .fontsize-ensurer.reset-size2.size2,
.katex .sizing.reset-size2.size2 {
    font-size: 1em;
  }
  .katex .fontsize-ensurer.reset-size2.size3,
.katex .sizing.reset-size2.size3 {
    font-size: 1.16666667em;
  }
  .katex .fontsize-ensurer.reset-size2.size4,
.katex .sizing.reset-size2.size4 {
    font-size: 1.33333333em;
  }
  .katex .fontsize-ensurer.reset-size2.size5,
.katex .sizing.reset-size2.size5 {
    font-size: 1.5em;
  }
  .katex .fontsize-ensurer.reset-size2.size6,
.katex .sizing.reset-size2.size6 {
    font-size: 1.66666667em;
  }
  .katex .fontsize-ensurer.reset-size2.size7,
.katex .sizing.reset-size2.size7 {
    font-size: 2em;
  }
  .katex .fontsize-ensurer.reset-size2.size8,
.katex .sizing.reset-size2.size8 {
    font-size: 2.4em;
  }
  .katex .fontsize-ensurer.reset-size2.size9,
.katex .sizing.reset-size2.size9 {
    font-size: 2.88em;
  }
  .katex .fontsize-ensurer.reset-size2.size10,
.katex .sizing.reset-size2.size10 {
    font-size: 3.45666667em;
  }
  .katex .fontsize-ensurer.reset-size2.size11,
.katex .sizing.reset-size2.size11 {
    font-size: 4.14666667em;
  }
  .katex .fontsize-ensurer.reset-size3.size1,
.katex .sizing.reset-size3.size1 {
    font-size: 0.71428571em;
  }
  .katex .fontsize-ensurer.reset-size3.size2,
.katex .sizing.reset-size3.size2 {
    font-size: 0.85714286em;
  }
  .katex .fontsize-ensurer.reset-size3.size3,
.katex .sizing.reset-size3.size3 {
    font-size: 1em;
  }
  .katex .fontsize-ensurer.reset-size3.size4,
.katex .sizing.reset-size3.size4 {
    font-size: 1.14285714em;
  }
  .katex .fontsize-ensurer.reset-size3.size5,
.katex .sizing.reset-size3.size5 {
    font-size: 1.28571429em;
  }
  .katex .fontsize-ensurer.reset-size3.size6,
.katex .sizing.reset-size3.size6 {
    font-size: 1.42857143em;
  }
  .katex .fontsize-ensurer.reset-size3.size7,
.katex .sizing.reset-size3.size7 {
    font-size: 1.71428571em;
  }
  .katex .fontsize-ensurer.reset-size3.size8,
.katex .sizing.reset-size3.size8 {
    font-size: 2.05714286em;
  }
  .katex .fontsize-ensurer.reset-size3.size9,
.katex .sizing.reset-size3.size9 {
    font-size: 2.46857143em;
  }
  .katex .fontsize-ensurer.reset-size3.size10,
.katex .sizing.reset-size3.size10 {
    font-size: 2.96285714em;
  }
  .katex .fontsize-ensurer.reset-size3.size11,
.katex .sizing.reset-size3.size11 {
    font-size: 3.55428571em;
  }
  .katex .fontsize-ensurer.reset-size4.size1,
.katex .sizing.reset-size4.size1 {
    font-size: 0.625em;
  }
  .katex .fontsize-ensurer.reset-size4.size2,
.katex .sizing.reset-size4.size2 {
    font-size: 0.75em;
  }
  .katex .fontsize-ensurer.reset-size4.size3,
.katex .sizing.reset-size4.size3 {
    font-size: 0.875em;
  }
  .katex .fontsize-ensurer.reset-size4.size4,
.katex .sizing.reset-size4.size4 {
    font-size: 1em;
  }
  .katex .fontsize-ensurer.reset-size4.size5,
.katex .sizing.reset-size4.size5 {
    font-size: 1.125em;
  }
  .katex .fontsize-ensurer.reset-size4.size6,
.katex .sizing.reset-size4.size6 {
    font-size: 1.25em;
  }
  .katex .fontsize-ensurer.reset-size4.size7,
.katex .sizing.reset-size4.size7 {
    font-size: 1.5em;
  }
  .katex .fontsize-ensurer.reset-size4.size8,
.katex .sizing.reset-size4.size8 {
    font-size: 1.8em;
  }
  .katex .fontsize-ensurer.reset-size4.size9,
.katex .sizing.reset-size4.size9 {
    font-size: 2.16em;
  }
  .katex .fontsize-ensurer.reset-size4.size10,
.katex .sizing.reset-size4.size10 {
    font-size: 2.5925em;
  }
  .katex .fontsize-ensurer.reset-size4.size11,
.katex .sizing.reset-size4.size11 {
    font-size: 3.11em;
  }
  .katex .fontsize-ensurer.reset-size5.size1,
.katex .sizing.reset-size5.size1 {
    font-size: 0.55555556em;
  }
  .katex .fontsize-ensurer.reset-size5.size2,
.katex .sizing.reset-size5.size2 {
    font-size: 0.66666667em;
  }
  .katex .fontsize-ensurer.reset-size5.size3,
.katex .sizing.reset-size5.size3 {
    font-size: 0.77777778em;
  }
  .katex .fontsize-ensurer.reset-size5.size4,
.katex .sizing.reset-size5.size4 {
    font-size: 0.88888889em;
  }
  .katex .fontsize-ensurer.reset-size5.size5,
.katex .sizing.reset-size5.size5 {
    font-size: 1em;
  }
  .katex .fontsize-ensurer.reset-size5.size6,
.katex .sizing.reset-size5.size6 {
    font-size: 1.11111111em;
  }
  .katex .fontsize-ensurer.reset-size5.size7,
.katex .sizing.reset-size5.size7 {
    font-size: 1.33333333em;
  }
  .katex .fontsize-ensurer.reset-size5.size8,
.katex .sizing.reset-size5.size8 {
    font-size: 1.6em;
  }
  .katex .fontsize-ensurer.reset-size5.size9,
.katex .sizing.reset-size5.size9 {
    font-size: 1.92em;
  }
  .katex .fontsize-ensurer.reset-size5.size10,
.katex .sizing.reset-size5.size10 {
    font-size: 2.30444444em;
  }
  .katex .fontsize-ensurer.reset-size5.size11,
.katex .sizing.reset-size5.size11 {
    font-size: 2.76444444em;
  }
  .katex .fontsize-ensurer.reset-size6.size1,
.katex .sizing.reset-size6.size1 {
    font-size: 0.5em;
  }
  .katex .fontsize-ensurer.reset-size6.size2,
.katex .sizing.reset-size6.size2 {
    font-size: 0.6em;
  }
  .katex .fontsize-ensurer.reset-size6.size3,
.katex .sizing.reset-size6.size3 {
    font-size: 0.7em;
  }
  .katex .fontsize-ensurer.reset-size6.size4,
.katex .sizing.reset-size6.size4 {
    font-size: 0.8em;
  }
  .katex .fontsize-ensurer.reset-size6.size5,
.katex .sizing.reset-size6.size5 {
    font-size: 0.9em;
  }
  .katex .fontsize-ensurer.reset-size6.size6,
.katex .sizing.reset-size6.size6 {
    font-size: 1em;
  }
  .katex .fontsize-ensurer.reset-size6.size7,
.katex .sizing.reset-size6.size7 {
    font-size: 1.2em;
  }
  .katex .fontsize-ensurer.reset-size6.size8,
.katex .sizing.reset-size6.size8 {
    font-size: 1.44em;
  }
  .katex .fontsize-ensurer.reset-size6.size9,
.katex .sizing.reset-size6.size9 {
    font-size: 1.728em;
  }
  .katex .fontsize-ensurer.reset-size6.size10,
.katex .sizing.reset-size6.size10 {
    font-size: 2.074em;
  }
  .katex .fontsize-ensurer.reset-size6.size11,
.katex .sizing.reset-size6.size11 {
    font-size: 2.488em;
  }
  .katex .fontsize-ensurer.reset-size7.size1,
.katex .sizing.reset-size7.size1 {
    font-size: 0.41666667em;
  }
  .katex .fontsize-ensurer.reset-size7.size2,
.katex .sizing.reset-size7.size2 {
    font-size: 0.5em;
  }
  .katex .fontsize-ensurer.reset-size7.size3,
.katex .sizing.reset-size7.size3 {
    font-size: 0.58333333em;
  }
  .katex .fontsize-ensurer.reset-size7.size4,
.katex .sizing.reset-size7.size4 {
    font-size: 0.66666667em;
  }
  .katex .fontsize-ensurer.reset-size7.size5,
.katex .sizing.reset-size7.size5 {
    font-size: 0.75em;
  }
  .katex .fontsize-ensurer.reset-size7.size6,
.katex .sizing.reset-size7.size6 {
    font-size: 0.83333333em;
  }
  .katex .fontsize-ensurer.reset-size7.size7,
.katex .sizing.reset-size7.size7 {
    font-size: 1em;
  }
  .katex .fontsize-ensurer.reset-size7.size8,
.katex .sizing.reset-size7.size8 {
    font-size: 1.2em;
  }
  .katex .fontsize-ensurer.reset-size7.size9,
.katex .sizing.reset-size7.size9 {
    font-size: 1.44em;
  }
  .katex .fontsize-ensurer.reset-size7.size10,
.katex .sizing.reset-size7.size10 {
    font-size: 1.72833333em;
  }
  .katex .fontsize-ensurer.reset-size7.size11,
.katex .sizing.reset-size7.size11 {
    font-size: 2.07333333em;
  }
  .katex .fontsize-ensurer.reset-size8.size1,
.katex .sizing.reset-size8.size1 {
    font-size: 0.34722222em;
  }
  .katex .fontsize-ensurer.reset-size8.size2,
.katex .sizing.reset-size8.size2 {
    font-size: 0.41666667em;
  }
  .katex .fontsize-ensurer.reset-size8.size3,
.katex .sizing.reset-size8.size3 {
    font-size: 0.48611111em;
  }
  .katex .fontsize-ensurer.reset-size8.size4,
.katex .sizing.reset-size8.size4 {
    font-size: 0.55555556em;
  }
  .katex .fontsize-ensurer.reset-size8.size5,
.katex .sizing.reset-size8.size5 {
    font-size: 0.625em;
  }
  .katex .fontsize-ensurer.reset-size8.size6,
.katex .sizing.reset-size8.size6 {
    font-size: 0.69444444em;
  }
  .katex .fontsize-ensurer.reset-size8.size7,
.katex .sizing.reset-size8.size7 {
    font-size: 0.83333333em;
  }
  .katex .fontsize-ensurer.reset-size8.size8,
.katex .sizing.reset-size8.size8 {
    font-size: 1em;
  }
  .katex .fontsize-ensurer.reset-size8.size9,
.katex .sizing.reset-size8.size9 {
    font-size: 1.2em;
  }
  .katex .fontsize-ensurer.reset-size8.size10,
.katex .sizing.reset-size8.size10 {
    font-size: 1.44027778em;
  }
  .katex .fontsize-ensurer.reset-size8.size11,
.katex .sizing.reset-size8.size11 {
    font-size: 1.72777778em;
  }
  .katex .fontsize-ensurer.reset-size9.size1,
.katex .sizing.reset-size9.size1 {
    font-size: 0.28935185em;
  }
  .katex .fontsize-ensurer.reset-size9.size2,
.katex .sizing.reset-size9.size2 {
    font-size: 0.34722222em;
  }
  .katex .fontsize-ensurer.reset-size9.size3,
.katex .sizing.reset-size9.size3 {
    font-size: 0.40509259em;
  }
  .katex .fontsize-ensurer.reset-size9.size4,
.katex .sizing.reset-size9.size4 {
    font-size: 0.46296296em;
  }
  .katex .fontsize-ensurer.reset-size9.size5,
.katex .sizing.reset-size9.size5 {
    font-size: 0.52083333em;
  }
  .katex .fontsize-ensurer.reset-size9.size6,
.katex .sizing.reset-size9.size6 {
    font-size: 0.5787037em;
  }
  .katex .fontsize-ensurer.reset-size9.size7,
.katex .sizing.reset-size9.size7 {
    font-size: 0.69444444em;
  }
  .katex .fontsize-ensurer.reset-size9.size8,
.katex .sizing.reset-size9.size8 {
    font-size: 0.83333333em;
  }
  .katex .fontsize-ensurer.reset-size9.size9,
.katex .sizing.reset-size9.size9 {
    font-size: 1em;
  }
  .katex .fontsize-ensurer.reset-size9.size10,
.katex .sizing.reset-size9.size10 {
    font-size: 1.20023148em;
  }
  .katex .fontsize-ensurer.reset-size9.size11,
.katex .sizing.reset-size9.size11 {
    font-size: 1.43981481em;
  }
  .katex .fontsize-ensurer.reset-size10.size1,
.katex .sizing.reset-size10.size1 {
    font-size: 0.24108004em;
  }
  .katex .fontsize-ensurer.reset-size10.size2,
.katex .sizing.reset-size10.size2 {
    font-size: 0.28929605em;
  }
  .katex .fontsize-ensurer.reset-size10.size3,
.katex .sizing.reset-size10.size3 {
    font-size: 0.33751205em;
  }
  .katex .fontsize-ensurer.reset-size10.size4,
.katex .sizing.reset-size10.size4 {
    font-size: 0.38572806em;
  }
  .katex .fontsize-ensurer.reset-size10.size5,
.katex .sizing.reset-size10.size5 {
    font-size: 0.43394407em;
  }
  .katex .fontsize-ensurer.reset-size10.size6,
.katex .sizing.reset-size10.size6 {
    font-size: 0.48216008em;
  }
  .katex .fontsize-ensurer.reset-size10.size7,
.katex .sizing.reset-size10.size7 {
    font-size: 0.57859209em;
  }
  .katex .fontsize-ensurer.reset-size10.size8,
.katex .sizing.reset-size10.size8 {
    font-size: 0.69431051em;
  }
  .katex .fontsize-ensurer.reset-size10.size9,
.katex .sizing.reset-size10.size9 {
    font-size: 0.83317261em;
  }
  .katex .fontsize-ensurer.reset-size10.size10,
.katex .sizing.reset-size10.size10 {
    font-size: 1em;
  }
  .katex .fontsize-ensurer.reset-size10.size11,
.katex .sizing.reset-size10.size11 {
    font-size: 1.19961427em;
  }
  .katex .fontsize-ensurer.reset-size11.size1,
.katex .sizing.reset-size11.size1 {
    font-size: 0.20096463em;
  }
  .katex .fontsize-ensurer.reset-size11.size2,
.katex .sizing.reset-size11.size2 {
    font-size: 0.24115756em;
  }
  .katex .fontsize-ensurer.reset-size11.size3,
.katex .sizing.reset-size11.size3 {
    font-size: 0.28135048em;
  }
  .katex .fontsize-ensurer.reset-size11.size4,
.katex .sizing.reset-size11.size4 {
    font-size: 0.32154341em;
  }
  .katex .fontsize-ensurer.reset-size11.size5,
.katex .sizing.reset-size11.size5 {
    font-size: 0.36173633em;
  }
  .katex .fontsize-ensurer.reset-size11.size6,
.katex .sizing.reset-size11.size6 {
    font-size: 0.40192926em;
  }
  .katex .fontsize-ensurer.reset-size11.size7,
.katex .sizing.reset-size11.size7 {
    font-size: 0.48231511em;
  }
  .katex .fontsize-ensurer.reset-size11.size8,
.katex .sizing.reset-size11.size8 {
    font-size: 0.57877814em;
  }
  .katex .fontsize-ensurer.reset-size11.size9,
.katex .sizing.reset-size11.size9 {
    font-size: 0.69453376em;
  }
  .katex .fontsize-ensurer.reset-size11.size10,
.katex .sizing.reset-size11.size10 {
    font-size: 0.83360129em;
  }
  .katex .fontsize-ensurer.reset-size11.size11,
.katex .sizing.reset-size11.size11 {
    font-size: 1em;
  }
  .katex .delimsizing.size1 {
    font-family: "KaTeX_Size1";
  }
  .katex .delimsizing.size2 {
    font-family: "KaTeX_Size2";
  }
  .katex .delimsizing.size3 {
    font-family: "KaTeX_Size3";
  }
  .katex .delimsizing.size4 {
    font-family: "KaTeX_Size4";
  }
  .katex .delimsizing.mult .delim-size1 > span {
    font-family: "KaTeX_Size1";
  }
  .katex .delimsizing.mult .delim-size4 > span {
    font-family: "KaTeX_Size4";
  }
  .katex .nulldelimiter {
    display: inline-block;
    width: 0.12em;
  }
  .katex .delimcenter,
.katex .op-symbol {
    position: relative;
  }
  .katex .op-symbol.small-op {
    font-family: "KaTeX_Size1";
  }
  .katex .op-symbol.large-op {
    font-family: "KaTeX_Size2";
  }
  .katex .accent > .vlist-t,
.katex .op-limits > .vlist-t {
    text-align: center;
  }
  .katex .accent .accent-body {
    position: relative;
  }
  .katex .accent .accent-body:not(.accent-full) {
    width: 0;
  }
  .katex .overlay {
    display: block;
  }
  .katex .mtable .vertical-separator {
    display: inline-block;
    min-width: 1px;
  }
  .katex .mtable .arraycolsep {
    display: inline-block;
  }
  .katex .mtable .col-align-c > .vlist-t {
    text-align: center;
  }
  .katex .mtable .col-align-l > .vlist-t {
    text-align: left;
  }
  .katex .mtable .col-align-r > .vlist-t {
    text-align: right;
  }
  .katex .svg-align {
    text-align: left;
  }
  .katex svg {
    position: absolute;
    display: block;
    width: 100%;
    height: inherit;
    fill: currentcolor;
    fill-opacity: 1;
    fill-rule: nonzero;
    stroke: currentcolor;
    stroke-dasharray: none;
    stroke-dashoffset: 0;
    stroke-linecap: butt;
    stroke-linejoin: miter;
    stroke-miterlimit: 4;
    stroke-opacity: 1;
    stroke-width: 1;
  }
  .katex svg path {
    stroke: none;
  }
  .katex img {
    min-width: 0;
    max-width: none;
    min-height: 0;
    max-height: none;
    border-style: none;
  }
  .katex .stretchy {
    position: relative;
    overflow: hidden;
    display: block;
    width: 100%;
  }
  .katex .stretchy::after,
.katex .stretchy::before {
    content: "";
  }
  .katex .hide-tail {
    position: relative;
    overflow: hidden;
    width: 100%;
  }
  .katex .halfarrow-left {
    position: absolute;
    left: 0;
    overflow: hidden;
    width: 50.2%;
  }
  .katex .halfarrow-right {
    position: absolute;
    right: 0;
    overflow: hidden;
    width: 50.2%;
  }
  .katex .brace-left {
    position: absolute;
    left: 0;
    overflow: hidden;
    width: 25.1%;
  }
  .katex .brace-center {
    position: absolute;
    left: 25%;
    overflow: hidden;
    width: 50%;
  }
  .katex .brace-right {
    position: absolute;
    right: 0;
    overflow: hidden;
    width: 25.1%;
  }
  .katex .x-arrow-pad {
    padding: 0 0.5em;
  }
  .katex .cd-arrow-pad {
    padding: 0 0.55556em 0 0.27778em;
  }
  .katex .mover,
.katex .munder,
.katex .x-arrow {
    text-align: center;
  }
  .katex .boxpad {
    padding: 0 0.3em;
  }
  .katex .fbox,
.katex .fcolorbox {
    box-sizing: border-box;
    border: 0.04em solid;
  }
  .katex .cancel-pad {
    padding: 0 0.2em;
  }
  .katex .cancel-lap {
    margin-right: -0.2em;
    margin-left: -0.2em;
  }
  .katex .sout {
    border-bottom-width: 0.08em;
    border-bottom-style: solid;
  }
  .katex .angl {
    box-sizing: border-box;
    border-top: 0.049em solid;
    border-right: 0.049em solid;
    margin-right: 0.03889em;
  }
  .katex .anglpad {
    padding: 0 0.03889em;
  }
  .katex .eqn-num::before {
    content: "(" counter(katexEqnNo) ")";
    counter-increment: katexEqnNo;
  }
  .katex .mml-eqn-num::before {
    content: "(" counter(mmlEqnNo) ")";
    counter-increment: mmlEqnNo;
  }
  .katex .mtr-glue {
    width: 50%;
  }
  .katex .cd-vert-arrow {
    position: relative;
    display: inline-block;
  }
  .katex .cd-label-left {
    position: absolute;
    right: calc(50% + 0.3em);
    display: inline-block;
    text-align: left;
  }
  .katex .cd-label-right {
    position: absolute;
    left: calc(50% + 0.3em);
    display: inline-block;
    text-align: right;
  }
  .katex-display {
    display: block;
    margin: 1em 0;
    text-align: center;
  }
  .katex-display > .katex {
    display: block;
    text-align: center;
    white-space: nowrap;
  }
  .katex-display > .katex > .katex-html {
    position: relative;
    display: block;
  }
  .katex-display > .katex > .katex-html > .tag {
    position: absolute;
    right: 0;
  }
  .katex-display.leqno > .katex > .katex-html > .tag {
    right: auto;
    left: 0;
  }
  .katex-display.fleqn > .katex {
    padding-left: 2em;
    text-align: left;
  }
  body {
    counter-reset: katexEqnNo mmlEqnNo;
  }
}
@property --tw-rotate-x {
  syntax: "*";
  inherits: false;
}
@property --tw-rotate-y {
  syntax: "*";
  inherits: false;
}
@property --tw-rotate-z {
  syntax: "*";
  inherits: false;
}
@property --tw-skew-x {
  syntax: "*";
  inherits: false;
}
@property --tw-skew-y {
  syntax: "*";
  inherits: false;
}
@property --tw-space-y-reverse {
  syntax: "*";
  inherits: false;
  initial-value: 0;
}
@property --tw-border-style {
  syntax: "*";
  inherits: false;
  initial-value: solid;
}
@property --tw-gradient-position {
  syntax: "*";
  inherits: false;
}
@property --tw-gradient-from {
  syntax: "<color>";
  inherits: false;
  initial-value: #0000;
}
@property --tw-gradient-via {
  syntax: "<color>";
  inherits: false;
  initial-value: #0000;
}
@property --tw-gradient-to {
  syntax: "<color>";
  inherits: false;
  initial-value: #0000;
}
@property --tw-gradient-stops {
  syntax: "*";
  inherits: false;
}
@property --tw-gradient-via-stops {
  syntax: "*";
  inherits: false;
}
@property --tw-gradient-from-position {
  syntax: "<length-percentage>";
  inherits: false;
  initial-value: 0%;
}
@property --tw-gradient-via-position {
  syntax: "<length-percentage>";
  inherits: false;
  initial-value: 50%;
}
@property --tw-gradient-to-position {
  syntax: "<length-percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-font-weight {
  syntax: "*";
  inherits: false;
}
@property --tw-tracking {
  syntax: "*";
  inherits: false;
}
@property --tw-ordinal {
  syntax: "*";
  inherits: false;
}
@property --tw-slashed-zero {
  syntax: "*";
  inherits: false;
}
@property --tw-numeric-figure {
  syntax: "*";
  inherits: false;
}
@property --tw-numeric-spacing {
  syntax: "*";
  inherits: false;
}
@property --tw-numeric-fraction {
  syntax: "*";
  inherits: false;
}
@property --tw-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-shadow-color {
  syntax: "*";
  inherits: false;
}
@property --tw-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-inset-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-inset-shadow-color {
  syntax: "*";
  inherits: false;
}
@property --tw-inset-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-ring-color {
  syntax: "*";
  inherits: false;
}
@property --tw-ring-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-inset-ring-color {
  syntax: "*";
  inherits: false;
}
@property --tw-inset-ring-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-ring-inset {
  syntax: "*";
  inherits: false;
}
@property --tw-ring-offset-width {
  syntax: "<length>";
  inherits: false;
  initial-value: 0px;
}
@property --tw-ring-offset-color {
  syntax: "*";
  inherits: false;
  initial-value: #fff;
}
@property --tw-ring-offset-shadow {
  syntax: "*";
  inherits: false;
  initial-value: 0 0 #0000;
}
@property --tw-outline-style {
  syntax: "*";
  inherits: false;
  initial-value: solid;
}
@property --tw-blur {
  syntax: "*";
  inherits: false;
}
@property --tw-brightness {
  syntax: "*";
  inherits: false;
}
@property --tw-contrast {
  syntax: "*";
  inherits: false;
}
@property --tw-grayscale {
  syntax: "*";
  inherits: false;
}
@property --tw-hue-rotate {
  syntax: "*";
  inherits: false;
}
@property --tw-invert {
  syntax: "*";
  inherits: false;
}
@property --tw-opacity {
  syntax: "*";
  inherits: false;
}
@property --tw-saturate {
  syntax: "*";
  inherits: false;
}
@property --tw-sepia {
  syntax: "*";
  inherits: false;
}
@property --tw-drop-shadow {
  syntax: "*";
  inherits: false;
}
@property --tw-drop-shadow-color {
  syntax: "*";
  inherits: false;
}
@property --tw-drop-shadow-alpha {
  syntax: "<percentage>";
  inherits: false;
  initial-value: 100%;
}
@property --tw-drop-shadow-size {
  syntax: "*";
  inherits: false;
}
@layer properties {
  @supports ((-webkit-hyphens: none) and (not (margin-trim: inline))) or ((-moz-orient: inline) and (not (color:rgb(from red r g b)))) {
    *, ::before, ::after, ::backdrop {
      --tw-rotate-x: initial;
      --tw-rotate-y: initial;
      --tw-rotate-z: initial;
      --tw-skew-x: initial;
      --tw-skew-y: initial;
      --tw-space-y-reverse: 0;
      --tw-border-style: solid;
      --tw-gradient-position: initial;
      --tw-gradient-from: #0000;
      --tw-gradient-via: #0000;
      --tw-gradient-to: #0000;
      --tw-gradient-stops: initial;
      --tw-gradient-via-stops: initial;
      --tw-gradient-from-position: 0%;
      --tw-gradient-via-position: 50%;
      --tw-gradient-to-position: 100%;
      --tw-font-weight: initial;
      --tw-tracking: initial;
      --tw-ordinal: initial;
      --tw-slashed-zero: initial;
      --tw-numeric-figure: initial;
      --tw-numeric-spacing: initial;
      --tw-numeric-fraction: initial;
      --tw-shadow: 0 0 #0000;
      --tw-shadow-color: initial;
      --tw-shadow-alpha: 100%;
      --tw-inset-shadow: 0 0 #0000;
      --tw-inset-shadow-color: initial;
      --tw-inset-shadow-alpha: 100%;
      --tw-ring-color: initial;
      --tw-ring-shadow: 0 0 #0000;
      --tw-inset-ring-color: initial;
      --tw-inset-ring-shadow: 0 0 #0000;
      --tw-ring-inset: initial;
      --tw-ring-offset-width: 0px;
      --tw-ring-offset-color: #fff;
      --tw-ring-offset-shadow: 0 0 #0000;
      --tw-outline-style: solid;
      --tw-blur: initial;
      --tw-brightness: initial;
      --tw-contrast: initial;
      --tw-grayscale: initial;
      --tw-hue-rotate: initial;
      --tw-invert: initial;
      --tw-opacity: initial;
      --tw-saturate: initial;
      --tw-sepia: initial;
      --tw-drop-shadow: initial;
      --tw-drop-shadow-color: initial;
      --tw-drop-shadow-alpha: 100%;
      --tw-drop-shadow-size: initial;
    }
  }
}
@layer components {
  .CircularProgress_Container {
    position: relative;
    width: var(--circular-progress-size, 28px);
    height: var(--circular-progress-size, 28px);
  }
  .CircularProgress_Container circle {
    stroke-width: var(--circular-progress-stroke, 2px);
  }
  .CircularProgress_Track {
    position: absolute;
    top: 0;
    left: 0;
    stroke: var(--circular-progress-track-color, light-dark(#deede9, var(--green-a50)));
    transition: stroke 0.15s ease;
  }
  .CircularProgress_TrackProgress {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 2;
    stroke: var(--circular-progress-track-active-color, var(--green-500));
    stroke-dasharray: 50px;
    stroke-dashoffset: 50px;
    stroke-linecap: round;
    transform: rotate(-90deg);
    transition: stroke-dashoffset 0.3s ease;
    will-change: transform;
  }
}
@layer components {
  .LoadingDots_LoadingDots {
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 4px;
    height: var(--font-text-md-line-height);
  }
  .LoadingDots_Dot {
    width: 8px;
    height: 8px;
    border-radius: 100%;
    animation: LoadingDots_pulse 1s infinite both;
    background-color: currentcolor;
  }
  .LoadingDots_Dot:nth-child(2) {
    animation-delay: 0.2s;
  }
  .LoadingDots_Dot:nth-child(3) {
    animation-delay: 0.4s;
  }
  @keyframes LoadingDots_pulse {
    0% {
      opacity: 0.15;
    }
    20% {
      opacity: 0.4;
    }
    100% {
      opacity: 0.15;
    }
  }
}
@layer components {
  .LoadingIndicator_LoadingIndicator {
    position: relative;
    width: var(--indicator-size, 1em);
    height: var(--indicator-size, 1em);
    animation: LoadingIndicator_rotate var(--indicator-rotate-duration, 0.8s) linear infinite;
    transition: opacity 0.15s ease;
  }
  .LoadingIndicator_LoadingIndicator::before {
    position: absolute;
    inset: 0;
    display: block;
    border: var(--indicator-stroke, 2px) solid var(--indicator-color, currentcolor);
    border-radius: 50%;
    content: "";
    -webkit-mask-image: conic-gradient(rgb(0 0 0 / 0%), rgb(0 0 0));
    mask-image: conic-gradient(rgb(0 0 0 / 0%), rgb(0 0 0));
  }
  .LoadingIndicator_LoadingIndicator::after {
    position: absolute;
    top: 0;
    left: 50%;
    display: block;
    width: var(--indicator-stroke, 2px);
    height: var(--indicator-stroke, 2px);
    border-radius: 100%;
    margin-left: calc(var(--indicator-stroke, 2px) * -1 / 2);
    background-color: var(--indicator-color, currentcolor);
    content: "";
  }
  @keyframes LoadingIndicator_rotate {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(1turn);
    }
  }
}
@layer components {
  .TransitionGroup_TransitionGroupChild {
    display: block;
  }
}
@layer components {
  .Button_Button {
    position: relative;
    display: inline-block;
    gap: var(--button-gap);
    flex-shrink: 0;
    height: var(--button-size);
    padding: 0 var(--button-gutter);
    border-radius: var(--button-radius);
    cursor: pointer;
    font-size: var(--button-font-size);
    font-weight: var(--button-font-weight);
    line-height: 1;
    transition-duration: var(--transition-duration-basic);
    transition-property: opacity, color;
    transition-timing-function: var(--transition-ease-basic);
    -webkit-user-select: none;
    -moz-user-select: none;
    user-select: none;
    white-space: nowrap;
  }
  .Button_Button::before {
    position: absolute;
    inset: 0;
    display: block;
    border-radius: inherit;
    content: "";
    transition-duration: var(--transition-duration-basic);
    transition-property:
      opacity,
      background-color,
      transform,
      box-shadow,
      border-color;
    transition-timing-function: var(--transition-ease-basic);
    will-change: transform;
  }
  .Button_Button::after {
    position: absolute;
    inset: 0;
    display: block;
    border-radius: inherit;
    content: "";
    pointer-events: none;
    transition-duration: var(--transition-duration-basic);
    transition-property: transform;
    transition-timing-function: var(--transition-ease-basic);
    will-change: transform;
  }
  .Button_Button:focus {
    outline: none;
  }
  .Button_Button:focus-visible::after {
    outline: 2px solid var(--button-ring-color, var(--color-ring));
    outline-offset: var(--button-ring-offset, 2px);
  }
  .Button_Button svg:where(:not([data-no-autosize])) {
    width: var(--button-icon-size);
    height: var(--button-icon-size);
  }
  :where(.Button_Button svg:where(:not([data-no-autosize])):first-child:not(:only-child)) {
    margin-left: var(--button-icon-offset, -1px);
  }
  :where(.Button_Button svg:where(:not([data-no-autosize])):last-child:not(:only-child)) {
    margin-right: var(--button-icon-offset, -1px);
  }
  .Button_Button:where([data-optically-align=start]) {
    margin-inline-start: calc(var(--button-gutter) * -1);
  }
  .Button_Button:where([data-optically-align=end]) {
    margin-inline-end: calc(var(--button-gutter) * -1);
  }
  .Button_Button:where([data-optically-align=start][data-uniform]) {
    margin-inline-start: calc(((var(--button-size) - var(--button-icon-size)) / 2) * -1);
  }
  .Button_Button:where([data-optically-align=end][data-uniform]) {
    margin-inline-end: calc(((var(--button-size) - var(--button-icon-size)) / 2) * -1);
  }
  .Button_Button:where([data-size="3xs"]) {
    --button-size: var(--control-size-3xs);
    --button-gutter: var(--control-gutter-2xs);
    --button-font-size: var(--control-font-size-sm);
    --button-icon-size: var(--control-icon-size-xs);
    --button-gap: var(--button-gap-sm);
    --button-radius: var(--control-radius-sm);
    --button-icon-offset: -1px;
    --indicator-size: 11px;
    --circular-progress-size: 11px;
  }
  .Button_Button:where([data-size="2xs"]) {
    --button-size: var(--control-size-2xs);
    --button-gutter: var(--control-gutter-xs);
    --button-font-size: var(--control-font-size-sm);
    --button-icon-size: var(--control-icon-size-sm);
    --button-gap: var(--button-gap-md);
    --button-radius: var(--control-radius-sm);
    --button-icon-offset: -1px;
    --indicator-size: 12px;
    --circular-progress-size: 12px;
  }
  .Button_Button:where([data-size=xs]) {
    --button-size: var(--control-size-xs);
    --button-gutter: var(--control-gutter-xs);
    --button-font-size: var(--control-font-size-md);
    --button-icon-size: var(--control-icon-size-sm);
    --button-gap: var(--button-gap-md);
    --button-radius: var(--control-radius-sm);
    --button-icon-offset: -1px;
    --indicator-size: 13px;
    --circular-progress-size: 14px;
  }
  .Button_Button:where([data-size=sm]) {
    --button-size: var(--control-size-sm);
    --button-gutter: var(--control-gutter-sm);
    --button-font-size: var(--control-font-size-md);
    --button-icon-size: var(--control-icon-size-md);
    --button-gap: var(--button-gap-md);
    --button-radius: var(--control-radius-sm);
    --button-icon-offset: -1px;
    --indicator-size: 15px;
    --circular-progress-size: 15px;
  }
  .Button_Button:where([data-size=md]) {
    --button-size: var(--control-size-md);
    --button-gutter: var(--control-gutter-md);
    --button-font-size: var(--control-font-size-md);
    --button-icon-size: var(--control-icon-size-md);
    --button-gap: var(--button-gap-lg);
    --button-radius: var(--control-radius-md);
    --button-icon-offset: -1px;
    --indicator-size: 16px;
    --circular-progress-size: 16px;
  }
  .Button_Button:where([data-size=lg]) {
    --button-size: var(--control-size-lg);
    --button-gutter: var(--control-gutter-md);
    --button-font-size: var(--control-font-size-md);
    --button-icon-size: var(--control-icon-size-md);
    --button-gap: var(--button-gap-lg);
    --button-radius: var(--control-radius-md);
    --button-icon-offset: -1px;
    --indicator-size: 16px;
    --circular-progress-size: 16px;
  }
  .Button_Button:where([data-size=xl]) {
    --button-size: var(--control-size-xl);
    --button-gutter: var(--control-gutter-lg);
    --button-font-size: var(--control-font-size-md);
    --button-icon-size: var(--control-icon-size-md);
    --button-gap: var(--button-gap-lg);
    --button-radius: var(--control-radius-lg);
    --button-icon-offset: -1px;
    --indicator-size: 18px;
    --circular-progress-size: 18px;
  }
  .Button_Button:where([data-size="2xl"]) {
    --button-size: var(--control-size-2xl);
    --button-gutter: var(--control-gutter-lg);
    --button-font-size: var(--control-font-size-lg);
    --button-icon-size: var(--control-icon-size-lg);
    --button-gap: var(--button-gap-lg);
    --button-radius: var(--control-radius-xl);
    --button-icon-offset: -2px;
    --indicator-size: 18px;
    --circular-progress-size: 18px;
  }
  .Button_Button:where([data-size="3xl"]) {
    --button-size: var(--control-size-3xl);
    --button-gutter: var(--control-gutter-xl);
    --button-font-size: var(--control-font-size-lg);
    --button-icon-size: var(--control-icon-size-lg);
    --button-gap: var(--button-gap-lg);
    --button-radius: var(--control-radius-xl);
    --button-icon-offset: -2px;
    --indicator-size: 20px;
    --circular-progress-size: 20px;
  }
  .Button_Button:where([data-gutter-size="2xs"]) {
    --button-gutter: var(--control-gutter-2xs);
  }
  .Button_Button:where([data-gutter-size=xs]) {
    --button-gutter: var(--control-gutter-xs);
  }
  .Button_Button:where([data-gutter-size=sm]) {
    --button-gutter: var(--control-gutter-sm);
  }
  .Button_Button:where([data-gutter-size=md]) {
    --button-gutter: var(--control-gutter-md);
  }
  .Button_Button:where([data-gutter-size=lg]) {
    --button-gutter: var(--control-gutter-lg);
  }
  .Button_Button:where([data-gutter-size=xl]) {
    --button-gutter: var(--control-gutter-xl);
  }
  .Button_Button:where([data-icon-size=sm]) {
    --button-icon-size: var(--control-icon-size-sm);
  }
  .Button_Button:where([data-icon-size=md]) {
    --button-icon-size: var(--control-icon-size-md);
  }
  .Button_Button:where([data-icon-size=lg]) {
    --button-icon-size: var(--control-icon-size-lg);
  }
  .Button_Button:where([data-icon-size=xl]) {
    --button-icon-size: var(--control-icon-size-xl);
  }
  .Button_Button:where([data-icon-size="2xl"]) {
    --button-icon-size: var(--control-icon-size-2xl);
  }
  .Button_Button:where([data-pill]) {
    --button-radius: var(--radius-full);
    padding: 0 calc(var(--button-gutter) * var(--control-gutter-pill-scaling));
  }
  .Button_Button:where([data-block]) {
    width: 100%;
  }
  .Button_Button[data-uniform] {
    --button-gutter: 0;
    width: var(--button-size);
  }
  .Button_Button[data-variant=ghost] {
    --button-ring-offset: -1px;
    color: var(--button-text-color);
  }
  .Button_Button[data-variant=ghost]::before {
    background-color: var(--button-background-color);
    opacity: 0;
    transform: scale(var(--scale));
  }
  .Button_Button[data-variant=ghost][aria-expanded=true],
  .Button_Button[data-variant=ghost][data-state=open] {
    color: var(--button-text-color-hover);
  }
  .Button_Button[data-variant=ghost][aria-expanded=true]::before,
  .Button_Button[data-variant=ghost][data-state=open]::before {
    opacity: 0.6;
    transform: scale(1);
  }
  .Button_Button[data-variant=ghost][data-selected] {
    color: var(--button-text-color-hover);
  }
  .Button_Button[data-variant=ghost][data-selected]::before {
    opacity: 1;
    transform: scale(1);
  }
  @media (hover: hover) and (pointer: fine) {
    .Button_Button[data-variant=ghost]:where(:not([data-disabled])):hover {
      color: var(--button-text-color-hover);
    }
    .Button_Button[data-variant=ghost]:where(:not([data-disabled])):hover::before {
      opacity: 1;
      transform: scale(1);
    }
  }
  .Button_Button[data-variant=ghost]:where(:not([data-disabled])):active::before {
    background-color: var(--button-background-color-active);
    opacity: 1;
    transform: scale(var(--scale));
  }
  .Button_Button[data-variant=ghost]:where(:not([data-disabled])):active::after {
    transform: scale(var(--scale));
  }
  .Button_Button[data-variant=ghost]:where([data-color=primary]) {
    --button-background-color: var(--color-background-primary-ghost-hover);
    --button-background-color-active: var(--color-background-primary-ghost-active);
    --button-text-color: var(--color-text-primary-ghost);
    --button-text-color-hover: var(--color-text-primary-ghost-hover);
    --button-ring-color: var(--color-ring-primary-ghost);
  }
  .Button_Button[data-variant=ghost]:where([data-color=secondary]) {
    --button-background-color: var(--color-background-secondary-ghost-hover);
    --button-background-color-active: var(--color-background-secondary-ghost-active);
    --button-text-color: var(--color-text-secondary-ghost);
    --button-text-color-hover: var(--color-text-secondary-ghost-hover);
    --button-ring-color: var(--color-ring-secondary-ghost);
  }
  .Button_Button[data-variant=ghost]:where([data-color=danger]) {
    --button-background-color: var(--color-background-danger-ghost-hover);
    --button-background-color-active: var(--color-background-danger-ghost-active);
    --button-text-color: var(--color-text-danger-ghost);
    --button-text-color-hover: var(--color-text-danger-ghost-hover);
    --button-ring-color: var(--color-ring-danger-ghost);
  }
  .Button_Button[data-variant=ghost]:where([data-color=success]) {
    --button-background-color: var(--color-background-success-ghost-hover);
    --button-background-color-active: var(--color-background-success-ghost-active);
    --button-text-color: var(--color-text-success-ghost);
    --button-text-color-hover: var(--color-text-success-ghost-hover);
    --button-ring-color: var(--color-ring-success-ghost);
  }
  .Button_Button[data-variant=ghost]:where([data-color=warning]) {
    --button-background-color: var(--color-background-warning-ghost-hover);
    --button-background-color-active: var(--color-background-warning-ghost-active);
    --button-text-color: var(--color-text-warning-ghost);
    --button-text-color-hover: var(--color-text-warning-ghost-hover);
    --button-ring-color: var(--color-ring-warning-ghost);
  }
  .Button_Button[data-variant=ghost]:where([data-color=caution]) {
    --button-background-color: var(--color-background-caution-ghost-hover);
    --button-background-color-active: var(--color-background-caution-ghost-active);
    --button-text-color: var(--color-text-caution-ghost);
    --button-text-color-hover: var(--color-text-caution-ghost-hover);
    --button-ring-color: var(--color-ring-caution-ghost);
  }
  .Button_Button[data-variant=ghost]:where([data-color=info]) {
    --button-background-color: var(--color-background-info-ghost-hover);
    --button-background-color-active: var(--color-background-info-ghost-active);
    --button-text-color: var(--color-text-info-ghost);
    --button-text-color-hover: var(--color-text-info-ghost-hover);
    --button-ring-color: var(--color-ring-info-ghost);
  }
  .Button_Button[data-variant=ghost]:where([data-color=discovery]) {
    --button-background-color: var(--color-background-discovery-ghost-hover);
    --button-background-color-active: var(--color-background-discovery-ghost-active);
    --button-text-color: var(--color-text-discovery-ghost);
    --button-text-color-hover: var(--color-text-discovery-ghost-hover);
    --button-ring-color: var(--color-ring-discovery-ghost);
  }
  .Button_Button[data-variant=solid] {
    color: var(--button-text-color);
  }
  .Button_Button[data-variant=solid]::before {
    background-color: var(--button-background-color);
  }
  .Button_Button[data-variant=solid][aria-expanded=true]::before,
  .Button_Button[data-variant=solid][data-state=open]::before,
  .Button_Button[data-variant=solid][data-selected]::before {
    background-color: var(--button-background-color-hover);
  }
  @media (hover: hover) and (pointer: fine) {
    .Button_Button[data-variant=solid]:where(:not([data-disabled])):hover::before {
      background-color: var(--button-background-color-hover);
    }
  }
  .Button_Button[data-variant=solid]:where(:not([data-disabled])):active::before {
    background-color: var(--button-background-color-active);
  }
  .Button_Button[data-variant=solid]:where(:not([data-disabled])):active::before,
  .Button_Button[data-variant=solid]:where(:not([data-disabled])):active::after {
    transform: scale(var(--scale));
  }
  .Button_Button[data-variant=solid]:where([data-color=primary]) {
    --button-background-color: var(--color-background-primary-solid);
    --button-background-color-hover: var(--color-background-primary-solid-hover);
    --button-background-color-active: var(--color-background-primary-solid-active);
    --button-text-color: var(--color-text-primary-solid);
    --button-ring-color: var(--color-ring-primary-solid);
  }
  .Button_Button[data-variant=solid]:where([data-color=secondary]) {
    --button-background-color: var(--color-background-secondary-solid);
    --button-background-color-hover: var(--color-background-secondary-solid-hover);
    --button-background-color-active: var(--color-background-secondary-solid-active);
    --button-text-color: var(--color-text-secondary-solid);
    --button-ring-color: var(--color-ring-secondary-solid);
  }
  .Button_Button[data-variant=solid]:where([data-color=success]) {
    --button-background-color: var(--color-background-success-solid);
    --button-background-color-hover: var(--color-background-success-solid-hover);
    --button-background-color-active: var(--color-background-success-solid-active);
    --button-text-color: var(--color-text-success-solid);
    --button-ring-color: var(--color-ring-success-solid);
  }
  .Button_Button[data-variant=solid]:where([data-color=danger]) {
    --button-background-color: var(--color-background-danger-solid);
    --button-background-color-hover: var(--color-background-danger-solid-hover);
    --button-background-color-active: var(--color-background-danger-solid-active);
    --button-text-color: var(--color-text-danger-solid);
    --button-ring-color: var(--color-ring-danger-solid);
  }
  .Button_Button[data-variant=solid]:where([data-color=warning]) {
    --button-background-color: var(--color-background-warning-solid);
    --button-background-color-hover: var(--color-background-warning-solid-hover);
    --button-background-color-active: var(--color-background-warning-solid-active);
    --button-text-color: var(--color-text-warning-solid);
    --button-ring-color: var(--color-ring-warning-solid);
  }
  .Button_Button[data-variant=solid]:where([data-color=caution]) {
    --button-background-color: var(--color-background-caution-solid);
    --button-background-color-hover: var(--color-background-caution-solid-hover);
    --button-background-color-active: var(--color-background-caution-solid-active);
    --button-text-color: var(--color-text-caution-solid);
    --button-ring-color: var(--color-ring-caution-solid);
  }
  .Button_Button[data-variant=solid]:where([data-color=info]) {
    --button-background-color: var(--color-background-info-solid);
    --button-background-color-hover: var(--color-background-info-solid-hover);
    --button-background-color-active: var(--color-background-info-solid-active);
    --button-text-color: var(--color-text-info-solid);
    --button-ring-color: var(--color-ring-info-solid);
  }
  .Button_Button[data-variant=solid]:where([data-color=discovery]) {
    --button-background-color: var(--color-background-discovery-solid);
    --button-background-color-hover: var(--color-background-discovery-solid-hover);
    --button-background-color-active: var(--color-background-discovery-solid-active);
    --button-text-color: var(--color-text-discovery-solid);
    --button-ring-color: var(--color-ring-discovery-solid);
  }
  .Button_Button[data-variant=soft] {
    color: var(--button-text-color);
  }
  .Button_Button[data-variant=soft]::before {
    background-color: var(--button-background-color);
  }
  .Button_Button[data-variant=soft][aria-expanded=true]::before,
  .Button_Button[data-variant=soft][data-state=open]::before,
  .Button_Button[data-variant=soft][data-selected]::before {
    background-color: var(--button-background-color-hover);
  }
  @media (hover: hover) and (pointer: fine) {
    .Button_Button[data-variant=soft]:where(:not([data-disabled])):hover::before {
      background-color: var(--button-background-color-hover);
    }
  }
  .Button_Button[data-variant=soft]:where(:not([data-disabled])):active::before {
    background-color: var(--button-background-color-active);
  }
  .Button_Button[data-variant=soft]:where(:not([data-disabled])):active::before,
  .Button_Button[data-variant=soft]:where(:not([data-disabled])):active::after {
    transform: scale(var(--scale));
  }
  .Button_Button[data-variant=soft]:where([data-color=primary]) {
    --button-background-color: var(--color-background-primary-soft-alpha);
    --button-background-color-hover: var(--color-background-primary-soft-alpha-hover);
    --button-background-color-active: var(--color-background-primary-soft-alpha-active);
    --button-text-color: var(--color-text-primary-soft);
    --button-ring-color: var(--color-ring-primary-soft);
  }
  .Button_Button[data-variant=soft]:where([data-color=secondary]) {
    --button-background-color: var(--color-background-secondary-soft-alpha);
    --button-background-color-hover: var(--color-background-secondary-soft-alpha-hover);
    --button-background-color-active: var(--color-background-secondary-soft-alpha-active);
    --button-text-color: var(--color-text-secondary-soft);
    --button-ring-color: var(--color-ring-secondary-soft);
  }
  .Button_Button[data-variant=soft]:where([data-color=success]) {
    --button-background-color: var(--color-background-success-soft-alpha);
    --button-background-color-hover: var(--color-background-success-soft-alpha-hover);
    --button-background-color-active: var(--color-background-success-soft-alpha-active);
    --button-text-color: var(--color-text-success-soft);
    --button-ring-color: var(--color-ring-success-soft);
  }
  .Button_Button[data-variant=soft]:where([data-color=danger]) {
    --button-background-color: var(--color-background-danger-soft-alpha);
    --button-background-color-hover: var(--color-background-danger-soft-alpha-hover);
    --button-background-color-active: var(--color-background-danger-soft-alpha-active);
    --button-text-color: var(--color-text-danger-soft);
    --button-ring-color: var(--color-ring-danger-soft);
  }
  .Button_Button[data-variant=soft]:where([data-color=warning]) {
    --button-background-color: var(--color-background-warning-soft-alpha);
    --button-background-color-hover: var(--color-background-warning-soft-alpha-hover);
    --button-background-color-active: var(--color-background-warning-soft-alpha-active);
    --button-text-color: var(--color-text-warning-soft);
    --button-ring-color: var(--color-ring-warning-soft);
  }
  .Button_Button[data-variant=soft]:where([data-color=caution]) {
    --button-background-color: var(--color-background-caution-soft-alpha);
    --button-background-color-hover: var(--color-background-caution-soft-alpha-hover);
    --button-background-color-active: var(--color-background-caution-soft-alpha-active);
    --button-text-color: var(--color-text-caution-soft);
    --button-ring-color: var(--color-ring-caution-soft);
  }
  .Button_Button[data-variant=soft]:where([data-color=info]) {
    --button-background-color: var(--color-background-info-soft-alpha);
    --button-background-color-hover: var(--color-background-info-soft-alpha-hover);
    --button-background-color-active: var(--color-background-info-soft-alpha-active);
    --button-text-color: var(--color-text-info-soft);
    --button-ring-color: var(--color-ring-info-soft);
  }
  .Button_Button[data-variant=soft]:where([data-color=discovery]) {
    --button-background-color: var(--color-background-discovery-soft-alpha);
    --button-background-color-hover: var(--color-background-discovery-soft-alpha-hover);
    --button-background-color-active: var(--color-background-discovery-soft-alpha-active);
    --button-text-color: var(--color-text-discovery-soft);
    --button-ring-color: var(--color-ring-discovery-soft);
  }
  .Button_Button[data-variant=outline] {
    --button-ring-offset: -1px;
    color: var(--button-text-color);
  }
  .Button_Button[data-variant=outline]::before {
    background-color: transparent;
    box-shadow: 0 0 0 1px var(--button-border-color) inset, var(--button-shadow-custom, 0 0 #00000000);
  }
  .Button_Button[data-variant=outline][aria-expanded=true],
  .Button_Button[data-variant=outline][data-state=open],
  .Button_Button[data-variant=outline][data-selected] {
    color: var(--button-text-color-hover);
  }
  .Button_Button[data-variant=outline][aria-expanded=true]::before,
  .Button_Button[data-variant=outline][data-state=open]::before,
  .Button_Button[data-variant=outline][data-selected]::before {
    background-color: var(--button-background-color-hover);
    box-shadow: 0 0 0 1px var(--button-border-color-hover) inset, var(--button-shadow-custom, 0 0 #00000000);
  }
  @media (hover: hover) and (pointer: fine) {
    .Button_Button[data-variant=outline]:where(:not([data-disabled])):hover {
      color: var(--button-text-color-hover);
    }
    .Button_Button[data-variant=outline]:where(:not([data-disabled])):hover::before {
      background-color: var(--button-background-color-hover);
      box-shadow: 0 0 0 1px var(--button-border-color-hover) inset, var(--button-shadow-custom, 0 0 #00000000);
    }
  }
  .Button_Button[data-variant=outline]:where(:not([data-disabled])):active::before {
    background-color: var(--button-background-color-active);
    transform: scale(var(--scale));
  }
  .Button_Button[data-variant=outline]:where(:not([data-disabled])):active::after {
    transform: scale(var(--scale));
  }
  .Button_Button[data-variant=outline]:where([data-color=primary]) {
    --button-background-color-hover: var(--color-background-primary-outline-hover);
    --button-background-color-active: var(--color-background-primary-outline-active);
    --button-border-color: var(--color-border-primary-outline);
    --button-border-color-hover: var(--color-border-primary-outline-hover);
    --button-text-color: var(--color-text-primary-outline);
    --button-text-color-hover: var(--color-text-primary-outline-hover);
    --button-ring-color: var(--color-ring-primary-outline);
  }
  .Button_Button[data-variant=outline]:where([data-color=secondary]) {
    --button-background-color-hover: var(--color-background-secondary-outline-hover);
    --button-background-color-active: var(--color-background-secondary-outline-active);
    --button-border-color: var(--color-border-secondary-outline);
    --button-border-color-hover: var(--color-border-secondary-outline-hover);
    --button-text-color: var(--color-text-secondary-outline);
    --button-text-color-hover: var(--color-text-secondary-outline-hover);
    --button-ring-color: var(--color-ring-secondary-outline);
  }
  .Button_Button[data-variant=outline]:where([data-color=danger]) {
    --button-background-color-hover: var(--color-background-danger-outline-hover);
    --button-background-color-active: var(--color-background-danger-outline-active);
    --button-border-color: var(--color-border-danger-outline);
    --button-border-color-hover: var(--color-border-danger-outline-hover);
    --button-text-color: var(--color-text-danger-outline);
    --button-text-color-hover: var(--color-text-danger-outline-hover);
    --button-ring-color: var(--color-ring-danger-outline);
  }
  .Button_Button[data-variant=outline]:where([data-color=success]) {
    --button-background-color-hover: var(--color-background-success-outline-hover);
    --button-background-color-active: var(--color-background-success-outline-active);
    --button-border-color: var(--color-border-success-outline);
    --button-border-color-hover: var(--color-border-success-outline-hover);
    --button-text-color: var(--color-text-success-outline);
    --button-text-color-hover: var(--color-text-success-outline-hover);
    --button-ring-color: var(--color-ring-success-outline);
  }
  .Button_Button[data-variant=outline]:where([data-color=warning]) {
    --button-background-color-hover: var(--color-background-warning-outline-hover);
    --button-background-color-active: var(--color-background-warning-outline-active);
    --button-border-color: var(--color-border-warning-outline);
    --button-border-color-hover: var(--color-border-warning-outline-hover);
    --button-text-color: var(--color-text-warning-outline);
    --button-text-color-hover: var(--color-text-warning-outline-hover);
    --button-ring-color: var(--color-ring-warning-outline);
  }
  .Button_Button[data-variant=outline]:where([data-color=caution]) {
    --button-background-color-hover: var(--color-background-caution-outline-hover);
    --button-background-color-active: var(--color-background-caution-outline-active);
    --button-border-color: var(--color-border-caution-outline);
    --button-border-color-hover: var(--color-border-caution-outline-hover);
    --button-text-color: var(--color-text-caution-outline);
    --button-text-color-hover: var(--color-text-caution-outline-hover);
    --button-ring-color: var(--color-ring-caution-outline);
  }
  .Button_Button[data-variant=outline]:where([data-color=info]) {
    --button-background-color-hover: var(--color-background-info-outline-hover);
    --button-background-color-active: var(--color-background-info-outline-active);
    --button-border-color: var(--color-border-info-outline);
    --button-border-color-hover: var(--color-border-info-outline-hover);
    --button-text-color: var(--color-text-info-outline);
    --button-text-color-hover: var(--color-text-info-outline-hover);
    --button-ring-color: var(--color-ring-info-outline);
  }
  .Button_Button[data-variant=outline]:where([data-color=discovery]) {
    --button-background-color-hover: var(--color-background-discovery-outline-hover);
    --button-background-color-active: var(--color-background-discovery-outline-active);
    --button-border-color: var(--color-border-discovery-outline);
    --button-border-color-hover: var(--color-border-discovery-outline-hover);
    --button-text-color: var(--color-text-discovery-outline);
    --button-text-color-hover: var(--color-text-discovery-outline-hover);
    --button-ring-color: var(--color-ring-discovery-outline);
  }
  .Button_Button[disabled] {
    pointer-events: none;
  }
  .Button_Button[data-disabled][data-variant] {
    --button-background-color: var(--color-background-disabled);
    --button-border-color: var(--color-border-disabled);
    --button-text-color: var(--color-text-disabled);
    cursor: not-allowed;
    pointer-events: auto;
  }
  .Button_Button[data-disabled][data-variant]:active::before {
    transform: scale(1);
  }
  .Button_Button[data-disabled][data-variant][data-disabled-tone=relaxed] {
    cursor: default;
  }
  .Button_ButtonInner {
    position: relative;
    display: flex;
    flex-direction: inherit;
    align-items: center;
    justify-content: center;
    gap: inherit;
    width: 100%;
    height: 100%;
    transition: opacity 0.15s ease 0.1s;
  }
  [data-loading] .Button_ButtonInner {
    opacity: 0;
    transition: opacity 0.3s ease;
  }
  .Button_ButtonLoader {
    position: absolute;
    inset: 0;
    z-index: 3;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
  }
  .Button_ButtonLoader[data-entering] {
    opacity: 0;
  }
  .Button_ButtonLoader[data-exiting] {
    opacity: 1;
  }
  .Button_ButtonLoader[data-entering-active],
  .Button_ButtonLoader[data-entering][data-interrupted] {
    opacity: 1;
    transition: opacity 0.15s ease 0.1s;
  }
  .Button_ButtonLoader[data-exiting-active],
  .Button_ButtonLoader[data-exiting][data-interrupted] {
    opacity: 0;
    transition: opacity 0.15s ease;
  }
}
@layer components {
  .Animate_TransitionItem {
    will-change: var(--tg-will-change);
  }
  [data-transition-position=absolute] .Animate_TransitionItem[data-exiting],
  [data-transition-position=absolute] .Animate_TransitionItem:not([data-exiting]) + .Animate_TransitionItem[data-entering] {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
  }
  .Animate_TransitionItem[data-entering] {
    filter: var(--tg-initial-filter);
    opacity: var(--tg-initial-opacity);
    transform: var(--tg-initial-transform);
  }
  .Animate_TransitionItem[data-exiting] {
    filter: var(--tg-enter-filter);
    opacity: var(--tg-enter-opacity);
    transform: var(--tg-enter-transform);
  }
  .Animate_TransitionItem[data-entering-active],
  .Animate_TransitionItem[data-entering][data-interrupted] {
    filter: var(--tg-enter-filter);
    opacity: var(--tg-enter-opacity);
    transform: var(--tg-enter-transform);
    transition:
      opacity var(--tg-enter-duration) var(--tg-enter-timing-function) var(--tg-enter-delay),
      transform var(--tg-enter-duration) var(--tg-enter-timing-function) var(--tg-enter-delay),
      filter var(--tg-enter-duration) var(--tg-enter-timing-function) var(--tg-enter-delay);
  }
  .Animate_TransitionItem[data-exiting-active],
  .Animate_TransitionItem[data-exiting][data-interrupted] {
    filter: var(--tg-exit-filter, none);
    opacity: var(--tg-exit-opacity, 0);
    transform: var(--tg-exit-transform, none);
    transition:
      opacity var(--tg-exit-duration) var(--tg-exit-timing-function) var(--tg-exit-delay),
      transform var(--tg-exit-duration) var(--tg-exit-timing-function) var(--tg-exit-delay),
      filter var(--tg-exit-duration) var(--tg-exit-timing-function) var(--tg-exit-delay);
  }
  .Animate_TransitionItem[data-entering][data-interrupted],
  .Animate_TransitionItem[data-exiting][data-interrupted] {
    transition-delay: 0ms;
  }
}
@layer components {
  .AnimateLayout_Layout {
    position: relative;
    display: block;
    flex-shrink: 0;
    transition-property: height, width;
  }
  .AnimateLayout_Layout[data-clip=true] {
    overflow: hidden;
  }
  .AnimateLayout_Layout[data-direction=in] {
    transition-delay: var(--tg-layout-enter-delay);
    transition-duration: var(--tg-layout-enter-duration);
    transition-timing-function: var(--tg-layout-enter-timing-function);
  }
  .AnimateLayout_Layout[data-direction=out] {
    transition-delay: var(--tg-layout-exit-delay);
    transition-duration: var(--tg-layout-exit-duration);
    transition-timing-function: var(--tg-layout-exit-timing-function);
  }
  .AnimateLayout_Layout[data-direction=move] {
    transition-delay: var(--tg-layout-move-delay);
    transition-duration: var(--tg-layout-move-duration);
    transition-timing-function: var(--tg-layout-move-timing-function);
  }
  .AnimateLayout_Layout[data-interrupted=true] {
    transition-delay: 0ms;
  }
  .AnimateLayout_TransitionItem {
    flex-shrink: 0;
    will-change: var(--tg-will-change, auto);
  }
  .AnimateLayout_TransitionItem[data-entering],
  .AnimateLayout_TransitionItem[data-exiting] {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
  }
  .AnimateLayout_Layout[data-dimension=width] > .AnimateLayout_TransitionItem[data-entering],
  .AnimateLayout_Layout[data-dimension=width] > .AnimateLayout_TransitionItem[data-exiting] {
    width: auto;
  }
  .AnimateLayout_Layout[data-item-anchor=end] > .AnimateLayout_TransitionItem[data-entering],
  .AnimateLayout_Layout[data-item-anchor=end] > .AnimateLayout_TransitionItem[data-exiting] {
    top: initial;
    bottom: 0;
  }
  .AnimateLayout_Layout[data-item-anchor=end][data-dimension=width] > .AnimateLayout_TransitionItem[data-entering],
  .AnimateLayout_Layout[data-item-anchor=end][data-dimension=width] > .AnimateLayout_TransitionItem[data-exiting] {
    right: 0;
    left: initial;
  }
  .AnimateLayout_TransitionItem[data-entering] {
    filter: var(--tg-initial-filter);
    opacity: var(--tg-initial-opacity);
    transform: var(--tg-initial-transform);
  }
  .AnimateLayout_TransitionItem[data-exiting] {
    filter: var(--tg-enter-filter);
    opacity: var(--tg-enter-opacity);
    transform: var(--tg-enter-transform);
  }
  .AnimateLayout_TransitionItem[data-entering-active],
  .AnimateLayout_TransitionItem[data-entering][data-interrupted] {
    filter: var(--tg-enter-filter);
    opacity: var(--tg-enter-opacity);
    transform: var(--tg-enter-transform);
    transition:
      opacity var(--tg-enter-duration) var(--tg-enter-timing-function) var(--tg-enter-delay),
      transform var(--tg-enter-duration) var(--tg-enter-timing-function) var(--tg-enter-delay),
      filter var(--tg-enter-duration) var(--tg-enter-timing-function) var(--tg-enter-delay);
  }
  .AnimateLayout_TransitionItem[data-exiting-active],
  .AnimateLayout_TransitionItem[data-exiting][data-interrupted] {
    filter: var(--tg-exit-filter);
    opacity: var(--tg-exit-opacity);
    transform: var(--tg-exit-transform);
    transition:
      opacity var(--tg-exit-duration) var(--tg-exit-timing-function) var(--tg-exit-delay),
      transform var(--tg-exit-duration) var(--tg-exit-timing-function) var(--tg-exit-delay),
      filter var(--tg-exit-duration) var(--tg-exit-timing-function) var(--tg-exit-delay);
  }
}
@layer components {
  .AnimateLayoutGroup_LayoutItem {
    position: relative;
    flex-shrink: 0;
  }
  .AnimateLayoutGroup_LayoutItem[data-entering-active],
  .AnimateLayoutGroup_LayoutItem[data-entering][data-interrupted] {
    transition: height var(--tg-layout-enter-duration) var(--tg-layout-enter-timing-function) var(--tg-layout-enter-delay), width var(--tg-layout-enter-duration) var(--tg-layout-enter-timing-function) var(--tg-layout-enter-delay);
  }
  .AnimateLayoutGroup_LayoutItem[data-exiting-active],
  .AnimateLayoutGroup_LayoutItem[data-exiting][data-interrupted] {
    transition: height var(--tg-layout-exit-duration) var(--tg-layout-exit-timing-function) var(--tg-layout-exit-delay), width var(--tg-layout-exit-duration) var(--tg-layout-exit-timing-function) var(--tg-layout-exit-delay);
  }
  .AnimateLayoutGroup_TransitionItem {
    display: block;
    will-change: var(--tg-will-change);
  }
  .AnimateLayoutGroup_LayoutItem[data-entering] > .AnimateLayoutGroup_TransitionItem {
    filter: var(--tg-initial-filter);
    opacity: var(--tg-initial-opacity);
    transform: var(--tg-initial-transform);
  }
  .AnimateLayoutGroup_LayoutItem[data-exiting] > .AnimateLayoutGroup_TransitionItem {
    filter: var(--tg-enter-filter);
    opacity: var(--tg-enter-opacity);
    transform: var(--tg-enter-transform);
  }
  .AnimateLayoutGroup_LayoutItem[data-entering] > .AnimateLayoutGroup_TransitionItem[data-dimension=width] {
    position: absolute;
    top: 0;
    left: 0;
  }
  .AnimateLayoutGroup_LayoutItem[data-entering-active] > .AnimateLayoutGroup_TransitionItem,
  .AnimateLayoutGroup_LayoutItem[data-entering][data-interrupted] > .AnimateLayoutGroup_TransitionItem {
    filter: var(--tg-enter-filter);
    opacity: var(--tg-enter-opacity);
    transform: var(--tg-enter-transform);
    transition:
      opacity var(--tg-enter-duration) var(--tg-enter-timing-function) var(--tg-enter-delay),
      transform var(--tg-enter-duration) var(--tg-enter-timing-function) var(--tg-enter-delay),
      filter var(--tg-enter-duration) var(--tg-enter-timing-function) var(--tg-enter-delay);
  }
  .AnimateLayoutGroup_LayoutItem[data-exiting-active] > .AnimateLayoutGroup_TransitionItem,
  .AnimateLayoutGroup_LayoutItem[data-exiting][data-interrupted] > .AnimateLayoutGroup_TransitionItem {
    filter: var(--tg-exit-filter);
    opacity: var(--tg-exit-opacity, 0);
    transform: var(--tg-exit-transform);
    transition:
      opacity var(--tg-exit-duration) var(--tg-exit-timing-function) var(--tg-exit-delay),
      transform var(--tg-exit-duration) var(--tg-exit-timing-function) var(--tg-exit-delay),
      filter var(--tg-exit-duration) var(--tg-exit-timing-function) var(--tg-exit-delay);
  }
}
@layer components {
  .Badge_Badge {
    --indicator-size: var(--badge-indicator-size);
    display: inline-flex;
    align-items: center;
    gap: calc(var(--spacing) * 1);
    height: var(--badge-size);
    padding: 0 var(--badge-gutter);
    border-radius: var(--badge-radius);
    font-size: var(--badge-font-size);
    font-weight: var(--badge-font-weight);
    letter-spacing: var(--badge-tracking);
    white-space: nowrap;
  }
  .Badge_Badge svg {
    font-size: var(--badge-icon-font-size);
  }
  :where(.Badge_Badge svg:first-child:not(:only-child)) {
    margin-left: var(--badge-icon-offset, -1px);
  }
  :where(.Badge_Badge svg:last-child:not(:only-child)) {
    margin-right: var(--badge-icon-offset, -1px);
  }
  .Badge_Badge[data-variant=soft] {
    background-color: var(--badge-background-color);
    color: var(--badge-text-color);
  }
  .Badge_Badge[data-variant=soft]:where([data-color=secondary]) {
    --badge-background-color: var(--color-background-secondary-soft-alpha);
    --badge-text-color: var(--color-text-secondary-soft);
  }
  .Badge_Badge[data-variant=soft]:where([data-color=success]) {
    --badge-background-color: var(--color-background-success-soft-alpha);
    --badge-text-color: var(--color-text-success-soft);
  }
  .Badge_Badge[data-variant=soft]:where([data-color=warning]) {
    --badge-background-color: var(--color-background-warning-soft-alpha);
    --badge-text-color: var(--color-text-warning-soft);
  }
  .Badge_Badge[data-variant=soft]:where([data-color=danger]) {
    --badge-background-color: var(--color-background-danger-soft-alpha);
    --badge-text-color: var(--color-text-danger-soft);
  }
  .Badge_Badge[data-variant=soft]:where([data-color=info]) {
    --badge-background-color: var(--color-background-info-soft-alpha);
    --badge-text-color: var(--color-text-info-soft);
  }
  .Badge_Badge[data-variant=soft]:where([data-color=discovery]) {
    --badge-background-color: var(--color-background-discovery-soft-alpha);
    --badge-text-color: var(--color-text-discovery-soft);
  }
  .Badge_Badge[data-variant=solid] {
    background-color: var(--badge-background-color);
    color: var(--badge-text-color);
  }
  .Badge_Badge[data-variant=solid]:where([data-color=secondary]) {
    --badge-background-color: var(--color-background-secondary-solid);
    --badge-text-color: var(--color-text-secondary-solid);
  }
  .Badge_Badge[data-variant=solid]:where([data-color=success]) {
    --badge-background-color: var(--color-background-success-solid);
    --badge-text-color: var(--color-text-success-solid);
  }
  .Badge_Badge[data-variant=solid]:where([data-color=warning]) {
    --badge-background-color: var(--color-background-warning-solid);
    --badge-text-color: var(--color-text-warning-solid);
  }
  .Badge_Badge[data-variant=solid]:where([data-color=danger]) {
    --badge-background-color: var(--color-background-danger-solid);
    --badge-text-color: var(--color-text-danger-solid);
  }
  .Badge_Badge[data-variant=solid]:where([data-color=info]) {
    --badge-background-color: var(--color-background-info-solid);
    --badge-text-color: var(--color-text-info-solid);
  }
  .Badge_Badge[data-variant=solid]:where([data-color=discovery]) {
    --badge-background-color: var(--color-background-discovery-solid);
    --badge-text-color: var(--color-text-discovery-solid);
  }
  .Badge_Badge[data-variant=outline] {
    box-shadow: 0 0 0 1px var(--badge-border-color) inset;
    color: var(--badge-text-color);
  }
  .Badge_Badge[data-variant=outline]:where([data-color=secondary]) {
    --badge-border-color: var(--color-border-secondary-outline);
    --badge-text-color: var(--color-text-secondary-outline);
  }
  .Badge_Badge[data-variant=outline]:where([data-color=success]) {
    --badge-border-color: var(--color-border-success-outline);
    --badge-text-color: var(--color-text-success-outline);
  }
  .Badge_Badge[data-variant=outline]:where([data-color=warning]) {
    --badge-border-color: var(--color-border-warning-outline);
    --badge-text-color: var(--color-text-warning-outline);
  }
  .Badge_Badge[data-variant=outline]:where([data-color=danger]) {
    --badge-border-color: var(--color-border-danger-outline);
    --badge-text-color: var(--color-text-danger-outline);
  }
  .Badge_Badge[data-variant=outline]:where([data-color=info]) {
    --badge-border-color: var(--color-border-info-outline);
    --badge-text-color: var(--color-text-info-outline);
  }
  .Badge_Badge[data-variant=outline]:where([data-color=discovery]) {
    --badge-border-color: var(--color-border-discovery-outline);
    --badge-text-color: var(--color-text-discovery-outline);
  }
  .Badge_Badge:where([data-size=sm]) {
    --badge-size: var(--badge-size-sm);
    --badge-gutter: var(--badge-gutter-sm);
    --badge-font-size: var(--badge-font-size-sm);
    --badge-font-weight: var(--badge-font-weight-sm);
    --badge-tracking: var(--badge-tracking-sm);
    --badge-radius: var(--badge-radius-sm);
    --badge-icon-font-size: var(--badge-icon-font-size-sm);
    --badge-indicator-size: var(--badge-indicator-size-sm);
  }
  .Badge_Badge:where([data-size=md]) {
    --badge-size: var(--badge-size-md);
    --badge-gutter: var(--badge-gutter-md);
    --badge-font-size: var(--badge-font-size-md);
    --badge-font-weight: var(--badge-font-weight-md);
    --badge-tracking: var(--badge-tracking-md);
    --badge-radius: var(--badge-radius-md);
    --badge-icon-font-size: var(--badge-icon-font-size-md);
    --badge-indicator-size: var(--badge-indicator-size-md);
  }
  .Badge_Badge:where([data-size=lg]) {
    --badge-size: var(--badge-size-lg);
    --badge-gutter: var(--badge-gutter-lg);
    --badge-font-size: var(--badge-font-size-lg);
    --badge-font-weight: var(--badge-font-weight-lg);
    --badge-tracking: var(--badge-tracking-lg);
    --badge-radius: var(--badge-radius-lg);
    --badge-icon-font-size: var(--badge-icon-font-size-lg);
    --badge-indicator-size: var(--badge-indicator-size-lg);
  }
  .Badge_Badge:where([data-pill]) {
    --badge-radius: var(--radius-full);
    padding: 0 calc(var(--badge-gutter) * var(--control-gutter-pill-scaling));
  }
}
@layer components {
  .EmptyMessage_EmptyMessage {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  .EmptyMessage_EmptyMessage[data-fill=static] {
    width: 100%;
    height: 100%;
  }
  .EmptyMessage_EmptyMessage[data-fill=absolute] {
    position: absolute;
    inset: 0;
  }
  .EmptyMessage_IconBadge {
    --badge-size: 40px;
    --icon-size: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    width: var(--badge-size);
    height: var(--badge-size);
    border-radius: var(--radius-md);
    margin: 0 0 12px;
    background: var(--badge-background-color);
    color: var(--badge-text-color);
  }
  .EmptyMessage_IconBadge svg {
    width: var(--icon-size);
    height: var(--icon-size);
  }
  .EmptyMessage_IconBadge[data-size=sm] {
    --badge-size: 32px;
    --icon-size: 20px;
  }
  .EmptyMessage_IconBadge[data-color=secondary] {
    --badge-background-color: var(--color-background-secondary-soft);
    --badge-text-color: var(--color-text-secondary-soft);
  }
  .EmptyMessage_IconBadge[data-color=warning] {
    --badge-background-color: var(--color-background-warning-soft);
    --badge-text-color: var(--color-text-warning-soft);
  }
  .EmptyMessage_IconBadge[data-color=danger] {
    --badge-background-color: var(--color-background-danger-soft);
    --badge-text-color: var(--color-text-danger-soft);
  }
  .EmptyMessage_Title {
    max-width: 90%;
    color: var(--color-text);
    font-size: 16px;
    font-weight: var(--font-weight-semibold);
    text-align: center;
    text-wrap: balance;
  }
  .EmptyMessage_Title:where([data-color=danger]) {
    color: var(--color-text-danger);
  }
  .EmptyMessage_Title:where([data-color=warning]) {
    color: var(--color-text-warning);
  }
  .EmptyMessage_Description {
    max-width: 90%;
    margin: 6px 0 0;
    color: var(--color-text-secondary);
    font-size: 14px;
    line-height: 1.45;
    text-align: center;
    text-wrap: balance;
  }
  .EmptyMessage_ActionRow {
    margin-top: calc(var(--spacing) * 4);
  }
}
@layer components {
  .Tooltip_Tooltip {
    max-width: 300px;
    border-radius: var(--radius-md);
    background: var(--color-surface-elevated);
    box-shadow: var(--shadow), var(--shadow-hairline);
    font-size: 14px;
    line-height: 1.45;
  }
  .Tooltip_Tooltip[data-clickable=false] {
    cursor: default;
  }
  .Tooltip_Tooltip[data-clickable=true] {
    cursor: pointer;
  }
  @media (hover: hover) and (pointer: fine) {
    .Tooltip_Tooltip[data-compact=true][data-clickable=true]:hover {
      background: var(--gray-600);
      color: var(--gray-0);
    }
  }
  .Tooltip_Tooltip[data-gutter-size=sm] {
    padding: 8px 12px;
  }
  .Tooltip_Tooltip[data-gutter-size=md] {
    padding: 12px 16px;
  }
  .Tooltip_Tooltip[data-gutter-size=lg] {
    padding: 14px 18px;
  }
  .Tooltip_Tooltip[data-compact=true] {
    padding: 2px 8px;
    background: var(--gray-700);
    color: var(--gray-0);
    font-size: 14px;
  }
  @keyframes Tooltip_scale-in {
    from {
      opacity: 0;
      transform: scale(0.95);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }
  @keyframes Tooltip_scale-out {
    from {
      opacity: 1;
      transform: scale(1);
    }
    to {
      opacity: 0;
      transform: scale(0.95);
    }
  }
  .Tooltip_TriggerDecorator {
    display: inline-flex;
    cursor: pointer;
    -webkit-text-decoration: underline dotted;
    text-decoration: underline dotted;
    text-decoration-color: transparent;
  }
  .Tooltip_TriggerDecorator:focus {
    outline: 0;
  }
  .Tooltip_TriggerDecorator[data-state*=open] {
    text-decoration-color: var(--color-text-tertiary);
    transition-timing-function: var(--cubic-enter);
  }
}
/* __CHATGPT_APP_CSS_END__ */
/* __CHATGPT_APP_JS_START__ */
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/react/cjs/react-jsx-runtime.production.js
var require_react_jsx_runtime_production = __commonJS({
  "node_modules/react/cjs/react-jsx-runtime.production.js"(exports) {
    "use strict";
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    function jsxProd(type, config, maybeKey) {
      var key = null;
      void 0 !== maybeKey && (key = "" + maybeKey);
      void 0 !== config.key && (key = "" + config.key);
      if ("key" in config) {
        maybeKey = {};
        for (var propName in config)
          "key" !== propName && (maybeKey[propName] = config[propName]);
      } else maybeKey = config;
      config = maybeKey.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== config ? config : null,
        props: maybeKey
      };
    }
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsx = jsxProd;
    exports.jsxs = jsxProd;
  }
});

// node_modules/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "node_modules/react/jsx-runtime.js"(exports, module) {
    "use strict";
    if (true) {
      module.exports = require_react_jsx_runtime_production();
    } else {
      module.exports = null;
    }
  }
});

// node_modules/react/cjs/react.production.js
var require_react_production = __commonJS({
  "node_modules/react/cjs/react.production.js"(exports) {
    "use strict";
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    };
    var assign = Object.assign;
    var emptyObject = {};
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {
    }
    ComponentDummy.prototype = Component.prototype;
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl = Array.isArray;
    function noop4() {
    }
    var ReactSharedInternals = { H: null, A: null, T: null, S: null };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function ReactElement(type, key, props) {
      var refProp = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== refProp ? refProp : null,
        props
      };
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(oldElement.type, newKey, oldElement.props);
    }
    function isValidElement3(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index2) {
      return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index2.toString(36);
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop4, noop4) : (thenable.status = "pending", thenable.then(
            function(fulfilledValue) {
              "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
            },
            function(error) {
              "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
            }
          )), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type) children = null;
      var invokeCallback = false;
      if (null === children) invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(
                  invokeCallback(children._payload),
                  array,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
            }
        }
      if (invokeCallback)
        return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
          return c;
        })) : null != callback && (isValidElement3(callback) && (callback = cloneAndReplaceKey(
          callback,
          escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
            userProvidedKeyEscapeRegex,
            "$&/"
          ) + "/") + invokeCallback
        )), array.push(callback)), 1;
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if (i = getIteratorFn(children), "function" === typeof i)
        for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children) return children;
      var result = [], count2 = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count2++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function(moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 1, payload._result = moduleObject;
          },
          function(error) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 2, payload._result = error;
          }
        );
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status) return payload._result.default;
      throw payload._result;
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    };
    var Children7 = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function() {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement3(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    exports.Activity = REACT_ACTIVITY_TYPE;
    exports.Children = Children7;
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function(size4) {
        return ReactSharedInternals.H.useMemoCache(size4);
      }
    };
    exports.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    exports.cacheSignal = function() {
      return null;
    };
    exports.cloneElement = function(element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " + element + "."
        );
      var props = assign({}, element.props), key = element.key;
      if (null != config)
        for (propName in void 0 !== config.key && (key = "" + config.key), config)
          !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
      var propName = arguments.length - 2;
      if (1 === propName) props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i = 0; i < propName; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      return ReactElement(element.type, key, props);
    };
    exports.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      return defaultValue;
    };
    exports.createElement = function(type, config, children) {
      var propName, props = {}, key = null;
      if (null != config)
        for (propName in void 0 !== config.key && (key = "" + config.key), config)
          hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength) props.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          void 0 === props[propName] && (props[propName] = childrenLength[propName]);
      return ReactElement(type, key, props);
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(render) {
      return { $$typeof: REACT_FORWARD_REF_TYPE, render };
    };
    exports.isValidElement = isValidElement3;
    exports.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    exports.memo = function(type, compare) {
      return {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: void 0 === compare ? null : compare
      };
    };
    exports.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop4, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    };
    exports.unstable_useCacheRefresh = function() {
      return ReactSharedInternals.H.useCacheRefresh();
    };
    exports.use = function(usable) {
      return ReactSharedInternals.H.use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
      return ReactSharedInternals.H.useCallback(callback, deps);
    };
    exports.useContext = function(Context) {
      return ReactSharedInternals.H.useContext(Context);
    };
    exports.useDebugValue = function() {
    };
    exports.useDeferredValue = function(value, initialValue) {
      return ReactSharedInternals.H.useDeferredValue(value, initialValue);
    };
    exports.useEffect = function(create, deps) {
      return ReactSharedInternals.H.useEffect(create, deps);
    };
    exports.useEffectEvent = function(callback) {
      return ReactSharedInternals.H.useEffectEvent(callback);
    };
    exports.useId = function() {
      return ReactSharedInternals.H.useId();
    };
    exports.useImperativeHandle = function(ref, create, deps) {
      return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function(create, deps) {
      return ReactSharedInternals.H.useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function(create, deps) {
      return ReactSharedInternals.H.useLayoutEffect(create, deps);
    };
    exports.useMemo = function(create, deps) {
      return ReactSharedInternals.H.useMemo(create, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
      return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArg, init) {
      return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
    };
    exports.useRef = function(initialValue) {
      return ReactSharedInternals.H.useRef(initialValue);
    };
    exports.useState = function(initialState) {
      return ReactSharedInternals.H.useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return ReactSharedInternals.H.useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    exports.useTransition = function() {
      return ReactSharedInternals.H.useTransition();
    };
    exports.version = "19.2.3";
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    "use strict";
    if (true) {
      module.exports = require_react_production();
    } else {
      module.exports = null;
    }
  }
});

// node_modules/lodash.debounce/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = debounce2;
  }
});

// node_modules/react-dom/cjs/react-dom.production.js
var require_react_dom_production = __commonJS({
  "node_modules/react-dom/cjs/react-dom.production.js"(exports) {
    "use strict";
    var React25 = require_react();
    function formatProdErrorMessage(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i = 2; i < arguments.length; i++)
          url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function noop4() {
    }
    var Internals = {
      d: {
        f: noop4,
        r: function() {
          throw Error(formatProdErrorMessage(522));
        },
        D: noop4,
        C: noop4,
        L: noop4,
        m: noop4,
        X: noop4,
        S: noop4,
        M: noop4
      },
      p: 0,
      findDOMNode: null
    };
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    function createPortal$1(children, containerInfo, implementation) {
      var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return {
        $$typeof: REACT_PORTAL_TYPE,
        key: null == key ? null : "" + key,
        children,
        containerInfo,
        implementation
      };
    }
    var ReactSharedInternals = React25.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function getCrossOriginStringAs(as, input) {
      if ("font" === as) return "";
      if ("string" === typeof input)
        return "use-credentials" === input ? input : "";
    }
    exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
    exports.createPortal = function(children, container) {
      var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
        throw Error(formatProdErrorMessage(299));
      return createPortal$1(children, container, null, key);
    };
    exports.flushSync = function(fn) {
      var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
      try {
        if (ReactSharedInternals.T = null, Internals.p = 2, fn) return fn();
      } finally {
        ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
      }
    };
    exports.preconnect = function(href, options) {
      "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
    };
    exports.prefetchDNS = function(href) {
      "string" === typeof href && Internals.d.D(href);
    };
    exports.preinit = function(href, options) {
      if ("string" === typeof href && options && "string" === typeof options.as) {
        var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
        "style" === as ? Internals.d.S(
          href,
          "string" === typeof options.precedence ? options.precedence : void 0,
          {
            crossOrigin,
            integrity,
            fetchPriority
          }
        ) : "script" === as && Internals.d.X(href, {
          crossOrigin,
          integrity,
          fetchPriority,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0
        });
      }
    };
    exports.preinitModule = function(href, options) {
      if ("string" === typeof href)
        if ("object" === typeof options && null !== options) {
          if (null == options.as || "script" === options.as) {
            var crossOrigin = getCrossOriginStringAs(
              options.as,
              options.crossOrigin
            );
            Internals.d.M(href, {
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0,
              nonce: "string" === typeof options.nonce ? options.nonce : void 0
            });
          }
        } else null == options && Internals.d.M(href);
    };
    exports.preload = function(href, options) {
      if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
        var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
        Internals.d.L(href, as, {
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0,
          nonce: "string" === typeof options.nonce ? options.nonce : void 0,
          type: "string" === typeof options.type ? options.type : void 0,
          fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
          referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
          imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
          imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
          media: "string" === typeof options.media ? options.media : void 0
        });
      }
    };
    exports.preloadModule = function(href, options) {
      if ("string" === typeof href)
        if (options) {
          var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
          Internals.d.m(href, {
            as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0
          });
        } else Internals.d.m(href);
    };
    exports.requestFormReset = function(form) {
      Internals.d.r(form);
    };
    exports.unstable_batchedUpdates = function(fn, a) {
      return fn(a);
    };
    exports.useFormState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useFormState(action, initialState, permalink);
    };
    exports.useFormStatus = function() {
      return ReactSharedInternals.H.useHostTransitionStatus();
    };
    exports.version = "19.2.3";
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS({
  "node_modules/react-dom/index.js"(exports, module) {
    "use strict";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      if (false) {
        throw new Error("^_^");
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    if (true) {
      checkDCE();
      module.exports = require_react_dom_production();
    } else {
      module.exports = null;
    }
  }
});

// node_modules/scheduler/cjs/scheduler.production.js
var require_scheduler_production = __commonJS({
  "node_modules/scheduler/cjs/scheduler.production.js"(exports) {
    "use strict";
    function push(heap, node) {
      var index2 = heap.length;
      heap.push(node);
      a: for (; 0 < index2; ) {
        var parentIndex = index2 - 1 >>> 1, parent = heap[parentIndex];
        if (0 < compare(parent, node))
          heap[parentIndex] = node, heap[index2] = parent, index2 = parentIndex;
        else break a;
      }
    }
    function peek(heap) {
      return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
      if (0 === heap.length) return null;
      var first = heap[0], last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a: for (var index2 = 0, length = heap.length, halfLength = length >>> 1; index2 < halfLength; ) {
          var leftIndex = 2 * (index2 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
          if (0 > compare(left, last))
            rightIndex < length && 0 > compare(right, left) ? (heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex) : (heap[index2] = left, heap[leftIndex] = last, index2 = leftIndex);
          else if (rightIndex < length && 0 > compare(right, last))
            heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex;
          else break a;
        }
      }
      return first;
    }
    function compare(a, b) {
      var diff = a.sortIndex - b.sortIndex;
      return 0 !== diff ? diff : a.id - b.id;
    }
    exports.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
      localPerformance = performance;
      exports.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      localDate = Date, initialTime = localDate.now();
      exports.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var localPerformance;
    var localDate;
    var initialTime;
    var taskQueue = [];
    var timerQueue = [];
    var taskIdCounter = 1;
    var currentTask = null;
    var currentPriorityLevel = 3;
    var isPerformingWork = false;
    var isHostCallbackScheduled = false;
    var isHostTimeoutScheduled = false;
    var needsPaint = false;
    var localSetTimeout = "function" === typeof setTimeout ? setTimeout : null;
    var localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null;
    var localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer; ) {
        if (null === timer.callback) pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        else break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (null !== peek(taskQueue))
          isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
        else {
          var firstTimer = peek(timerQueue);
          null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    var isMessageLoopRunning = false;
    var taskTimeoutID = -1;
    var frameInterval = 5;
    var startTime = -1;
    function shouldYieldToHost() {
      return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
    }
    function performWorkUntilDeadline() {
      needsPaint = false;
      if (isMessageLoopRunning) {
        var currentTime = exports.unstable_now();
        startTime = currentTime;
        var hasMoreWork = true;
        try {
          a: {
            isHostCallbackScheduled = false;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(
                      currentTask.expirationTime <= currentTime
                    );
                    currentTime = exports.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = true;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = true;
                else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer && requestHostTimeout(
                    handleTimeout,
                    firstTimer.startTime - currentTime
                  );
                  hasMoreWork = false;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
        }
      }
    }
    var schedulePerformWorkUntilDeadline;
    if ("function" === typeof localSetImmediate)
      schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if ("undefined" !== typeof MessageChannel) {
      channel = new MessageChannel(), port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function() {
        port.postMessage(null);
      };
    } else
      schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    var channel;
    var port;
    function requestHostTimeout(callback, ms) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports.unstable_now());
      }, ms);
    }
    exports.unstable_IdlePriority = 5;
    exports.unstable_ImmediatePriority = 1;
    exports.unstable_LowPriority = 4;
    exports.unstable_NormalPriority = 3;
    exports.unstable_Profiling = null;
    exports.unstable_UserBlockingPriority = 2;
    exports.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports.unstable_forceFrameRate = function(fps) {
      0 > fps || 125 < fps ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports.unstable_next = function(eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_requestPaint = function() {
      needsPaint = true;
    };
    exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      var currentTime = exports.unstable_now();
      "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports.unstable_shouldYield = shouldYieldToHost;
    exports.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS({
  "node_modules/scheduler/index.js"(exports, module) {
    "use strict";
    if (true) {
      module.exports = require_scheduler_production();
    } else {
      module.exports = null;
    }
  }
});

// node_modules/react-dom/cjs/react-dom-client.production.js
var require_react_dom_client_production = __commonJS({
  "node_modules/react-dom/cjs/react-dom-client.production.js"(exports) {
    "use strict";
    var Scheduler = require_scheduler();
    var React25 = require_react();
    var ReactDOM5 = require_react_dom();
    function formatProdErrorMessage(code) {
      var url = "https://react.dev/errors/" + code;
      if (1 < arguments.length) {
        url += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var i = 2; i < arguments.length; i++)
          url += "&args[]=" + encodeURIComponent(arguments[i]);
      }
      return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function isValidContainer(node) {
      return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
    }
    function getNearestMountedFiber(fiber) {
      var node = fiber, nearestMounted = fiber;
      if (fiber.alternate) for (; node.return; ) node = node.return;
      else {
        fiber = node;
        do
          node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
        while (fiber);
      }
      return 3 === node.tag ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (13 === fiber.tag) {
        var suspenseState = fiber.memoizedState;
        null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
        if (null !== suspenseState) return suspenseState.dehydrated;
      }
      return null;
    }
    function getActivityInstanceFromFiber(fiber) {
      if (31 === fiber.tag) {
        var activityState = fiber.memoizedState;
        null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
        if (null !== activityState) return activityState.dehydrated;
      }
      return null;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw Error(formatProdErrorMessage(188));
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        alternate = getNearestMountedFiber(fiber);
        if (null === alternate) throw Error(formatProdErrorMessage(188));
        return alternate !== fiber ? null : fiber;
      }
      for (var a = fiber, b = alternate; ; ) {
        var parentA = a.return;
        if (null === parentA) break;
        var parentB = parentA.alternate;
        if (null === parentB) {
          b = parentA.return;
          if (null !== b) {
            a = b;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (parentB = parentA.child; parentB; ) {
            if (parentB === a) return assertIsMounted(parentA), fiber;
            if (parentB === b) return assertIsMounted(parentA), alternate;
            parentB = parentB.sibling;
          }
          throw Error(formatProdErrorMessage(188));
        }
        if (a.return !== b.return) a = parentA, b = parentB;
        else {
          for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
            if (child$0 === a) {
              didFindChild = true;
              a = parentA;
              b = parentB;
              break;
            }
            if (child$0 === b) {
              didFindChild = true;
              b = parentA;
              a = parentB;
              break;
            }
            child$0 = child$0.sibling;
          }
          if (!didFindChild) {
            for (child$0 = parentB.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentB;
                b = parentA;
                break;
              }
              if (child$0 === b) {
                didFindChild = true;
                b = parentB;
                a = parentA;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) throw Error(formatProdErrorMessage(189));
          }
        }
        if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
      }
      if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiberImpl(node) {
      var tag = node.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
      for (node = node.child; null !== node; ) {
        tag = findCurrentHostFiberImpl(node);
        if (null !== tag) return tag;
        node = node.sibling;
      }
      return null;
    }
    var assign = Object.assign;
    var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element");
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    Symbol.for("react.scope");
    var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
    Symbol.for("react.legacy_hidden");
    Symbol.for("react.tracing_marker");
    var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
    Symbol.for("react.view_transition");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
    function getComponentNameFromType(type) {
      if (null == type) return null;
      if ("function" === typeof type)
        return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
      if ("string" === typeof type) return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
        case REACT_ACTIVITY_TYPE:
          return "Activity";
      }
      if ("object" === typeof type)
        switch (type.$$typeof) {
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_CONTEXT_TYPE:
            return type.displayName || "Context";
          case REACT_CONSUMER_TYPE:
            return (type._context.displayName || "Context") + ".Consumer";
          case REACT_FORWARD_REF_TYPE:
            var innerType = type.render;
            type = type.displayName;
            type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
            return type;
          case REACT_MEMO_TYPE:
            return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE:
            innerType = type._payload;
            type = type._init;
            try {
              return getComponentNameFromType(type(innerType));
            } catch (x) {
            }
        }
      return null;
    }
    var isArrayImpl = Array.isArray;
    var ReactSharedInternals = React25.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    var ReactDOMSharedInternals = ReactDOM5.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    var sharedNotPendingObject = {
      pending: false,
      data: null,
      method: null,
      action: null
    };
    var valueStack = [];
    var index2 = -1;
    function createCursor(defaultValue) {
      return { current: defaultValue };
    }
    function pop(cursor) {
      0 > index2 || (cursor.current = valueStack[index2], valueStack[index2] = null, index2--);
    }
    function push(cursor, value) {
      index2++;
      valueStack[index2] = cursor.current;
      cursor.current = value;
    }
    var contextStackCursor = createCursor(null);
    var contextFiberStackCursor = createCursor(null);
    var rootInstanceStackCursor = createCursor(null);
    var hostTransitionProviderCursor = createCursor(null);
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance);
      push(contextFiberStackCursor, fiber);
      push(contextStackCursor, null);
      switch (nextRootInstance.nodeType) {
        case 9:
        case 11:
          fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
          break;
        default:
          if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
            nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
          else
            switch (fiber) {
              case "svg":
                fiber = 1;
                break;
              case "math":
                fiber = 2;
                break;
              default:
                fiber = 0;
            }
      }
      pop(contextStackCursor);
      push(contextStackCursor, fiber);
    }
    function popHostContainer() {
      pop(contextStackCursor);
      pop(contextFiberStackCursor);
      pop(rootInstanceStackCursor);
    }
    function pushHostContext(fiber) {
      null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
      var context = contextStackCursor.current;
      var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
      context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
      hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
    }
    var prefix;
    var suffix;
    function describeBuiltInComponentFrame(name) {
      if (void 0 === prefix)
        try {
          throw Error();
        } catch (x) {
          var match = x.stack.trim().match(/\n( *(at )?)/);
          prefix = match && match[1] || "";
          suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
        }
      return "\n" + prefix + name + suffix;
    }
    var reentry = false;
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry) return "";
      reentry = true;
      var previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var RunInRootFrame = {
          DetermineComponentFrameRoot: function() {
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if ("object" === typeof Reflect && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    var control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x$1) {
                    control = x$1;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x$2) {
                  control = x$2;
                }
                (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
                });
              }
            } catch (sample) {
              if (sample && control && "string" === typeof sample.stack)
                return [sample.stack, control.stack];
            }
            return [null, null];
          }
        };
        RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var namePropDescriptor = Object.getOwnPropertyDescriptor(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name"
        );
        namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
          RunInRootFrame.DetermineComponentFrameRoot,
          "name",
          { value: "DetermineComponentFrameRoot" }
        );
        var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
        if (sampleStack && controlStack) {
          var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
          for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
            RunInRootFrame++;
          for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
            "DetermineComponentFrameRoot"
          ); )
            namePropDescriptor++;
          if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
            for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
              namePropDescriptor--;
          for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
            if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
              if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                do
                  if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                    var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                    fn.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn.displayName));
                    return frame;
                  }
                while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
              }
              break;
            }
        }
      } finally {
        reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
      }
      return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
    }
    function describeFiber(fiber, childFiber) {
      switch (fiber.tag) {
        case 26:
        case 27:
        case 5:
          return describeBuiltInComponentFrame(fiber.type);
        case 16:
          return describeBuiltInComponentFrame("Lazy");
        case 13:
          return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
        case 19:
          return describeBuiltInComponentFrame("SuspenseList");
        case 0:
        case 15:
          return describeNativeComponentFrame(fiber.type, false);
        case 11:
          return describeNativeComponentFrame(fiber.type.render, false);
        case 1:
          return describeNativeComponentFrame(fiber.type, true);
        case 31:
          return describeBuiltInComponentFrame("Activity");
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress2) {
      try {
        var info = "", previous = null;
        do
          info += describeFiber(workInProgress2, previous), previous = workInProgress2, workInProgress2 = workInProgress2.return;
        while (workInProgress2);
        return info;
      } catch (x) {
        return "\nError generating stack: " + x.message + "\n" + x.stack;
      }
    }
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var scheduleCallback$3 = Scheduler.unstable_scheduleCallback;
    var cancelCallback$1 = Scheduler.unstable_cancelCallback;
    var shouldYield = Scheduler.unstable_shouldYield;
    var requestPaint = Scheduler.unstable_requestPaint;
    var now = Scheduler.unstable_now;
    var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
    var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
    var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
    var NormalPriority$1 = Scheduler.unstable_NormalPriority;
    var LowPriority = Scheduler.unstable_LowPriority;
    var IdlePriority = Scheduler.unstable_IdlePriority;
    var log$1 = Scheduler.log;
    var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
    var rendererID = null;
    var injectedHook = null;
    function setIsStrictModeForDevtools(newIsStrictMode) {
      "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
      if (injectedHook && "function" === typeof injectedHook.setStrictMode)
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
        }
    }
    var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
    var log = Math.log;
    var LN2 = Math.LN2;
    function clz32Fallback(x) {
      x >>>= 0;
      return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
    }
    var nextTransitionUpdateLane = 256;
    var nextTransitionDeferredLane = 262144;
    var nextRetryLane = 4194304;
    function getHighestPriorityLanes(lanes) {
      var pendingSyncLanes = lanes & 42;
      if (0 !== pendingSyncLanes) return pendingSyncLanes;
      switch (lanes & -lanes) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
          return lanes & 261888;
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return lanes & 3932160;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return lanes & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return lanes;
      }
    }
    function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
      var pendingLanes = root2.pendingLanes;
      if (0 === pendingLanes) return 0;
      var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
      root2 = root2.warmLanes;
      var nonIdlePendingLanes = pendingLanes & 134217727;
      0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
      return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
    }
    function checkIfRootIsPrerendering(root2, renderLanes2) {
      return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return currentTime + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return currentTime + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      nextRetryLane <<= 1;
      0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
      return lane;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated$1(root2, updateLane) {
      root2.pendingLanes |= updateLane;
      268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
    }
    function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
      var previouslyPendingLanes = root2.pendingLanes;
      root2.pendingLanes = remainingLanes;
      root2.suspendedLanes = 0;
      root2.pingedLanes = 0;
      root2.warmLanes = 0;
      root2.expiredLanes &= remainingLanes;
      root2.entangledLanes &= remainingLanes;
      root2.errorRecoveryDisabledLanes &= remainingLanes;
      root2.shellSuspendCounter = 0;
      var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
      for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
        var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
        entanglements[index$7] = 0;
        expirationTimes[index$7] = -1;
        var hiddenUpdatesForLane = hiddenUpdates[index$7];
        if (null !== hiddenUpdatesForLane)
          for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
            var update = hiddenUpdatesForLane[index$7];
            null !== update && (update.lane &= -536870913);
          }
        remainingLanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
      0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
    }
    function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
      root2.pendingLanes |= spawnedLane;
      root2.suspendedLanes &= ~spawnedLane;
      var spawnedLaneIndex = 31 - clz32(spawnedLane);
      root2.entangledLanes |= spawnedLane;
      root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
    }
    function markRootEntangled(root2, entangledLanes) {
      var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
      for (root2 = root2.entanglements; rootEntangledLanes; ) {
        var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
        lane & entangledLanes | root2[index$8] & entangledLanes && (root2[index$8] |= entangledLanes);
        rootEntangledLanes &= ~lane;
      }
    }
    function getBumpedLaneForHydration(root2, renderLanes2) {
      var renderLane = renderLanes2 & -renderLanes2;
      renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
      return 0 !== (renderLane & (root2.suspendedLanes | renderLanes2)) ? 0 : renderLane;
    }
    function getBumpedLaneForHydrationByLane(lane) {
      switch (lane) {
        case 2:
          lane = 1;
          break;
        case 8:
          lane = 4;
          break;
        case 32:
          lane = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          lane = 128;
          break;
        case 268435456:
          lane = 134217728;
          break;
        default:
          lane = 0;
      }
      return lane;
    }
    function lanesToEventPriority(lanes) {
      lanes &= -lanes;
      return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
    }
    function resolveUpdatePriority() {
      var updatePriority = ReactDOMSharedInternals.p;
      if (0 !== updatePriority) return updatePriority;
      updatePriority = window.event;
      return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
    }
    function runWithPriority(priority, fn) {
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        return ReactDOMSharedInternals.p = priority, fn();
      } finally {
        ReactDOMSharedInternals.p = previousPriority;
      }
    }
    var randomKey = Math.random().toString(36).slice(2);
    var internalInstanceKey = "__reactFiber$" + randomKey;
    var internalPropsKey = "__reactProps$" + randomKey;
    var internalContainerInstanceKey = "__reactContainer$" + randomKey;
    var internalEventHandlersKey = "__reactEvents$" + randomKey;
    var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
    var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
    var internalRootNodeResourcesKey = "__reactResources$" + randomKey;
    var internalHoistableMarker = "__reactMarker$" + randomKey;
    function detachDeletedInstance(node) {
      delete node[internalInstanceKey];
      delete node[internalPropsKey];
      delete node[internalEventHandlersKey];
      delete node[internalEventHandlerListenersKey];
      delete node[internalEventHandlesSetKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst) return targetInst;
      for (var parentNode = targetNode.parentNode; parentNode; ) {
        if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
          parentNode = targetInst.alternate;
          if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
            for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
              if (parentNode = targetNode[internalInstanceKey]) return parentNode;
              targetNode = getParentHydrationBoundary(targetNode);
            }
          return targetInst;
        }
        targetNode = parentNode;
        parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node) {
      if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
        var tag = node.tag;
        if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
          return node;
      }
      return null;
    }
    function getNodeFromInstance(inst) {
      var tag = inst.tag;
      if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
      throw Error(formatProdErrorMessage(33));
    }
    function getResourcesFromRoot(root2) {
      var resources = root2[internalRootNodeResourcesKey];
      resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
      return resources;
    }
    function markNodeAsHoistable(node) {
      node[internalHoistableMarker] = true;
    }
    var allNativeEvents = /* @__PURE__ */ new Set();
    var registrationNameDependencies = {};
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies);
      registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] = dependencies;
      for (registrationName = 0; registrationName < dependencies.length; registrationName++)
        allNativeEvents.add(dependencies[registrationName]);
    }
    var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
      "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
    );
    var illegalAttributeNameCache = {};
    var validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
        return true;
      if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
      if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
        return validatedAttributeNameCache[attributeName] = true;
      illegalAttributeNameCache[attributeName] = true;
      return false;
    }
    function setValueForAttribute(node, name, value) {
      if (isAttributeNameSafe(name))
        if (null === value) node.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
              node.removeAttribute(name);
              return;
            case "boolean":
              var prefix$10 = name.toLowerCase().slice(0, 5);
              if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
                node.removeAttribute(name);
                return;
              }
          }
          node.setAttribute(name, "" + value);
        }
    }
    function setValueForKnownAttribute(node, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        node.setAttribute(name, "" + value);
      }
    }
    function setValueForNamespacedAttribute(node, namespace, name, value) {
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            node.removeAttribute(name);
            return;
        }
        node.setAttributeNS(namespace, name, "" + value);
      }
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return value;
        default:
          return "";
      }
    }
    function isCheckable(elem) {
      var type = elem.type;
      return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
    }
    function trackValueOnNode(node, valueField, currentValue) {
      var descriptor = Object.getOwnPropertyDescriptor(
        node.constructor.prototype,
        valueField
      );
      if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
        var get = descriptor.get, set = descriptor.set;
        Object.defineProperty(node, valueField, {
          configurable: true,
          get: function() {
            return get.call(this);
          },
          set: function(value) {
            currentValue = "" + value;
            set.call(this, value);
          }
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        return {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value) {
            currentValue = "" + value;
          },
          stopTracking: function() {
            node._valueTracker = null;
            delete node[valueField];
          }
        };
      }
    }
    function track(node) {
      if (!node._valueTracker) {
        var valueField = isCheckable(node) ? "checked" : "value";
        node._valueTracker = trackValueOnNode(
          node,
          valueField,
          "" + node[valueField]
        );
      }
    }
    function updateValueIfChanged(node) {
      if (!node) return false;
      var tracker = node._valueTracker;
      if (!tracker) return true;
      var lastValue = tracker.getValue();
      var value = "";
      node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
      node = value;
      return node !== lastValue ? (tracker.setValue(node), true) : false;
    }
    function getActiveElement(doc) {
      doc = doc || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof doc) return null;
      try {
        return doc.activeElement || doc.body;
      } catch (e) {
        return doc.body;
      }
    }
    var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
    function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
      return value.replace(
        escapeSelectorAttributeValueInsideDoubleQuotesRegex,
        function(ch) {
          return "\\" + ch.charCodeAt(0).toString(16) + " ";
        }
      );
    }
    function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
      element.name = "";
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
      if (null != value)
        if ("number" === type) {
          if (0 === value && "" === element.value || element.value != value)
            element.value = "" + getToStringValue(value);
        } else
          element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
      else
        "submit" !== type && "reset" !== type || element.removeAttribute("value");
      null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
      null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
      null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
    }
    function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
      null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
      if (null != value || null != defaultValue) {
        if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
          track(element);
          return;
        }
        defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
        value = null != value ? "" + getToStringValue(value) : defaultValue;
        isHydrating2 || value === element.value || (element.value = value);
        element.defaultValue = value;
      }
      checked = null != checked ? checked : defaultChecked;
      checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
      element.checked = isHydrating2 ? element.checked : !!checked;
      element.defaultChecked = !!checked;
      null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
      track(element);
    }
    function setDefaultValue(node, type, value) {
      "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
    }
    function updateOptions(node, multiple, propValue, setDefaultSelected) {
      node = node.options;
      if (multiple) {
        multiple = {};
        for (var i = 0; i < propValue.length; i++)
          multiple["$" + propValue[i]] = true;
        for (propValue = 0; propValue < node.length; propValue++)
          i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
      } else {
        propValue = "" + getToStringValue(propValue);
        multiple = null;
        for (i = 0; i < node.length; i++) {
          if (node[i].value === propValue) {
            node[i].selected = true;
            setDefaultSelected && (node[i].defaultSelected = true);
            return;
          }
          null !== multiple || node[i].disabled || (multiple = node[i]);
        }
        null !== multiple && (multiple.selected = true);
      }
    }
    function updateTextarea(element, value, defaultValue) {
      if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
        element.defaultValue !== value && (element.defaultValue = value);
        return;
      }
      element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
    }
    function initTextarea(element, value, defaultValue, children) {
      if (null == value) {
        if (null != children) {
          if (null != defaultValue) throw Error(formatProdErrorMessage(92));
          if (isArrayImpl(children)) {
            if (1 < children.length) throw Error(formatProdErrorMessage(93));
            children = children[0];
          }
          defaultValue = children;
        }
        null == defaultValue && (defaultValue = "");
        value = defaultValue;
      }
      defaultValue = getToStringValue(value);
      element.defaultValue = defaultValue;
      children = element.textContent;
      children === defaultValue && "" !== children && null !== children && (element.value = children);
      track(element);
    }
    function setTextContent(node, text) {
      if (text) {
        var firstChild = node.firstChild;
        if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node.textContent = text;
    }
    var unitlessNumbers = new Set(
      "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
        " "
      )
    );
    function setValueForStyle(style2, styleName, value) {
      var isCustomProperty = 0 === styleName.indexOf("--");
      null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
    }
    function setValueForStyles(node, styles, prevStyles) {
      if (null != styles && "object" !== typeof styles)
        throw Error(formatProdErrorMessage(62));
      node = node.style;
      if (null != prevStyles) {
        for (var styleName in prevStyles)
          !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
        for (var styleName$16 in styles)
          styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
      } else
        for (var styleName$17 in styles)
          styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
    }
    function isCustomElement(tagName) {
      if (-1 === tagName.indexOf("-")) return false;
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var aliases = /* @__PURE__ */ new Map([
      ["acceptCharset", "accept-charset"],
      ["htmlFor", "for"],
      ["httpEquiv", "http-equiv"],
      ["crossOrigin", "crossorigin"],
      ["accentHeight", "accent-height"],
      ["alignmentBaseline", "alignment-baseline"],
      ["arabicForm", "arabic-form"],
      ["baselineShift", "baseline-shift"],
      ["capHeight", "cap-height"],
      ["clipPath", "clip-path"],
      ["clipRule", "clip-rule"],
      ["colorInterpolation", "color-interpolation"],
      ["colorInterpolationFilters", "color-interpolation-filters"],
      ["colorProfile", "color-profile"],
      ["colorRendering", "color-rendering"],
      ["dominantBaseline", "dominant-baseline"],
      ["enableBackground", "enable-background"],
      ["fillOpacity", "fill-opacity"],
      ["fillRule", "fill-rule"],
      ["floodColor", "flood-color"],
      ["floodOpacity", "flood-opacity"],
      ["fontFamily", "font-family"],
      ["fontSize", "font-size"],
      ["fontSizeAdjust", "font-size-adjust"],
      ["fontStretch", "font-stretch"],
      ["fontStyle", "font-style"],
      ["fontVariant", "font-variant"],
      ["fontWeight", "font-weight"],
      ["glyphName", "glyph-name"],
      ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
      ["glyphOrientationVertical", "glyph-orientation-vertical"],
      ["horizAdvX", "horiz-adv-x"],
      ["horizOriginX", "horiz-origin-x"],
      ["imageRendering", "image-rendering"],
      ["letterSpacing", "letter-spacing"],
      ["lightingColor", "lighting-color"],
      ["markerEnd", "marker-end"],
      ["markerMid", "marker-mid"],
      ["markerStart", "marker-start"],
      ["overlinePosition", "overline-position"],
      ["overlineThickness", "overline-thickness"],
      ["paintOrder", "paint-order"],
      ["panose-1", "panose-1"],
      ["pointerEvents", "pointer-events"],
      ["renderingIntent", "rendering-intent"],
      ["shapeRendering", "shape-rendering"],
      ["stopColor", "stop-color"],
      ["stopOpacity", "stop-opacity"],
      ["strikethroughPosition", "strikethrough-position"],
      ["strikethroughThickness", "strikethrough-thickness"],
      ["strokeDasharray", "stroke-dasharray"],
      ["strokeDashoffset", "stroke-dashoffset"],
      ["strokeLinecap", "stroke-linecap"],
      ["strokeLinejoin", "stroke-linejoin"],
      ["strokeMiterlimit", "stroke-miterlimit"],
      ["strokeOpacity", "stroke-opacity"],
      ["strokeWidth", "stroke-width"],
      ["textAnchor", "text-anchor"],
      ["textDecoration", "text-decoration"],
      ["textRendering", "text-rendering"],
      ["transformOrigin", "transform-origin"],
      ["underlinePosition", "underline-position"],
      ["underlineThickness", "underline-thickness"],
      ["unicodeBidi", "unicode-bidi"],
      ["unicodeRange", "unicode-range"],
      ["unitsPerEm", "units-per-em"],
      ["vAlphabetic", "v-alphabetic"],
      ["vHanging", "v-hanging"],
      ["vIdeographic", "v-ideographic"],
      ["vMathematical", "v-mathematical"],
      ["vectorEffect", "vector-effect"],
      ["vertAdvY", "vert-adv-y"],
      ["vertOriginX", "vert-origin-x"],
      ["vertOriginY", "vert-origin-y"],
      ["wordSpacing", "word-spacing"],
      ["writingMode", "writing-mode"],
      ["xmlnsXlink", "xmlns:xlink"],
      ["xHeight", "x-height"]
    ]);
    var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function sanitizeURL(url) {
      return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
    }
    function noop$1() {
    }
    var currentReplayingEvent = null;
    function getEventTarget(nativeEvent) {
      nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
      nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
      return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
    }
    var restoreTarget = null;
    var restoreQueue = null;
    function restoreStateOfTarget(target) {
      var internalInstance = getInstanceFromNode(target);
      if (internalInstance && (target = internalInstance.stateNode)) {
        var props = target[internalPropsKey] || null;
        a: switch (target = internalInstance.stateNode, internalInstance.type) {
          case "input":
            updateInput(
              target,
              props.value,
              props.defaultValue,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name
            );
            internalInstance = props.name;
            if ("radio" === props.type && null != internalInstance) {
              for (props = target; props.parentNode; ) props = props.parentNode;
              props = props.querySelectorAll(
                'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                  "" + internalInstance
                ) + '"][type="radio"]'
              );
              for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                var otherNode = props[internalInstance];
                if (otherNode !== target && otherNode.form === target.form) {
                  var otherProps = otherNode[internalPropsKey] || null;
                  if (!otherProps) throw Error(formatProdErrorMessage(90));
                  updateInput(
                    otherNode,
                    otherProps.value,
                    otherProps.defaultValue,
                    otherProps.defaultValue,
                    otherProps.checked,
                    otherProps.defaultChecked,
                    otherProps.type,
                    otherProps.name
                  );
                }
              }
              for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
            }
            break a;
          case "textarea":
            updateTextarea(target, props.value, props.defaultValue);
            break a;
          case "select":
            internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
        }
      }
    }
    var isInsideEventHandler = false;
    function batchedUpdates$1(fn, a, b) {
      if (isInsideEventHandler) return fn(a, b);
      isInsideEventHandler = true;
      try {
        var JSCompiler_inline_result = fn(a);
        return JSCompiler_inline_result;
      } finally {
        if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
          if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
            for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
        }
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (null === stateNode) return null;
      var props = stateNode[internalPropsKey] || null;
      if (null === props) return null;
      stateNode = props[registrationName];
      a: switch (registrationName) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
          inst = !props;
          break a;
        default:
          inst = false;
      }
      if (inst) return null;
      if (stateNode && "function" !== typeof stateNode)
        throw Error(
          formatProdErrorMessage(231, registrationName, typeof stateNode)
        );
      return stateNode;
    }
    var canUseDOM3 = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
    var passiveBrowserEventsSupported = false;
    if (canUseDOM3)
      try {
        options = {};
        Object.defineProperty(options, "passive", {
          get: function() {
            passiveBrowserEventsSupported = true;
          }
        });
        window.addEventListener("test", options, options);
        window.removeEventListener("test", options, options);
      } catch (e) {
        passiveBrowserEventsSupported = false;
      }
    var options;
    var root = null;
    var startText = null;
    var fallbackText = null;
    function getData() {
      if (fallbackText) return fallbackText;
      var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
      for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
      return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
    }
    function getEventCharCode(nativeEvent) {
      var keyCode = nativeEvent.keyCode;
      "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
      10 === nativeEvent && (nativeEvent = 13);
      return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
    }
    function functionThatReturnsTrue() {
      return true;
    }
    function functionThatReturnsFalse() {
      return false;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        this._reactName = reactName;
        this._targetInst = targetInst;
        this.type = reactEventType;
        this.nativeEvent = nativeEvent;
        this.target = nativeEventTarget;
        this.currentTarget = null;
        for (var propName in Interface)
          Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
        this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
        this.isPropagationStopped = functionThatReturnsFalse;
        return this;
      }
      assign(SyntheticBaseEvent.prototype, {
        preventDefault: function() {
          this.defaultPrevented = true;
          var event = this.nativeEvent;
          event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
        },
        stopPropagation: function() {
          var event = this.nativeEvent;
          event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
        },
        persist: function() {
        },
        isPersistent: functionThatReturnsTrue
      });
      return SyntheticBaseEvent;
    }
    var EventInterface = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    };
    var SyntheticEvent = createSyntheticEvent(EventInterface);
    var UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 });
    var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
    var lastMovementX;
    var lastMovementY;
    var lastMouseEvent;
    var MouseEventInterface = assign({}, UIEventInterface, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: getEventModifierState,
      button: 0,
      buttons: 0,
      relatedTarget: function(event) {
        return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
      },
      movementX: function(event) {
        if ("movementX" in event) return event.movementX;
        event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
        return lastMovementX;
      },
      movementY: function(event) {
        return "movementY" in event ? event.movementY : lastMovementY;
      }
    });
    var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
    var DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 });
    var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
    var FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 });
    var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
    var AnimationEventInterface = assign({}, EventInterface, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    });
    var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
    var ClipboardEventInterface = assign({}, EventInterface, {
      clipboardData: function(event) {
        return "clipboardData" in event ? event.clipboardData : window.clipboardData;
      }
    });
    var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
    var CompositionEventInterface = assign({}, EventInterface, { data: 0 });
    var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
    var normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    };
    var translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    var modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function modifierStateGetter(keyArg) {
      var nativeEvent = this.nativeEvent;
      return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
    }
    function getEventModifierState() {
      return modifierStateGetter;
    }
    var KeyboardEventInterface = assign({}, UIEventInterface, {
      key: function(nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if ("Unidentified" !== key) return key;
        }
        return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: getEventModifierState,
      charCode: function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : 0;
      },
      keyCode: function(event) {
        return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      },
      which: function(event) {
        return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
      }
    });
    var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
    var PointerEventInterface = assign({}, MouseEventInterface, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    });
    var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
    var TouchEventInterface = assign({}, UIEventInterface, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: getEventModifierState
    });
    var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
    var TransitionEventInterface = assign({}, EventInterface, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    });
    var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
    var WheelEventInterface = assign({}, MouseEventInterface, {
      deltaX: function(event) {
        return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
      },
      deltaY: function(event) {
        return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    });
    var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
    var ToggleEventInterface = assign({}, EventInterface, {
      newState: 0,
      oldState: 0
    });
    var SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface);
    var END_KEYCODES = [9, 13, 27, 32];
    var canUseCompositionEvent = canUseDOM3 && "CompositionEvent" in window;
    var documentMode = null;
    canUseDOM3 && "documentMode" in document && (documentMode = document.documentMode);
    var canUseTextInputEvent = canUseDOM3 && "TextEvent" in window && !documentMode;
    var useFallbackCompositionData = canUseDOM3 && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode);
    var SPACEBAR_CHAR = String.fromCharCode(32);
    var hasSpaceKeypress = false;
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
        case "keydown":
          return 229 !== nativeEvent.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      nativeEvent = nativeEvent.detail;
      return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
    }
    var isComposing = false;
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          if (32 !== nativeEvent.which) return null;
          hasSpaceKeypress = true;
          return SPACEBAR_CHAR;
        case "textInput":
          return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing)
        return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
            if (nativeEvent.char && 1 < nativeEvent.char.length)
              return nativeEvent.char;
            if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
        default:
          return null;
      }
    }
    var supportedInputTypes = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true
    };
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
      restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
      inst = accumulateTwoPhaseListeners(inst, "onChange");
      0 < inst.length && (nativeEvent = new SyntheticEvent(
        "onChange",
        "change",
        null,
        nativeEvent,
        target
      ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
    }
    var activeElement$1 = null;
    var activeElementInst$1 = null;
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode)) return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if ("change" === domEventName) return targetInst;
    }
    var isInputEventSupported = false;
    if (canUseDOM3) {
      if (canUseDOM3) {
        isSupported$jscomp$inline_427 = "oninput" in document;
        if (!isSupported$jscomp$inline_427) {
          element$jscomp$inline_428 = document.createElement("div");
          element$jscomp$inline_428.setAttribute("oninput", "return;");
          isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
        }
        JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
      } else JSCompiler_inline_result$jscomp$286 = false;
      isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
    }
    var JSCompiler_inline_result$jscomp$286;
    var isSupported$jscomp$inline_427;
    var element$jscomp$inline_428;
    function stopWatchingForValueChange() {
      activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
    }
    function handlePropertyChange(nativeEvent) {
      if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(
          dispatchQueue,
          activeElementInst$1,
          nativeEvent,
          getEventTarget(nativeEvent)
        );
        batchedUpdates$1(runEventInBatch, dispatchQueue);
      }
    }
    function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
      "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName) {
      if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
        return getInstIfValueChanged(activeElementInst$1);
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if ("click" === domEventName) return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if ("input" === domEventName || "change" === domEventName)
        return getInstIfValueChanged(targetInst);
    }
    function is(x, y) {
      return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
    }
    var objectIs = "function" === typeof Object.is ? Object.is : is;
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB)) return true;
      if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
        return false;
      var keysA = Object.keys(objA), keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) return false;
      for (keysB = 0; keysB < keysA.length; keysB++) {
        var currentKey = keysA[keysB];
        if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
          return false;
      }
      return true;
    }
    function getLeafNode(node) {
      for (; node && node.firstChild; ) node = node.firstChild;
      return node;
    }
    function getNodeForCharacterOffset(root2, offset4) {
      var node = getLeafNode(root2);
      root2 = 0;
      for (var nodeEnd; node; ) {
        if (3 === node.nodeType) {
          nodeEnd = root2 + node.textContent.length;
          if (root2 <= offset4 && nodeEnd >= offset4)
            return { node, offset: offset4 - root2 };
          root2 = nodeEnd;
        }
        a: {
          for (; node; ) {
            if (node.nextSibling) {
              node = node.nextSibling;
              break a;
            }
            node = node.parentNode;
          }
          node = void 0;
        }
        node = getLeafNode(node);
      }
    }
    function containsNode(outerNode, innerNode) {
      return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
    }
    function getActiveElementDeep(containerInfo) {
      containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
      for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
        try {
          var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
        } catch (err) {
          JSCompiler_inline_result = false;
        }
        if (JSCompiler_inline_result) containerInfo = element.contentWindow;
        else break;
        element = getActiveElement(containerInfo.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
    }
    var skipSelectionChangeEvent = canUseDOM3 && "documentMode" in document && 11 >= document.documentMode;
    var activeElement = null;
    var activeElementInst = null;
    var lastSelection = null;
    var mouseDown = false;
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
      var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
      mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
        anchorNode: doc.anchorNode,
        anchorOffset: doc.anchorOffset,
        focusNode: doc.focusNode,
        focusOffset: doc.focusOffset
      }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
        "onSelect",
        "select",
        null,
        nativeEvent,
        nativeEventTarget
      ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
    }
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit" + styleProp] = "webkit" + eventName;
      prefixes["Moz" + styleProp] = "moz" + eventName;
      return prefixes;
    }
    var vendorPrefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap("Animation", "AnimationIteration"),
      animationstart: makePrefixMap("Animation", "AnimationStart"),
      transitionrun: makePrefixMap("Transition", "TransitionRun"),
      transitionstart: makePrefixMap("Transition", "TransitionStart"),
      transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    };
    var prefixedEventNames = {};
    var style = {};
    canUseDOM3 && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName]) return eventName;
      var prefixMap = vendorPrefixes[eventName], styleProp;
      for (styleProp in prefixMap)
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
          return prefixedEventNames[eventName] = prefixMap[styleProp];
      return eventName;
    }
    var ANIMATION_END = getVendorPrefixedEventName("animationend");
    var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
    var ANIMATION_START = getVendorPrefixedEventName("animationstart");
    var TRANSITION_RUN = getVendorPrefixedEventName("transitionrun");
    var TRANSITION_START = getVendorPrefixedEventName("transitionstart");
    var TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel");
    var TRANSITION_END = getVendorPrefixedEventName("transitionend");
    var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
    var simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
    simpleEventPluginEvents.push("scrollEnd");
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName);
      registerTwoPhaseEvent(reactName, [domEventName]);
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event)) return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    };
    var concurrentQueues = [];
    var concurrentQueuesIndex = 0;
    var concurrentlyUpdatedLanes = 0;
    function finishQueueingConcurrentUpdates() {
      for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
        var fiber = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var queue = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var update = concurrentQueues[i];
        concurrentQueues[i++] = null;
        var lane = concurrentQueues[i];
        concurrentQueues[i++] = null;
        if (null !== queue && null !== update) {
          var pending = queue.pending;
          null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
          queue.pending = update;
        }
        0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
      }
    }
    function enqueueUpdate$1(fiber, queue, update, lane) {
      concurrentQueues[concurrentQueuesIndex++] = fiber;
      concurrentQueues[concurrentQueuesIndex++] = queue;
      concurrentQueues[concurrentQueuesIndex++] = update;
      concurrentQueues[concurrentQueuesIndex++] = lane;
      concurrentlyUpdatedLanes |= lane;
      fiber.lanes |= lane;
      fiber = fiber.alternate;
      null !== fiber && (fiber.lanes |= lane);
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      enqueueUpdate$1(fiber, queue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      enqueueUpdate$1(fiber, null, null, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
      sourceFiber.lanes |= lane;
      var alternate = sourceFiber.alternate;
      null !== alternate && (alternate.lanes |= lane);
      for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
        parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
      return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
    }
    function getRootForUpdatedFiber(sourceFiber) {
      if (50 < nestedUpdateCount)
        throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
      for (var parent = sourceFiber.return; null !== parent; )
        sourceFiber = parent, parent = sourceFiber.return;
      return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
    }
    var emptyContextObject = {};
    function FiberNode(tag, pendingProps, key, mode) {
      this.tag = tag;
      this.key = key;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.refCleanup = this.ref = null;
      this.pendingProps = pendingProps;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = mode;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function createFiberImplClass(tag, pendingProps, key, mode) {
      return new FiberNode(tag, pendingProps, key, mode);
    }
    function shouldConstruct(Component) {
      Component = Component.prototype;
      return !(!Component || !Component.isReactComponent);
    }
    function createWorkInProgress(current, pendingProps) {
      var workInProgress2 = current.alternate;
      null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
        current.tag,
        pendingProps,
        current.key,
        current.mode
      ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
      workInProgress2.flags = current.flags & 65011712;
      workInProgress2.childLanes = current.childLanes;
      workInProgress2.lanes = current.lanes;
      workInProgress2.child = current.child;
      workInProgress2.memoizedProps = current.memoizedProps;
      workInProgress2.memoizedState = current.memoizedState;
      workInProgress2.updateQueue = current.updateQueue;
      pendingProps = current.dependencies;
      workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
      workInProgress2.sibling = current.sibling;
      workInProgress2.index = current.index;
      workInProgress2.ref = current.ref;
      workInProgress2.refCleanup = current.refCleanup;
      return workInProgress2;
    }
    function resetWorkInProgress(workInProgress2, renderLanes2) {
      workInProgress2.flags &= 65011714;
      var current = workInProgress2.alternate;
      null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
        lanes: renderLanes2.lanes,
        firstContext: renderLanes2.firstContext
      });
      return workInProgress2;
    }
    function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
      var fiberTag = 0;
      owner = type;
      if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
      else if ("string" === typeof type)
        fiberTag = isHostHoistableType(
          type,
          pendingProps,
          contextStackCursor.current
        ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
      else
        a: switch (type) {
          case REACT_ACTIVITY_TYPE:
            return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
          case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(pendingProps.children, mode, lanes, key);
          case REACT_STRICT_MODE_TYPE:
            fiberTag = 8;
            mode |= 24;
            break;
          case REACT_PROFILER_TYPE:
            return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
          case REACT_SUSPENSE_TYPE:
            return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
          case REACT_SUSPENSE_LIST_TYPE:
            return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
          default:
            if ("object" === typeof type && null !== type)
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  fiberTag = 10;
                  break a;
                case REACT_CONSUMER_TYPE:
                  fiberTag = 9;
                  break a;
                case REACT_FORWARD_REF_TYPE:
                  fiberTag = 11;
                  break a;
                case REACT_MEMO_TYPE:
                  fiberTag = 14;
                  break a;
                case REACT_LAZY_TYPE:
                  fiberTag = 16;
                  owner = null;
                  break a;
              }
            fiberTag = 29;
            pendingProps = Error(
              formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
            );
            owner = null;
        }
      key = createFiberImplClass(fiberTag, pendingProps, key, mode);
      key.elementType = type;
      key.type = owner;
      key.lanes = lanes;
      return key;
    }
    function createFiberFromFragment(elements, mode, lanes, key) {
      elements = createFiberImplClass(7, elements, key, mode);
      elements.lanes = lanes;
      return elements;
    }
    function createFiberFromText(content, mode, lanes) {
      content = createFiberImplClass(6, content, null, mode);
      content.lanes = lanes;
      return content;
    }
    function createFiberFromDehydratedFragment(dehydratedNode) {
      var fiber = createFiberImplClass(18, null, null, 0);
      fiber.stateNode = dehydratedNode;
      return fiber;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      mode = createFiberImplClass(
        4,
        null !== portal.children ? portal.children : [],
        portal.key,
        mode
      );
      mode.lanes = lanes;
      mode.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        implementation: portal.implementation
      };
      return mode;
    }
    var CapturedStacks = /* @__PURE__ */ new WeakMap();
    function createCapturedValueAtFiber(value, source) {
      if ("object" === typeof value && null !== value) {
        var existing = CapturedStacks.get(value);
        if (void 0 !== existing) return existing;
        source = {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
        CapturedStacks.set(value, source);
        return source;
      }
      return {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source)
      };
    }
    var forkStack = [];
    var forkStackIndex = 0;
    var treeForkProvider = null;
    var treeForkCount = 0;
    var idStack = [];
    var idStackIndex = 0;
    var treeContextProvider = null;
    var treeContextId = 1;
    var treeContextOverflow = "";
    function pushTreeFork(workInProgress2, totalChildren) {
      forkStack[forkStackIndex++] = treeForkCount;
      forkStack[forkStackIndex++] = treeForkProvider;
      treeForkProvider = workInProgress2;
      treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress2, totalChildren, index3) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextProvider = workInProgress2;
      var baseIdWithLeadingBit = treeContextId;
      workInProgress2 = treeContextOverflow;
      var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
      baseIdWithLeadingBit &= ~(1 << baseLength);
      index3 += 1;
      var length = 32 - clz32(totalChildren) + baseLength;
      if (30 < length) {
        var numberOfOverflowBits = baseLength - baseLength % 5;
        length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
        baseIdWithLeadingBit >>= numberOfOverflowBits;
        baseLength -= numberOfOverflowBits;
        treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index3 << baseLength | baseIdWithLeadingBit;
        treeContextOverflow = length + workInProgress2;
      } else
        treeContextId = 1 << length | index3 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
    }
    function pushMaterializedTreeId(workInProgress2) {
      null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
    }
    function popTreeContext(workInProgress2) {
      for (; workInProgress2 === treeForkProvider; )
        treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (; workInProgress2 === treeContextProvider; )
        treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
      idStack[idStackIndex++] = treeContextId;
      idStack[idStackIndex++] = treeContextOverflow;
      idStack[idStackIndex++] = treeContextProvider;
      treeContextId = suspendedContext.id;
      treeContextOverflow = suspendedContext.overflow;
      treeContextProvider = workInProgress2;
    }
    var hydrationParentFiber = null;
    var nextHydratableInstance = null;
    var isHydrating = false;
    var hydrationErrors = null;
    var rootOrSingletonContext = false;
    var HydrationMismatchException = Error(formatProdErrorMessage(519));
    function throwOnHydrationMismatch(fiber) {
      var error = Error(
        formatProdErrorMessage(
          418,
          1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML",
          ""
        )
      );
      queueHydrationError(createCapturedValueAtFiber(error, fiber));
      throw HydrationMismatchException;
    }
    function prepareToHydrateHostInstance(fiber) {
      var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
      instance[internalInstanceKey] = fiber;
      instance[internalPropsKey] = props;
      switch (type) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", instance);
          listenToNonDelegatedEvent("close", instance);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", instance);
          break;
        case "video":
        case "audio":
          for (type = 0; type < mediaEventTypes.length; type++)
            listenToNonDelegatedEvent(mediaEventTypes[type], instance);
          break;
        case "source":
          listenToNonDelegatedEvent("error", instance);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", instance);
          listenToNonDelegatedEvent("load", instance);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", instance);
          break;
        case "input":
          listenToNonDelegatedEvent("invalid", instance);
          initInput(
            instance,
            props.value,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name,
            true
          );
          break;
        case "select":
          listenToNonDelegatedEvent("invalid", instance);
          break;
        case "textarea":
          listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children);
      }
      type = props.children;
      "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$1), instance = true) : instance = false;
      instance || throwOnHydrationMismatch(fiber, true);
    }
    function popToNextHostParent(fiber) {
      for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
        switch (hydrationParentFiber.tag) {
          case 5:
          case 31:
          case 13:
            rootOrSingletonContext = false;
            return;
          case 27:
          case 3:
            rootOrSingletonContext = true;
            return;
          default:
            hydrationParentFiber = hydrationParentFiber.return;
        }
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber) return false;
      if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
      var tag = fiber.tag, JSCompiler_temp;
      if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
        if (JSCompiler_temp = 5 === tag)
          JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
        JSCompiler_temp = !JSCompiler_temp;
      }
      JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
      popToNextHostParent(fiber);
      if (13 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else if (31 === tag) {
        fiber = fiber.memoizedState;
        fiber = null !== fiber ? fiber.dehydrated : null;
        if (!fiber) throw Error(formatProdErrorMessage(317));
        nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
      } else
        27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
      return true;
    }
    function resetHydrationState() {
      nextHydratableInstance = hydrationParentFiber = null;
      isHydrating = false;
    }
    function upgradeHydrationErrorsToRecoverable() {
      var queuedErrors = hydrationErrors;
      null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
        workInProgressRootRecoverableErrors,
        queuedErrors
      ), hydrationErrors = null);
      return queuedErrors;
    }
    function queueHydrationError(error) {
      null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
    }
    var valueCursor = createCursor(null);
    var currentlyRenderingFiber$1 = null;
    var lastContextDependency = null;
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue);
      context._currentValue = nextValue;
    }
    function popProvider(context) {
      context._currentValue = valueCursor.current;
      pop(valueCursor);
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
      for (; null !== parent; ) {
        var alternate = parent.alternate;
        (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
        if (parent === propagationRoot) break;
        parent = parent.return;
      }
    }
    function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
      var fiber = workInProgress2.child;
      null !== fiber && (fiber.return = workInProgress2);
      for (; null !== fiber; ) {
        var list = fiber.dependencies;
        if (null !== list) {
          var nextFiber = fiber.child;
          list = list.firstContext;
          a: for (; null !== list; ) {
            var dependency = list;
            list = fiber;
            for (var i = 0; i < contexts.length; i++)
              if (dependency.context === contexts[i]) {
                list.lanes |= renderLanes2;
                dependency = list.alternate;
                null !== dependency && (dependency.lanes |= renderLanes2);
                scheduleContextWorkOnParentPath(
                  list.return,
                  renderLanes2,
                  workInProgress2
                );
                forcePropagateEntireTree || (nextFiber = null);
                break a;
              }
            list = dependency.next;
          }
        } else if (18 === fiber.tag) {
          nextFiber = fiber.return;
          if (null === nextFiber) throw Error(formatProdErrorMessage(341));
          nextFiber.lanes |= renderLanes2;
          list = nextFiber.alternate;
          null !== list && (list.lanes |= renderLanes2);
          scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
          nextFiber = null;
        } else nextFiber = fiber.child;
        if (null !== nextFiber) nextFiber.return = fiber;
        else
          for (nextFiber = fiber; null !== nextFiber; ) {
            if (nextFiber === workInProgress2) {
              nextFiber = null;
              break;
            }
            fiber = nextFiber.sibling;
            if (null !== fiber) {
              fiber.return = nextFiber.return;
              nextFiber = fiber;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
      current = null;
      for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
        if (!isInsidePropagationBailout) {
          if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
          else if (0 !== (parent.flags & 262144)) break;
        }
        if (10 === parent.tag) {
          var currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent = currentParent.memoizedProps;
          if (null !== currentParent) {
            var context = parent.type;
            objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
          }
        } else if (parent === hostTransitionProviderCursor.current) {
          currentParent = parent.alternate;
          if (null === currentParent) throw Error(formatProdErrorMessage(387));
          currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
        }
        parent = parent.return;
      }
      null !== current && propagateContextChanges(
        workInProgress2,
        current,
        renderLanes2,
        forcePropagateEntireTree
      );
      workInProgress2.flags |= 262144;
    }
    function checkIfContextChanged(currentDependencies) {
      for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
        if (!objectIs(
          currentDependencies.context._currentValue,
          currentDependencies.memoizedValue
        ))
          return true;
        currentDependencies = currentDependencies.next;
      }
      return false;
    }
    function prepareToReadContext(workInProgress2) {
      currentlyRenderingFiber$1 = workInProgress2;
      lastContextDependency = null;
      workInProgress2 = workInProgress2.dependencies;
      null !== workInProgress2 && (workInProgress2.firstContext = null);
    }
    function readContext(context) {
      return readContextForConsumer(currentlyRenderingFiber$1, context);
    }
    function readContextDuringReconciliation(consumer, context) {
      null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
      return readContextForConsumer(consumer, context);
    }
    function readContextForConsumer(consumer, context) {
      var value = context._currentValue;
      context = { context, memoizedValue: value, next: null };
      if (null === lastContextDependency) {
        if (null === consumer) throw Error(formatProdErrorMessage(308));
        lastContextDependency = context;
        consumer.dependencies = { lanes: 0, firstContext: context };
        consumer.flags |= 524288;
      } else lastContextDependency = lastContextDependency.next = context;
      return value;
    }
    var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
      var listeners = [], signal = this.signal = {
        aborted: false,
        addEventListener: function(type, listener) {
          listeners.push(listener);
        }
      };
      this.abort = function() {
        signal.aborted = true;
        listeners.forEach(function(listener) {
          return listener();
        });
      };
    };
    var scheduleCallback$2 = Scheduler.unstable_scheduleCallback;
    var NormalPriority = Scheduler.unstable_NormalPriority;
    var CacheContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
    function createCache() {
      return {
        controller: new AbortControllerLocal(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function releaseCache(cache) {
      cache.refCount--;
      0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
        cache.controller.abort();
      });
    }
    var currentEntangledListeners = null;
    var currentEntangledPendingCount = 0;
    var currentEntangledLane = 0;
    var currentEntangledActionThenable = null;
    function entangleAsyncAction(transition, thenable) {
      if (null === currentEntangledListeners) {
        var entangledListeners = currentEntangledListeners = [];
        currentEntangledPendingCount = 0;
        currentEntangledLane = requestTransitionLane();
        currentEntangledActionThenable = {
          status: "pending",
          value: void 0,
          then: function(resolve) {
            entangledListeners.push(resolve);
          }
        };
      }
      currentEntangledPendingCount++;
      thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
      return thenable;
    }
    function pingEngtangledActionScope() {
      if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
        null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
        var listeners = currentEntangledListeners;
        currentEntangledListeners = null;
        currentEntangledLane = 0;
        currentEntangledActionThenable = null;
        for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
      }
    }
    function chainThenableValue(thenable, result) {
      var listeners = [], thenableWithOverride = {
        status: "pending",
        value: null,
        reason: null,
        then: function(resolve) {
          listeners.push(resolve);
        }
      };
      thenable.then(
        function() {
          thenableWithOverride.status = "fulfilled";
          thenableWithOverride.value = result;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
        },
        function(error) {
          thenableWithOverride.status = "rejected";
          thenableWithOverride.reason = error;
          for (error = 0; error < listeners.length; error++)
            (0, listeners[error])(void 0);
        }
      );
      return thenableWithOverride;
    }
    var prevOnStartTransitionFinish = ReactSharedInternals.S;
    ReactSharedInternals.S = function(transition, returnValue) {
      globalMostRecentTransitionTime = now();
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
      null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
    };
    var resumedCache = createCursor(null);
    function peekCacheFromPool() {
      var cacheResumedFromPreviousRender = resumedCache.current;
      return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
    }
    function pushTransition(offscreenWorkInProgress, prevCachePool) {
      null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
    }
    function getSuspendedCache() {
      var cacheFromPool = peekCacheFromPool();
      return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
    }
    var SuspenseException = Error(formatProdErrorMessage(460));
    var SuspenseyCommitException = Error(formatProdErrorMessage(474));
    var SuspenseActionException = Error(formatProdErrorMessage(542));
    var noopSuspenseyCommitThenable = { then: function() {
    } };
    function isThenableResolved(thenable) {
      thenable = thenable.status;
      return "fulfilled" === thenable || "rejected" === thenable;
    }
    function trackUsedThenable(thenableState2, thenable, index3) {
      index3 = thenableState2[index3];
      void 0 === index3 ? thenableState2.push(thenable) : index3 !== thenable && (thenable.then(noop$1, noop$1), thenable = index3);
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
        default:
          if ("string" === typeof thenable.status) thenable.then(noop$1, noop$1);
          else {
            thenableState2 = workInProgressRoot;
            if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
              throw Error(formatProdErrorMessage(482));
            thenableState2 = thenable;
            thenableState2.status = "pending";
            thenableState2.then(
              function(fulfilledValue) {
                if ("pending" === thenable.status) {
                  var fulfilledThenable = thenable;
                  fulfilledThenable.status = "fulfilled";
                  fulfilledThenable.value = fulfilledValue;
                }
              },
              function(error) {
                if ("pending" === thenable.status) {
                  var rejectedThenable = thenable;
                  rejectedThenable.status = "rejected";
                  rejectedThenable.reason = error;
                }
              }
            );
          }
          switch (thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          }
          suspendedThenable = thenable;
          throw SuspenseException;
      }
    }
    function resolveLazy(lazyType) {
      try {
        var init = lazyType._init;
        return init(lazyType._payload);
      } catch (x) {
        if (null !== x && "object" === typeof x && "function" === typeof x.then)
          throw suspendedThenable = x, SuspenseException;
        throw x;
      }
    }
    var suspendedThenable = null;
    function getSuspendedThenable() {
      if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
      var thenable = suspendedThenable;
      suspendedThenable = null;
      return thenable;
    }
    function checkIfUseWrappedInAsyncCatch(rejectedReason) {
      if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
        throw Error(formatProdErrorMessage(483));
    }
    var thenableState$1 = null;
    var thenableIndexCounter$1 = 0;
    function unwrapThenable(thenable) {
      var index3 = thenableIndexCounter$1;
      thenableIndexCounter$1 += 1;
      null === thenableState$1 && (thenableState$1 = []);
      return trackUsedThenable(thenableState$1, thenable, index3);
    }
    function coerceRef(workInProgress2, element) {
      element = element.props.ref;
      workInProgress2.ref = void 0 !== element ? element : null;
    }
    function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
      if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
        throw Error(formatProdErrorMessage(525));
      returnFiber = Object.prototype.toString.call(newChild);
      throw Error(
        formatProdErrorMessage(
          31,
          "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
        )
      );
    }
    function createChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects) return null;
        for (; null !== currentFirstChild; )
          deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return null;
      }
      function mapRemainingChildren(currentFirstChild) {
        for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
          null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        fiber = createWorkInProgress(fiber, pendingProps);
        fiber.index = 0;
        fiber.sibling = null;
        return fiber;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        newFiber.index = newIndex;
        if (!shouldTrackSideEffects)
          return newFiber.flags |= 1048576, lastPlacedIndex;
        newIndex = newFiber.alternate;
        if (null !== newIndex)
          return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
        newFiber.flags |= 67108866;
        return lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
        return newFiber;
      }
      function updateTextNode(returnFiber, current, textContent, lanes) {
        if (null === current || 6 !== current.tag)
          return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, textContent);
        current.return = returnFiber;
        return current;
      }
      function updateElement(returnFiber, current, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return updateFragment(
            returnFiber,
            current,
            element.props.children,
            lanes,
            element.key
          );
        if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
          return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
        current = createFiberFromTypeAndProps(
          element.type,
          element.key,
          element.props,
          null,
          returnFiber.mode,
          lanes
        );
        coerceRef(current, element);
        current.return = returnFiber;
        return current;
      }
      function updatePortal(returnFiber, current, portal, lanes) {
        if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
          return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
        current = useFiber(current, portal.children || []);
        current.return = returnFiber;
        return current;
      }
      function updateFragment(returnFiber, current, fragment, lanes, key) {
        if (null === current || 7 !== current.tag)
          return current = createFiberFromFragment(
            fragment,
            returnFiber.mode,
            lanes,
            key
          ), current.return = returnFiber, current;
        current = useFiber(current, fragment);
        current.return = returnFiber;
        return current;
      }
      function createChild(returnFiber, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return newChild = createFiberFromText(
            "" + newChild,
            returnFiber.mode,
            lanes
          ), newChild.return = returnFiber, newChild;
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return lanes = createFiberFromTypeAndProps(
                newChild.type,
                newChild.key,
                newChild.props,
                null,
                returnFiber.mode,
                lanes
              ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
            case REACT_PORTAL_TYPE:
              return newChild = createFiberFromPortal(
                newChild,
                returnFiber.mode,
                lanes
              ), newChild.return = returnFiber, newChild;
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return newChild = createFiberFromFragment(
              newChild,
              returnFiber.mode,
              lanes,
              null
            ), newChild.return = returnFiber, newChild;
          if ("function" === typeof newChild.then)
            return createChild(returnFiber, unwrapThenable(newChild), lanes);
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return createChild(
              returnFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key = null !== oldFiber ? oldFiber.key : null;
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateSlot(
              returnFiber,
              oldFiber,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateSlot(
              returnFiber,
              oldFiber,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
          return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
            case REACT_PORTAL_TYPE:
              return existingChildren = existingChildren.get(
                null === newChild.key ? newIdx : newChild.key
              ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild) || getIteratorFn(newChild))
            return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
          if ("function" === typeof newChild.then)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return null;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(
            returnFiber,
            oldFiber,
            newChildren[newIdx],
            lanes
          );
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; newIdx < newChildren.length; newIdx++)
            oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
              oldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
          nextOldFiber = updateFromMap(
            oldFiber,
            returnFiber,
            newIdx,
            newChildren[newIdx],
            lanes
          ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
            null === nextOldFiber.key ? newIdx : nextOldFiber.key
          ), currentFirstChild = placeChild(
            nextOldFiber,
            currentFirstChild,
            newIdx
          ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
        if (null == newChildren) throw Error(formatProdErrorMessage(151));
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (null === newFiber) {
            null === oldFiber && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
          currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
          null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
          previousNewFiber = newFiber;
          oldFiber = nextOldFiber;
        }
        if (step.done)
          return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
        if (null === oldFiber) {
          for (; !step.done; newIdx++, step = newChildren.next())
            step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
          step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
        shouldTrackSideEffects && oldFiber.forEach(function(child) {
          return deleteChild(returnFiber, child);
        });
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
        "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
        if ("object" === typeof newChild && null !== newChild) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              a: {
                for (var key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key) {
                    key = newChild.type;
                    if (key === REACT_FRAGMENT_TYPE) {
                      if (7 === currentFirstChild.tag) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(
                          currentFirstChild,
                          newChild.props.children
                        );
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                    } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.props);
                      coerceRef(lanes, newChild);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    }
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  } else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                  newChild.props.children,
                  returnFiber.mode,
                  lanes,
                  newChild.key
                ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
              }
              return placeSingleChild(returnFiber);
            case REACT_PORTAL_TYPE:
              a: {
                for (key = newChild.key; null !== currentFirstChild; ) {
                  if (currentFirstChild.key === key)
                    if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(currentFirstChild, newChild.children || []);
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    } else {
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    }
                  else deleteChild(returnFiber, currentFirstChild);
                  currentFirstChild = currentFirstChild.sibling;
                }
                lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                lanes.return = returnFiber;
                returnFiber = lanes;
              }
              return placeSingleChild(returnFiber);
            case REACT_LAZY_TYPE:
              return newChild = resolveLazy(newChild), reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
          }
          if (isArrayImpl(newChild))
            return reconcileChildrenArray(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          if (getIteratorFn(newChild)) {
            key = getIteratorFn(newChild);
            if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
            newChild = key.call(newChild);
            return reconcileChildrenIterator(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
          }
          if ("function" === typeof newChild.then)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              unwrapThenable(newChild),
              lanes
            );
          if (newChild.$$typeof === REACT_CONTEXT_TYPE)
            return reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              readContextDuringReconciliation(returnFiber, newChild),
              lanes
            );
          throwOnInvalidObjectTypeImpl(returnFiber, newChild);
        }
        return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
      }
      return function(returnFiber, currentFirstChild, newChild, lanes) {
        try {
          thenableIndexCounter$1 = 0;
          var firstChildFiber = reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
          thenableState$1 = null;
          return firstChildFiber;
        } catch (x) {
          if (x === SuspenseException || x === SuspenseActionException) throw x;
          var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
          fiber.lanes = lanes;
          fiber.return = returnFiber;
          return fiber;
        } finally {
        }
      };
    }
    var reconcileChildFibers = createChildReconciler(true);
    var mountChildFibers = createChildReconciler(false);
    var hasForceUpdate = false;
    function initializeUpdateQueue(fiber) {
      fiber.updateQueue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: { pending: null, lanes: 0, hiddenCallbacks: null },
        callbacks: null
      };
    }
    function cloneUpdateQueue(current, workInProgress2) {
      current = current.updateQueue;
      workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
        baseState: current.baseState,
        firstBaseUpdate: current.firstBaseUpdate,
        lastBaseUpdate: current.lastBaseUpdate,
        shared: current.shared,
        callbacks: null
      });
    }
    function createUpdate(lane) {
      return { lane, tag: 0, payload: null, callback: null, next: null };
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (null === updateQueue) return null;
      updateQueue = updateQueue.shared;
      if (0 !== (executionContext & 2)) {
        var pending = updateQueue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        updateQueue.pending = update;
        update = getRootForUpdatedFiber(fiber);
        markUpdateLaneFromFiberToRoot(fiber, null, lane);
        return update;
      }
      enqueueUpdate$1(fiber, updateQueue, update, lane);
      return getRootForUpdatedFiber(fiber);
    }
    function entangleTransitions(root2, fiber, lane) {
      fiber = fiber.updateQueue;
      if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
        var queueLanes = fiber.lanes;
        queueLanes &= root2.pendingLanes;
        lane |= queueLanes;
        fiber.lanes = lane;
        markRootEntangled(root2, lane);
      }
    }
    function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
      var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
      if (null !== current && (current = current.updateQueue, queue === current)) {
        var newFirst = null, newLast = null;
        queue = queue.firstBaseUpdate;
        if (null !== queue) {
          do {
            var clone = {
              lane: queue.lane,
              tag: queue.tag,
              payload: queue.payload,
              callback: null,
              next: null
            };
            null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
            queue = queue.next;
          } while (null !== queue);
          null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
        } else newFirst = newLast = capturedUpdate;
        queue = {
          baseState: current.baseState,
          firstBaseUpdate: newFirst,
          lastBaseUpdate: newLast,
          shared: current.shared,
          callbacks: current.callbacks
        };
        workInProgress2.updateQueue = queue;
        return;
      }
      workInProgress2 = queue.lastBaseUpdate;
      null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
      queue.lastBaseUpdate = capturedUpdate;
    }
    var didReadFromEntangledAsyncAction = false;
    function suspendIfUpdateReadFromEntangledAsyncAction() {
      if (didReadFromEntangledAsyncAction) {
        var entangledActionThenable = currentEntangledActionThenable;
        if (null !== entangledActionThenable) throw entangledActionThenable;
      }
    }
    function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
      didReadFromEntangledAsyncAction = false;
      var queue = workInProgress$jscomp$0.updateQueue;
      hasForceUpdate = false;
      var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
      if (null !== pendingQueue) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null;
        null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
        lastBaseUpdate = lastPendingUpdate;
        var current = workInProgress$jscomp$0.alternate;
        null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
      }
      if (null !== firstBaseUpdate) {
        var newState = queue.baseState;
        lastBaseUpdate = 0;
        current = firstPendingUpdate = lastPendingUpdate = null;
        pendingQueue = firstBaseUpdate;
        do {
          var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
          if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
            0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
            null !== current && (current = current.next = {
              lane: 0,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: null,
              next: null
            });
            a: {
              var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
              updateLane = props;
              var instance = instance$jscomp$0;
              switch (update.tag) {
                case 1:
                  workInProgress2 = update.payload;
                  if ("function" === typeof workInProgress2) {
                    newState = workInProgress2.call(instance, newState, updateLane);
                    break a;
                  }
                  newState = workInProgress2;
                  break a;
                case 3:
                  workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                case 0:
                  workInProgress2 = update.payload;
                  updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                  if (null === updateLane || void 0 === updateLane) break a;
                  newState = assign({}, newState, updateLane);
                  break a;
                case 2:
                  hasForceUpdate = true;
              }
            }
            updateLane = pendingQueue.callback;
            null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
          } else
            isHiddenUpdate = {
              lane: updateLane,
              tag: pendingQueue.tag,
              payload: pendingQueue.payload,
              callback: pendingQueue.callback,
              next: null
            }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
          pendingQueue = pendingQueue.next;
          if (null === pendingQueue)
            if (pendingQueue = queue.shared.pending, null === pendingQueue)
              break;
            else
              isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
        } while (1);
        null === current && (lastPendingUpdate = newState);
        queue.baseState = lastPendingUpdate;
        queue.firstBaseUpdate = firstPendingUpdate;
        queue.lastBaseUpdate = current;
        null === firstBaseUpdate && (queue.shared.lanes = 0);
        workInProgressRootSkippedLanes |= lastBaseUpdate;
        workInProgress$jscomp$0.lanes = lastBaseUpdate;
        workInProgress$jscomp$0.memoizedState = newState;
      }
    }
    function callCallback(callback, context) {
      if ("function" !== typeof callback)
        throw Error(formatProdErrorMessage(191, callback));
      callback.call(context);
    }
    function commitCallbacks(updateQueue, context) {
      var callbacks = updateQueue.callbacks;
      if (null !== callbacks)
        for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
          callCallback(callbacks[updateQueue], context);
    }
    var currentTreeHiddenStackCursor = createCursor(null);
    var prevEntangledRenderLanesCursor = createCursor(0);
    function pushHiddenContext(fiber, context) {
      fiber = entangledRenderLanes;
      push(prevEntangledRenderLanesCursor, fiber);
      push(currentTreeHiddenStackCursor, context);
      entangledRenderLanes = fiber | context.baseLanes;
    }
    function reuseHiddenContextOnStack() {
      push(prevEntangledRenderLanesCursor, entangledRenderLanes);
      push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
    }
    function popHiddenContext() {
      entangledRenderLanes = prevEntangledRenderLanesCursor.current;
      pop(currentTreeHiddenStackCursor);
      pop(prevEntangledRenderLanesCursor);
    }
    var suspenseHandlerStackCursor = createCursor(null);
    var shellBoundary = null;
    function pushPrimaryTreeSuspenseHandler(handler) {
      var current = handler.alternate;
      push(suspenseStackCursor, suspenseStackCursor.current & 1);
      push(suspenseHandlerStackCursor, handler);
      null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
    }
    function pushDehydratedActivitySuspenseHandler(fiber) {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, fiber);
      null === shellBoundary && (shellBoundary = fiber);
    }
    function pushOffscreenSuspenseHandler(fiber) {
      22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack(fiber);
    }
    function reuseSuspenseHandlerOnStack() {
      push(suspenseStackCursor, suspenseStackCursor.current);
      push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
    }
    function popSuspenseHandler(fiber) {
      pop(suspenseHandlerStackCursor);
      shellBoundary === fiber && (shellBoundary = null);
      pop(suspenseStackCursor);
    }
    var suspenseStackCursor = createCursor(0);
    function findFirstSuspended(row) {
      for (var node = row; null !== node; ) {
        if (13 === node.tag) {
          var state = node.memoizedState;
          if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
            return node;
        } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
          if (0 !== (node.flags & 128)) return node;
        } else if (null !== node.child) {
          node.child.return = node;
          node = node.child;
          continue;
        }
        if (node === row) break;
        for (; null === node.sibling; ) {
          if (null === node.return || node.return === row) return null;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
      return null;
    }
    var renderLanes = 0;
    var currentlyRenderingFiber = null;
    var currentHook = null;
    var workInProgressHook = null;
    var didScheduleRenderPhaseUpdate = false;
    var didScheduleRenderPhaseUpdateDuringThisPass = false;
    var shouldDoubleInvokeUserFnsInHooksDEV = false;
    var localIdCounter = 0;
    var thenableIndexCounter = 0;
    var thenableState = null;
    var globalClientIdCounter = 0;
    function throwInvalidHookError() {
      throw Error(formatProdErrorMessage(321));
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (null === prevDeps) return false;
      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
        if (!objectIs(nextDeps[i], prevDeps[i])) return false;
      return true;
    }
    function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes;
      currentlyRenderingFiber = workInProgress2;
      workInProgress2.memoizedState = null;
      workInProgress2.updateQueue = null;
      workInProgress2.lanes = 0;
      ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      nextRenderLanes = Component(props, secondArg);
      shouldDoubleInvokeUserFnsInHooksDEV = false;
      didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
        workInProgress2,
        Component,
        props,
        secondArg
      ));
      finishRenderingHooks(current);
      return nextRenderLanes;
    }
    function finishRenderingHooks(current) {
      ReactSharedInternals.H = ContextOnlyDispatcher;
      var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdate = false;
      thenableIndexCounter = 0;
      thenableState = null;
      if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
      null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
    }
    function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
      currentlyRenderingFiber = workInProgress2;
      var numberOfReRenders = 0;
      do {
        didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
        thenableIndexCounter = 0;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
        numberOfReRenders += 1;
        workInProgressHook = currentHook = null;
        if (null != workInProgress2.updateQueue) {
          var children = workInProgress2.updateQueue;
          children.lastEffect = null;
          children.events = null;
          children.stores = null;
          null != children.memoCache && (children.memoCache.index = 0);
        }
        ReactSharedInternals.H = HooksDispatcherOnRerender;
        children = Component(props, secondArg);
      } while (didScheduleRenderPhaseUpdateDuringThisPass);
      return children;
    }
    function TransitionAwareHostComponent() {
      var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
      maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
      dispatcher = dispatcher.useState()[0];
      (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
      return maybeThenable;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = 0 !== localIdCounter;
      localIdCounter = 0;
      return didRenderIdHook;
    }
    function bailoutHooks(current, workInProgress2, lanes) {
      workInProgress2.updateQueue = current.updateQueue;
      workInProgress2.flags &= -2053;
      current.lanes &= ~lanes;
    }
    function resetHooksOnUnwind(workInProgress2) {
      if (didScheduleRenderPhaseUpdate) {
        for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
          var queue = workInProgress2.queue;
          null !== queue && (queue.pending = null);
          workInProgress2 = workInProgress2.next;
        }
        didScheduleRenderPhaseUpdate = false;
      }
      renderLanes = 0;
      workInProgressHook = currentHook = currentlyRenderingFiber = null;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      thenableIndexCounter = localIdCounter = 0;
      thenableState = null;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
      return workInProgressHook;
    }
    function updateWorkInProgressHook() {
      if (null === currentHook) {
        var nextCurrentHook = currentlyRenderingFiber.alternate;
        nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
      } else nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
      if (null !== nextWorkInProgressHook)
        workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
      else {
        if (null === nextCurrentHook) {
          if (null === currentlyRenderingFiber.alternate)
            throw Error(formatProdErrorMessage(467));
          throw Error(formatProdErrorMessage(310));
        }
        currentHook = nextCurrentHook;
        nextCurrentHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
      }
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return { lastEffect: null, events: null, stores: null, memoCache: null };
    }
    function useThenable(thenable) {
      var index3 = thenableIndexCounter;
      thenableIndexCounter += 1;
      null === thenableState && (thenableState = []);
      thenable = trackUsedThenable(thenableState, thenable, index3);
      index3 = currentlyRenderingFiber;
      null === (null === workInProgressHook ? index3.memoizedState : workInProgressHook.next) && (index3 = index3.alternate, ReactSharedInternals.H = null === index3 || null === index3.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
      return thenable;
    }
    function use(usable) {
      if (null !== usable && "object" === typeof usable) {
        if ("function" === typeof usable.then) return useThenable(usable);
        if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
      }
      throw Error(formatProdErrorMessage(438, String(usable)));
    }
    function useMemoCache(size4) {
      var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
      null !== updateQueue && (memoCache = updateQueue.memoCache);
      if (null == memoCache) {
        var current = currentlyRenderingFiber.alternate;
        null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
          data: current.data.map(function(array) {
            return array.slice();
          }),
          index: 0
        })));
      }
      null == memoCache && (memoCache = { data: [], index: 0 });
      null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
      updateQueue.memoCache = memoCache;
      updateQueue = memoCache.data[memoCache.index];
      if (void 0 === updateQueue)
        for (updateQueue = memoCache.data[memoCache.index] = Array(size4), current = 0; current < size4; current++)
          updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
      memoCache.index++;
      return updateQueue;
    }
    function basicStateReducer(state, action) {
      return "function" === typeof action ? action(state) : action;
    }
    function updateReducer(reducer) {
      var hook = updateWorkInProgressHook();
      return updateReducerImpl(hook, currentHook, reducer);
    }
    function updateReducerImpl(hook, current, reducer) {
      var queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
      if (null !== pendingQueue) {
        if (null !== baseQueue) {
          var baseFirst = baseQueue.next;
          baseQueue.next = pendingQueue.next;
          pendingQueue.next = baseFirst;
        }
        current.baseQueue = baseQueue = pendingQueue;
        queue.pending = null;
      }
      pendingQueue = hook.baseState;
      if (null === baseQueue) hook.memoizedState = pendingQueue;
      else {
        current = baseQueue.next;
        var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = false;
        do {
          var updateLane = update.lane & -536870913;
          if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
            var revertLane = update.revertLane;
            if (0 === revertLane)
              null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                lane: 0,
                revertLane: 0,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
            else if ((renderLanes & revertLane) === revertLane) {
              update = update.next;
              revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
              continue;
            } else
              updateLane = {
                lane: 0,
                revertLane: update.revertLane,
                gesture: null,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
            updateLane = update.action;
            shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
            pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
          } else
            revertLane = {
              lane: updateLane,
              revertLane: update.revertLane,
              gesture: update.gesture,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
          update = update.next;
        } while (null !== update && update !== current);
        null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
        if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$60 && (reducer = currentEntangledActionThenable, null !== reducer)))
          throw reducer;
        hook.memoizedState = pendingQueue;
        hook.baseState = baseFirst;
        hook.baseQueue = newBaseQueueLast;
        queue.lastRenderedState = pendingQueue;
      }
      null === baseQueue && (queue.lanes = 0);
      return [hook.memoizedState, queue.dispatch];
    }
    function rerenderReducer(reducer) {
      var hook = updateWorkInProgressHook(), queue = hook.queue;
      if (null === queue) throw Error(formatProdErrorMessage(311));
      queue.lastRenderedReducer = reducer;
      var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
      if (null !== lastRenderPhaseUpdate) {
        queue.pending = null;
        var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
        do
          newState = reducer(newState, update.action), update = update.next;
        while (update !== lastRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
        hook.memoizedState = newState;
        null === hook.baseQueue && (hook.baseState = newState);
        queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
      if (isHydrating$jscomp$0) {
        if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else getServerSnapshot = getSnapshot();
      var snapshotChanged = !objectIs(
        (currentHook || hook).memoizedState,
        getServerSnapshot
      );
      snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
      hook = hook.queue;
      updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
        subscribe
      ]);
      if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
        fiber.flags |= 2048;
        pushSimpleEffect(
          9,
          { destroy: void 0 },
          updateStoreInstance.bind(
            null,
            fiber,
            hook,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
        isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      return getServerSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= 16384;
      fiber = { getSnapshot, value: renderedSnapshot };
      getSnapshot = currentlyRenderingFiber.updateQueue;
      null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      return subscribe(function() {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      });
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot;
      inst = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(inst, nextValue);
      } catch (error) {
        return true;
      }
    }
    function forceStoreRerender(fiber) {
      var root2 = enqueueConcurrentRenderForLane(fiber, 2);
      null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
    }
    function mountStateImpl(initialState) {
      var hook = mountWorkInProgressHook();
      if ("function" === typeof initialState) {
        var initialStateInitializer = initialState;
        initialState = initialStateInitializer();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            initialStateInitializer();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      }
      hook.memoizedState = hook.baseState = initialState;
      hook.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      return hook;
    }
    function updateOptimisticImpl(hook, current, passthrough, reducer) {
      hook.baseState = passthrough;
      return updateReducerImpl(
        hook,
        currentHook,
        "function" === typeof reducer ? reducer : basicStateReducer
      );
    }
    function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
      if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
      fiber = actionQueue.action;
      if (null !== fiber) {
        var actionNode = {
          payload,
          action: fiber,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(listener) {
            actionNode.listeners.push(listener);
          }
        };
        null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
        setState(actionNode);
        setPendingState = actionQueue.pending;
        null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
      }
    }
    function runActionStateAction(actionQueue, node) {
      var action = node.action, payload = node.payload, prevState = actionQueue.state;
      if (node.isTransition) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          handleActionReturnValue(actionQueue, node, returnValue);
        } catch (error) {
          onActionError(actionQueue, node, error);
        } finally {
          null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      } else
        try {
          prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
        } catch (error$66) {
          onActionError(actionQueue, node, error$66);
        }
    }
    function handleActionReturnValue(actionQueue, node, returnValue) {
      null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
        function(nextState) {
          onActionSuccess(actionQueue, node, nextState);
        },
        function(error) {
          return onActionError(actionQueue, node, error);
        }
      ) : onActionSuccess(actionQueue, node, returnValue);
    }
    function onActionSuccess(actionQueue, actionNode, nextState) {
      actionNode.status = "fulfilled";
      actionNode.value = nextState;
      notifyActionListeners(actionNode);
      actionQueue.state = nextState;
      actionNode = actionQueue.pending;
      null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
    }
    function onActionError(actionQueue, actionNode, error) {
      var last = actionQueue.pending;
      actionQueue.pending = null;
      if (null !== last) {
        last = last.next;
        do
          actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
        while (actionNode !== last);
      }
      actionQueue.action = null;
    }
    function notifyActionListeners(actionNode) {
      actionNode = actionNode.listeners;
      for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
    }
    function actionStateReducer(oldState, newState) {
      return newState;
    }
    function mountActionState(action, initialStateProp) {
      if (isHydrating) {
        var ssrFormState = workInProgressRoot.formState;
        if (null !== ssrFormState) {
          a: {
            var JSCompiler_inline_result = currentlyRenderingFiber;
            if (isHydrating) {
              if (nextHydratableInstance) {
                b: {
                  var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                  for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                    if (!inRootOrSingleton) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                    JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    if (null === JSCompiler_inline_result$jscomp$0) {
                      JSCompiler_inline_result$jscomp$0 = null;
                      break b;
                    }
                  }
                  inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                  JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                }
                if (JSCompiler_inline_result$jscomp$0) {
                  nextHydratableInstance = getNextHydratable(
                    JSCompiler_inline_result$jscomp$0.nextSibling
                  );
                  JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                  break a;
                }
              }
              throwOnHydrationMismatch(JSCompiler_inline_result);
            }
            JSCompiler_inline_result = false;
          }
          JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
        }
      }
      ssrFormState = mountWorkInProgressHook();
      ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
      JSCompiler_inline_result = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: actionStateReducer,
        lastRenderedState: initialStateProp
      };
      ssrFormState.queue = JSCompiler_inline_result;
      ssrFormState = dispatchSetState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result
      );
      JSCompiler_inline_result.dispatch = ssrFormState;
      JSCompiler_inline_result = mountStateImpl(false);
      inRootOrSingleton = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        false,
        JSCompiler_inline_result.queue
      );
      JSCompiler_inline_result = mountWorkInProgressHook();
      JSCompiler_inline_result$jscomp$0 = {
        state: initialStateProp,
        dispatch: null,
        action,
        pending: null
      };
      JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
      ssrFormState = dispatchActionState.bind(
        null,
        currentlyRenderingFiber,
        JSCompiler_inline_result$jscomp$0,
        inRootOrSingleton,
        ssrFormState
      );
      JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
      JSCompiler_inline_result.memoizedState = action;
      return [initialStateProp, ssrFormState, false];
    }
    function updateActionState(action) {
      var stateHook = updateWorkInProgressHook();
      return updateActionStateImpl(stateHook, currentHook, action);
    }
    function updateActionStateImpl(stateHook, currentStateHook, action) {
      currentStateHook = updateReducerImpl(
        stateHook,
        currentStateHook,
        actionStateReducer
      )[0];
      stateHook = updateReducer(basicStateReducer)[0];
      if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
        try {
          var state = useThenable(currentStateHook);
        } catch (x) {
          if (x === SuspenseException) throw SuspenseActionException;
          throw x;
        }
      else state = currentStateHook;
      currentStateHook = updateWorkInProgressHook();
      var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
      action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
        9,
        { destroy: void 0 },
        actionStateActionEffect.bind(null, actionQueue, action),
        null
      ));
      return [state, dispatch, stateHook];
    }
    function actionStateActionEffect(actionQueue, action) {
      actionQueue.action = action;
    }
    function rerenderActionState(action) {
      var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
      if (null !== currentStateHook)
        return updateActionStateImpl(stateHook, currentStateHook, action);
      updateWorkInProgressHook();
      stateHook = stateHook.memoizedState;
      currentStateHook = updateWorkInProgressHook();
      var dispatch = currentStateHook.queue.dispatch;
      currentStateHook.memoizedState = action;
      return [stateHook, dispatch, false];
    }
    function pushSimpleEffect(tag, inst, create, deps) {
      tag = { tag, create, deps, inst, next: null };
      inst = currentlyRenderingFiber.updateQueue;
      null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
      create = inst.lastEffect;
      null === create ? inst.lastEffect = tag.next = tag : (deps = create.next, create.next = tag, tag.next = deps, inst.lastEffect = tag);
      return tag;
    }
    function updateRef() {
      return updateWorkInProgressHook().memoizedState;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = mountWorkInProgressHook();
      currentlyRenderingFiber.flags |= fiberFlags;
      hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        { destroy: void 0 },
        create,
        void 0 === deps ? null : deps
      );
    }
    function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var inst = hook.memoizedState.inst;
      null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
        1 | hookFlags,
        inst,
        create,
        deps
      ));
    }
    function mountEffect(create, deps) {
      mountEffectImpl(8390656, 8, create, deps);
    }
    function updateEffect(create, deps) {
      updateEffectImpl(2048, 8, create, deps);
    }
    function useEffectEventImpl(payload) {
      currentlyRenderingFiber.flags |= 4;
      var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
      if (null === componentUpdateQueue)
        componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
      else {
        var events = componentUpdateQueue.events;
        null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
      }
    }
    function updateEvent(callback) {
      var ref = updateWorkInProgressHook().memoizedState;
      useEffectEventImpl({ ref, nextImpl: callback });
      return function() {
        if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
        return ref.impl.apply(void 0, arguments);
      };
    }
    function updateInsertionEffect(create, deps) {
      return updateEffectImpl(4, 2, create, deps);
    }
    function updateLayoutEffect(create, deps) {
      return updateEffectImpl(4, 4, create, deps);
    }
    function imperativeHandleEffect(create, ref) {
      if ("function" === typeof ref) {
        create = create();
        var refCleanup = ref(create);
        return function() {
          "function" === typeof refCleanup ? refCleanup() : ref(null);
        };
      }
      if (null !== ref && void 0 !== ref)
        return create = create(), ref.current = create, function() {
          ref.current = null;
        };
    }
    function updateImperativeHandle(ref, create, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
    }
    function mountDebugValue() {
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      hook.memoizedState = [callback, deps];
      return callback;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var prevState = hook.memoizedState;
      if (null !== deps && areHookInputsEqual(deps, prevState[1]))
        return prevState[0];
      prevState = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [prevState, deps];
      return prevState;
    }
    function mountDeferredValueImpl(hook, value, initialValue) {
      if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
        return hook.memoizedState = value;
      hook.memoizedState = initialValue;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return initialValue;
    }
    function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
      if (objectIs(value, prevValue)) return value;
      if (null !== currentTreeHiddenStackCursor.current)
        return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
      if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
        return didReceiveUpdate = true, hook.memoizedState = value;
      hook = requestDeferredLane();
      currentlyRenderingFiber.lanes |= hook;
      workInProgressRootSkippedLanes |= hook;
      return prevValue;
    }
    function startTransition(fiber, queue, pendingState, finishedState, callback) {
      var previousPriority = ReactDOMSharedInternals.p;
      ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      dispatchOptimisticSetState(fiber, false, queue, pendingState);
      try {
        var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
          var thenableForFinishedState = chainThenableValue(
            returnValue,
            finishedState
          );
          dispatchSetStateInternal(
            fiber,
            queue,
            thenableForFinishedState,
            requestUpdateLane(fiber)
          );
        } else
          dispatchSetStateInternal(
            fiber,
            queue,
            finishedState,
            requestUpdateLane(fiber)
          );
      } catch (error) {
        dispatchSetStateInternal(
          fiber,
          queue,
          { then: function() {
          }, status: "rejected", reason: error },
          requestUpdateLane()
        );
      } finally {
        ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    }
    function noop4() {
    }
    function startHostTransition(formFiber, pendingState, action, formData) {
      if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
      var queue = ensureFormComponentIsStateful(formFiber).queue;
      startTransition(
        formFiber,
        queue,
        pendingState,
        sharedNotPendingObject,
        null === action ? noop4 : function() {
          requestFormReset$1(formFiber);
          return action(formData);
        }
      );
    }
    function ensureFormComponentIsStateful(formFiber) {
      var existingStateHook = formFiber.memoizedState;
      if (null !== existingStateHook) return existingStateHook;
      existingStateHook = {
        memoizedState: sharedNotPendingObject,
        baseState: sharedNotPendingObject,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: sharedNotPendingObject
        },
        next: null
      };
      var initialResetState = {};
      existingStateHook.next = {
        memoizedState: initialResetState,
        baseState: initialResetState,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialResetState
        },
        next: null
      };
      formFiber.memoizedState = existingStateHook;
      formFiber = formFiber.alternate;
      null !== formFiber && (formFiber.memoizedState = existingStateHook);
      return existingStateHook;
    }
    function requestFormReset$1(formFiber) {
      var stateHook = ensureFormComponentIsStateful(formFiber);
      null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
      dispatchSetStateInternal(
        formFiber,
        stateHook.next.queue,
        {},
        requestUpdateLane()
      );
    }
    function useHostTransitionStatus() {
      return readContext(HostTransitionContext);
    }
    function updateId() {
      return updateWorkInProgressHook().memoizedState;
    }
    function updateRefresh() {
      return updateWorkInProgressHook().memoizedState;
    }
    function refreshCache(fiber) {
      for (var provider = fiber.return; null !== provider; ) {
        switch (provider.tag) {
          case 24:
          case 3:
            var lane = requestUpdateLane();
            fiber = createUpdate(lane);
            var root$69 = enqueueUpdate(provider, fiber, lane);
            null !== root$69 && (scheduleUpdateOnFiber(root$69, provider, lane), entangleTransitions(root$69, provider, lane));
            provider = { cache: createCache() };
            fiber.payload = provider;
            return;
        }
        provider = provider.return;
      }
    }
    function dispatchReducerAction(fiber, queue, action) {
      var lane = requestUpdateLane();
      action = {
        lane,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
    }
    function dispatchSetState(fiber, queue, action) {
      var lane = requestUpdateLane();
      dispatchSetStateInternal(fiber, queue, action, lane);
    }
    function dispatchSetStateInternal(fiber, queue, action, lane) {
      var update = {
        lane,
        revertLane: 0,
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
          try {
            var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
            update.hasEagerState = true;
            update.eagerState = eagerState;
            if (objectIs(eagerState, currentState))
              return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
          } catch (error) {
          } finally {
          }
        action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (null !== action)
          return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
      }
      return false;
    }
    function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
      action = {
        lane: 2,
        revertLane: requestTransitionLane(),
        gesture: null,
        action,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber)) {
        if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
      } else
        throwIfDuringRender = enqueueConcurrentHookUpdate(
          fiber,
          queue,
          action,
          2
        ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
      var pending = queue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      queue.pending = update;
    }
    function entangleTransitionUpdate(root2, queue, lane) {
      if (0 !== (lane & 4194048)) {
        var queueLanes = queue.lanes;
        queueLanes &= root2.pendingLanes;
        lane |= queueLanes;
        queue.lanes = lane;
        markRootEntangled(root2, lane);
      }
    }
    var ContextOnlyDispatcher = {
      readContext,
      use,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError,
      useHostTransitionStatus: throwInvalidHookError,
      useFormState: throwInvalidHookError,
      useActionState: throwInvalidHookError,
      useOptimistic: throwInvalidHookError,
      useMemoCache: throwInvalidHookError,
      useCacheRefresh: throwInvalidHookError
    };
    ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
    var HooksDispatcherOnMount = {
      readContext,
      use,
      useCallback: function(callback, deps) {
        mountWorkInProgressHook().memoizedState = [
          callback,
          void 0 === deps ? null : deps
        ];
        return callback;
      },
      useContext: readContext,
      useEffect: mountEffect,
      useImperativeHandle: function(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        mountEffectImpl(
          4194308,
          4,
          imperativeHandleEffect.bind(null, create, ref),
          deps
        );
      },
      useLayoutEffect: function(create, deps) {
        return mountEffectImpl(4194308, 4, create, deps);
      },
      useInsertionEffect: function(create, deps) {
        mountEffectImpl(4, 2, create, deps);
      },
      useMemo: function(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var nextValue = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [nextValue, deps];
        return nextValue;
      },
      useReducer: function(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        if (void 0 !== init) {
          var initialState = init(initialArg);
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              init(initialArg);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        } else initialState = initialArg;
        hook.memoizedState = hook.baseState = initialState;
        reducer = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState
        };
        hook.queue = reducer;
        reducer = reducer.dispatch = dispatchReducerAction.bind(
          null,
          currentlyRenderingFiber,
          reducer
        );
        return [hook.memoizedState, reducer];
      },
      useRef: function(initialValue) {
        var hook = mountWorkInProgressHook();
        initialValue = { current: initialValue };
        return hook.memoizedState = initialValue;
      },
      useState: function(initialState) {
        initialState = mountStateImpl(initialState);
        var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
        queue.dispatch = dispatch;
        return [initialState.memoizedState, dispatch];
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue) {
        var hook = mountWorkInProgressHook();
        return mountDeferredValueImpl(hook, value, initialValue);
      },
      useTransition: function() {
        var stateHook = mountStateImpl(false);
        stateHook = startTransition.bind(
          null,
          currentlyRenderingFiber,
          stateHook.queue,
          true,
          false
        );
        mountWorkInProgressHook().memoizedState = stateHook;
        return [false, stateHook];
      },
      useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
        if (isHydrating) {
          if (void 0 === getServerSnapshot)
            throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else {
          getServerSnapshot = getSnapshot();
          if (null === workInProgressRoot)
            throw Error(formatProdErrorMessage(349));
          0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        hook.memoizedState = getServerSnapshot;
        var inst = { value: getServerSnapshot, getSnapshot };
        hook.queue = inst;
        mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
          subscribe
        ]);
        fiber.flags |= 2048;
        pushSimpleEffect(
          9,
          { destroy: void 0 },
          updateStoreInstance.bind(
            null,
            fiber,
            inst,
            getServerSnapshot,
            getSnapshot
          ),
          null
        );
        return getServerSnapshot;
      },
      useId: function() {
        var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
        if (isHydrating) {
          var JSCompiler_inline_result = treeContextOverflow;
          var idWithLeadingBit = treeContextId;
          JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
          identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
          JSCompiler_inline_result = localIdCounter++;
          0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
          identifierPrefix += "_";
        } else
          JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
        return hook.memoizedState = identifierPrefix;
      },
      useHostTransitionStatus,
      useFormState: mountActionState,
      useActionState: mountActionState,
      useOptimistic: function(passthrough) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = hook.baseState = passthrough;
        var queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        hook.queue = queue;
        hook = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          true,
          queue
        );
        queue.dispatch = hook;
        return [passthrough, hook];
      },
      useMemoCache,
      useCacheRefresh: function() {
        return mountWorkInProgressHook().memoizedState = refreshCache.bind(
          null,
          currentlyRenderingFiber
        );
      },
      useEffectEvent: function(callback) {
        var hook = mountWorkInProgressHook(), ref = { impl: callback };
        hook.memoizedState = ref;
        return function() {
          if (0 !== (executionContext & 2))
            throw Error(formatProdErrorMessage(440));
          return ref.impl.apply(void 0, arguments);
        };
      }
    };
    var HooksDispatcherOnUpdate = {
      readContext,
      use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: updateReducer,
      useRef: updateRef,
      useState: function() {
        return updateReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      },
      useTransition: function() {
        var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId,
      useHostTransitionStatus,
      useFormState: updateActionState,
      useActionState: updateActionState,
      useOptimistic: function(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      },
      useMemoCache,
      useCacheRefresh: updateRefresh
    };
    HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
    var HooksDispatcherOnRerender = {
      readContext,
      use,
      useCallback: updateCallback,
      useContext: readContext,
      useEffect: updateEffect,
      useImperativeHandle: updateImperativeHandle,
      useInsertionEffect: updateInsertionEffect,
      useLayoutEffect: updateLayoutEffect,
      useMemo: updateMemo,
      useReducer: rerenderReducer,
      useRef: updateRef,
      useState: function() {
        return rerenderReducer(basicStateReducer);
      },
      useDebugValue: mountDebugValue,
      useDeferredValue: function(value, initialValue) {
        var hook = updateWorkInProgressHook();
        return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
          hook,
          currentHook.memoizedState,
          value,
          initialValue
        );
      },
      useTransition: function() {
        var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
        return [
          "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
          start
        ];
      },
      useSyncExternalStore: updateSyncExternalStore,
      useId: updateId,
      useHostTransitionStatus,
      useFormState: rerenderActionState,
      useActionState: rerenderActionState,
      useOptimistic: function(passthrough, reducer) {
        var hook = updateWorkInProgressHook();
        if (null !== currentHook)
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        hook.baseState = passthrough;
        return [passthrough, hook.queue.dispatch];
      },
      useMemoCache,
      useCacheRefresh: updateRefresh
    };
    HooksDispatcherOnRerender.useEffectEvent = updateEvent;
    function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
      ctor = workInProgress2.memoizedState;
      getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
      getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign({}, ctor, getDerivedStateFromProps);
      workInProgress2.memoizedState = getDerivedStateFromProps;
      0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
    }
    var classComponentUpdater = {
      enqueueSetState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueReplaceState: function(inst, payload, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 1;
        update.payload = payload;
        void 0 !== callback && null !== callback && (update.callback = callback);
        payload = enqueueUpdate(inst, update, lane);
        null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
      },
      enqueueForceUpdate: function(inst, callback) {
        inst = inst._reactInternals;
        var lane = requestUpdateLane(), update = createUpdate(lane);
        update.tag = 2;
        void 0 !== callback && null !== callback && (update.callback = callback);
        callback = enqueueUpdate(inst, update, lane);
        null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
      }
    };
    function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
      workInProgress2 = workInProgress2.stateNode;
      return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
    }
    function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
      workInProgress2 = instance.state;
      "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
      "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
      instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
    }
    function resolveClassComponentProps(Component, baseProps) {
      var newProps = baseProps;
      if ("ref" in baseProps) {
        newProps = {};
        for (var propName in baseProps)
          "ref" !== propName && (newProps[propName] = baseProps[propName]);
      }
      if (Component = Component.defaultProps) {
        newProps === baseProps && (newProps = assign({}, newProps));
        for (var propName$73 in Component)
          void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
      }
      return newProps;
    }
    function defaultOnUncaughtError(error) {
      reportGlobalError(error);
    }
    function defaultOnCaughtError(error) {
      console.error(error);
    }
    function defaultOnRecoverableError(error) {
      reportGlobalError(error);
    }
    function logUncaughtError(root2, errorInfo) {
      try {
        var onUncaughtError = root2.onUncaughtError;
        onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
      } catch (e$74) {
        setTimeout(function() {
          throw e$74;
        });
      }
    }
    function logCaughtError(root2, boundary, errorInfo) {
      try {
        var onCaughtError = root2.onCaughtError;
        onCaughtError(errorInfo.value, {
          componentStack: errorInfo.stack,
          errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
        });
      } catch (e$75) {
        setTimeout(function() {
          throw e$75;
        });
      }
    }
    function createRootErrorUpdate(root2, errorInfo, lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      lane.payload = { element: null };
      lane.callback = function() {
        logUncaughtError(root2, errorInfo);
      };
      return lane;
    }
    function createClassErrorUpdate(lane) {
      lane = createUpdate(lane);
      lane.tag = 3;
      return lane;
    }
    function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if ("function" === typeof getDerivedStateFromError) {
        var error = errorInfo.value;
        update.payload = function() {
          return getDerivedStateFromError(error);
        };
        update.callback = function() {
          logCaughtError(root2, fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
        logCaughtError(root2, fiber, errorInfo);
        "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
        var stack = errorInfo.stack;
        this.componentDidCatch(errorInfo.value, {
          componentStack: null !== stack ? stack : ""
        });
      });
    }
    function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
      sourceFiber.flags |= 32768;
      if (null !== value && "object" === typeof value && "function" === typeof value.then) {
        returnFiber = sourceFiber.alternate;
        null !== returnFiber && propagateParentContextChanges(
          returnFiber,
          sourceFiber,
          rootRenderLanes,
          true
        );
        sourceFiber = suspenseHandlerStackCursor.current;
        if (null !== sourceFiber) {
          switch (sourceFiber.tag) {
            case 31:
            case 13:
              return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
            case 22:
              return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([value])
              }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
          }
          throw Error(formatProdErrorMessage(435, sourceFiber.tag));
        }
        attachPingListener(root2, value, rootRenderLanes);
        renderDidSuspendDelayIfPossible();
        return false;
      }
      if (isHydrating)
        return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
          cause: value
        }), queueHydrationError(
          createCapturedValueAtFiber(returnFiber, sourceFiber)
        )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
          root2.stateNode,
          value,
          rootRenderLanes
        ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
      var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
      wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
      null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
      4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
      if (null === returnFiber) return true;
      value = createCapturedValueAtFiber(value, sourceFiber);
      sourceFiber = returnFiber;
      do {
        switch (sourceFiber.tag) {
          case 3:
            return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
          case 1:
            if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
              return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                rootRenderLanes,
                root2,
                sourceFiber,
                value
              ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
        }
        sourceFiber = sourceFiber.return;
      } while (null !== sourceFiber);
      return false;
    }
    var SelectiveHydrationException = Error(formatProdErrorMessage(461));
    var didReceiveUpdate = false;
    function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
      workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
        workInProgress2,
        current.child,
        nextChildren,
        renderLanes2
      );
    }
    function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
      Component = Component.render;
      var ref = workInProgress2.ref;
      if ("ref" in nextProps) {
        var propsWithoutRef = {};
        for (var key in nextProps)
          "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
      } else propsWithoutRef = nextProps;
      prepareToReadContext(workInProgress2);
      nextProps = renderWithHooks(
        current,
        workInProgress2,
        Component,
        propsWithoutRef,
        ref,
        renderLanes2
      );
      key = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && key && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      if (null === current) {
        var type = Component.type;
        if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
          return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
            current,
            workInProgress2,
            type,
            nextProps,
            renderLanes2
          );
        current = createFiberFromTypeAndProps(
          Component.type,
          null,
          nextProps,
          workInProgress2,
          workInProgress2.mode,
          renderLanes2
        );
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      type = current.child;
      if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
        var prevProps = type.memoizedProps;
        Component = Component.compare;
        Component = null !== Component ? Component : shallowEqual;
        if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
          return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      workInProgress2.flags |= 1;
      current = createWorkInProgress(type, nextProps);
      current.ref = workInProgress2.ref;
      current.return = workInProgress2;
      return workInProgress2.child = current;
    }
    function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      if (null !== current) {
        var prevProps = current.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
          if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
            0 !== (current.flags & 131072) && (didReceiveUpdate = true);
          else
            return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      return updateFunctionComponent(
        current,
        workInProgress2,
        Component,
        nextProps,
        renderLanes2
      );
    }
    function updateOffscreenComponent(current, workInProgress2, renderLanes2, nextProps) {
      var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
      null === current && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      if ("hidden" === nextProps.mode) {
        if (0 !== (workInProgress2.flags & 128)) {
          prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
          if (null !== current) {
            nextProps = workInProgress2.child = current.child;
            for (nextChildren = 0; null !== nextProps; )
              nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
            nextProps = nextChildren & ~prevState;
          } else nextProps = 0, workInProgress2.child = null;
          return deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            prevState,
            renderLanes2,
            nextProps
          );
        }
        if (0 !== (renderLanes2 & 536870912))
          workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
            workInProgress2,
            null !== prevState ? prevState.cachePool : null
          ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
        else
          return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
            current,
            workInProgress2,
            null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
            renderLanes2,
            nextProps
          );
      } else
        null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress2));
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    function bailoutOffscreenComponent(current, workInProgress2) {
      null !== current && 22 === current.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      });
      return workInProgress2.sibling;
    }
    function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
      var JSCompiler_inline_result = peekCacheFromPool();
      JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
      workInProgress2.memoizedState = {
        baseLanes: nextBaseLanes,
        cachePool: JSCompiler_inline_result
      };
      null !== current && pushTransition(workInProgress2, null);
      reuseHiddenContextOnStack();
      pushOffscreenSuspenseHandler(workInProgress2);
      null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
      workInProgress2.childLanes = remainingChildLanes;
      return null;
    }
    function mountActivityChildren(workInProgress2, nextProps) {
      nextProps = mountWorkInProgressOffscreenFiber(
        { mode: nextProps.mode, children: nextProps.children },
        workInProgress2.mode
      );
      nextProps.ref = workInProgress2.ref;
      workInProgress2.child = nextProps;
      nextProps.return = workInProgress2;
      return nextProps;
    }
    function retryActivityComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
      current = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
      current.flags |= 2;
      popSuspenseHandler(workInProgress2);
      workInProgress2.memoizedState = null;
      return current;
    }
    function updateActivityComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
      workInProgress2.flags &= -129;
      if (null === current) {
        if (isHydrating) {
          if ("hidden" === nextProps.mode)
            return current = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current);
          pushDehydratedActivitySuspenseHandler(workInProgress2);
          (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          ), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
            dehydrated: current,
            treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
          if (null === current) throw throwOnHydrationMismatch(workInProgress2);
          workInProgress2.lanes = 536870912;
          return null;
        }
        return mountActivityChildren(workInProgress2, nextProps);
      }
      var prevState = current.memoizedState;
      if (null !== prevState) {
        var dehydrated = prevState.dehydrated;
        pushDehydratedActivitySuspenseHandler(workInProgress2);
        if (didSuspend)
          if (workInProgress2.flags & 256)
            workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          else if (null !== workInProgress2.memoizedState)
            workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null;
          else throw Error(formatProdErrorMessage(558));
        else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), didSuspend = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || didSuspend) {
          nextProps = workInProgressRoot;
          if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes2), 0 !== dehydrated && dehydrated !== prevState.retryLane))
            throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, current, dehydrated), SelectiveHydrationException;
          renderDidSuspendDelayIfPossible();
          workInProgress2 = retryActivityComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else
          current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
        return workInProgress2;
      }
      current = createWorkInProgress(current.child, {
        mode: nextProps.mode,
        children: nextProps.children
      });
      current.ref = workInProgress2.ref;
      workInProgress2.child = current;
      current.return = workInProgress2;
      return current;
    }
    function markRef(current, workInProgress2) {
      var ref = workInProgress2.ref;
      if (null === ref)
        null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
      else {
        if ("function" !== typeof ref && "object" !== typeof ref)
          throw Error(formatProdErrorMessage(284));
        if (null === current || current.ref !== ref)
          workInProgress2.flags |= 4194816;
      }
    }
    function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      Component = renderWithHooks(
        current,
        workInProgress2,
        Component,
        nextProps,
        void 0,
        renderLanes2
      );
      nextProps = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, Component, renderLanes2);
      return workInProgress2.child;
    }
    function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
      prepareToReadContext(workInProgress2);
      workInProgress2.updateQueue = null;
      nextProps = renderWithHooksAgain(
        workInProgress2,
        Component,
        nextProps,
        secondArg
      );
      finishRenderingHooks(current);
      Component = checkDidRenderIdHook();
      if (null !== current && !didReceiveUpdate)
        return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      isHydrating && Component && pushMaterializedTreeId(workInProgress2);
      workInProgress2.flags |= 1;
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      return workInProgress2.child;
    }
    function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
      prepareToReadContext(workInProgress2);
      if (null === workInProgress2.stateNode) {
        var context = emptyContextObject, contextType = Component.contextType;
        "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
        context = new Component(nextProps, context);
        workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
        context.updater = classComponentUpdater;
        workInProgress2.stateNode = context;
        context._reactInternals = workInProgress2;
        context = workInProgress2.stateNode;
        context.props = nextProps;
        context.state = workInProgress2.memoizedState;
        context.refs = {};
        initializeUpdateQueue(workInProgress2);
        contextType = Component.contextType;
        context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
        context.state = workInProgress2.memoizedState;
        contextType = Component.getDerivedStateFromProps;
        "function" === typeof contextType && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          contextType,
          nextProps
        ), context.state = workInProgress2.memoizedState);
        "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
        "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
        nextProps = true;
      } else if (null === current) {
        context = workInProgress2.stateNode;
        var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
        context.props = oldProps;
        var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
        contextType = emptyContextObject;
        "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
        var getDerivedStateFromProps = Component.getDerivedStateFromProps;
        contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
        unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
        contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          contextType
        );
        hasForceUpdate = false;
        var oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        oldContext = workInProgress2.memoizedState;
        unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          getDerivedStateFromProps,
          nextProps
        ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component,
          oldProps,
          nextProps,
          oldState,
          oldContext,
          contextType
        )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
      } else {
        context = workInProgress2.stateNode;
        cloneUpdateQueue(current, workInProgress2);
        contextType = workInProgress2.memoizedProps;
        contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
        context.props = contextType$jscomp$0;
        getDerivedStateFromProps = workInProgress2.pendingProps;
        oldState = context.context;
        oldContext = Component.contextType;
        oldProps = emptyContextObject;
        "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
        unresolvedOldProps = Component.getDerivedStateFromProps;
        (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
          workInProgress2,
          context,
          nextProps,
          oldProps
        );
        hasForceUpdate = false;
        oldState = workInProgress2.memoizedState;
        context.state = oldState;
        processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
        suspendIfUpdateReadFromEntangledAsyncAction();
        var newState = workInProgress2.memoizedState;
        contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
          workInProgress2,
          Component,
          unresolvedOldProps,
          nextProps
        ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
          workInProgress2,
          Component,
          contextType$jscomp$0,
          nextProps,
          oldState,
          newState,
          oldProps
        ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
          nextProps,
          newState,
          oldProps
        )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
      }
      context = nextProps;
      markRef(current, workInProgress2);
      nextProps = 0 !== (workInProgress2.flags & 128);
      context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        current.child,
        null,
        renderLanes2
      ), workInProgress2.child = reconcileChildFibers(
        workInProgress2,
        null,
        Component,
        renderLanes2
      )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
        current,
        workInProgress2,
        renderLanes2
      );
      return current;
    }
    function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
      resetHydrationState();
      workInProgress2.flags |= 256;
      reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
      return workInProgress2.child;
    }
    var SUSPENDED_MARKER = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    };
    function mountSuspenseOffscreenState(renderLanes2) {
      return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
    }
    function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
      current = null !== current ? current.childLanes & ~renderLanes2 : 0;
      primaryTreeDidDefer && (current |= workInProgressDeferredLane);
      return current;
    }
    function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
      (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
      JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
      JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
      workInProgress2.flags &= -33;
      if (null === current) {
        if (isHydrating) {
          showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
          (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
            current,
            rootOrSingletonContext
          ), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
            dehydrated: current,
            treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
            retryLane: 536870912,
            hydrationErrors: null
          }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
          if (null === current) throw throwOnHydrationMismatch(workInProgress2);
          isSuspenseInstanceFallback(current) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
          return null;
        }
        var nextPrimaryChildren = nextProps.children;
        nextProps = nextProps.fallback;
        if (showFallback)
          return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
            { mode: "hidden", children: nextPrimaryChildren },
            showFallback
          ), nextProps = createFiberFromFragment(
            nextProps,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
      }
      var prevState = current.memoizedState;
      if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
        if (didSuspend)
          workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
            { mode: "visible", children: nextProps.children },
            showFallback
          ), nextPrimaryChildren = createFiberFromFragment(
            nextPrimaryChildren,
            showFallback,
            renderLanes2,
            null
          ), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(
            workInProgress2,
            current.child,
            null,
            renderLanes2
          ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
        else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren)) {
          JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
          if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
          JSCompiler_temp = digest;
          nextProps = Error(formatProdErrorMessage(419));
          nextProps.stack = "";
          nextProps.digest = JSCompiler_temp;
          queueHydrationError({ value: nextProps, source: null, stack: null });
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
          JSCompiler_temp = workInProgressRoot;
          if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), 0 !== nextProps && nextProps !== prevState.retryLane))
            throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
          isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
          workInProgress2 = retrySuspenseComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        } else
          isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(
            nextPrimaryChildren.nextSibling
          ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountSuspensePrimaryChildren(
            workInProgress2,
            nextProps.children
          ), workInProgress2.flags |= 4096);
        return workInProgress2;
      }
      if (showFallback)
        return reuseSuspenseHandlerOnStack(workInProgress2), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
          mode: "hidden",
          children: nextProps.children
        }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(
          digest,
          nextPrimaryChildren
        ) : (nextPrimaryChildren = createFiberFromFragment(
          nextPrimaryChildren,
          showFallback,
          renderLanes2,
          null
        ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
          baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
          cachePool: showFallback
        }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes2
        ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      renderLanes2 = current.child;
      current = renderLanes2.sibling;
      renderLanes2 = createWorkInProgress(renderLanes2, {
        mode: "visible",
        children: nextProps.children
      });
      renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
      null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
      workInProgress2.child = renderLanes2;
      workInProgress2.memoizedState = null;
      return renderLanes2;
    }
    function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
      primaryChildren = mountWorkInProgressOffscreenFiber(
        { mode: "visible", children: primaryChildren },
        workInProgress2.mode
      );
      primaryChildren.return = workInProgress2;
      return workInProgress2.child = primaryChildren;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
      offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
      offscreenProps.lanes = 0;
      return offscreenProps;
    }
    function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
      reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
      current = mountSuspensePrimaryChildren(
        workInProgress2,
        workInProgress2.pendingProps.children
      );
      current.flags |= 2;
      workInProgress2.memoizedState = null;
      return current;
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
      fiber.lanes |= renderLanes2;
      var alternate = fiber.alternate;
      null !== alternate && (alternate.lanes |= renderLanes2);
      scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
    }
    function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
      var renderState = workInProgress2.memoizedState;
      null === renderState ? workInProgress2.memoizedState = {
        isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail,
        tailMode,
        treeForkCount: treeForkCount2
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
    }
    function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
      nextProps = nextProps.children;
      var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
      shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress2.flags |= 128) : suspenseContext &= 1;
      push(suspenseStackCursor, suspenseContext);
      reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
      nextProps = isHydrating ? treeForkCount : 0;
      if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
        a: for (current = workInProgress2.child; null !== current; ) {
          if (13 === current.tag)
            null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
          else if (19 === current.tag)
            scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
          else if (null !== current.child) {
            current.child.return = current;
            current = current.child;
            continue;
          }
          if (current === workInProgress2) break a;
          for (; null === current.sibling; ) {
            if (null === current.return || current.return === workInProgress2)
              break a;
            current = current.return;
          }
          current.sibling.return = current.return;
          current = current.sibling;
        }
      switch (revealOrder) {
        case "forwards":
          renderLanes2 = workInProgress2.child;
          for (revealOrder = null; null !== renderLanes2; )
            current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
          renderLanes2 = revealOrder;
          null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
          initSuspenseListRenderState(
            workInProgress2,
            false,
            revealOrder,
            renderLanes2,
            tailMode,
            nextProps
          );
          break;
        case "backwards":
        case "unstable_legacy-backwards":
          renderLanes2 = null;
          revealOrder = workInProgress2.child;
          for (workInProgress2.child = null; null !== revealOrder; ) {
            current = revealOrder.alternate;
            if (null !== current && null === findFirstSuspended(current)) {
              workInProgress2.child = revealOrder;
              break;
            }
            current = revealOrder.sibling;
            revealOrder.sibling = renderLanes2;
            renderLanes2 = revealOrder;
            revealOrder = current;
          }
          initSuspenseListRenderState(
            workInProgress2,
            true,
            renderLanes2,
            null,
            tailMode,
            nextProps
          );
          break;
        case "together":
          initSuspenseListRenderState(
            workInProgress2,
            false,
            null,
            null,
            void 0,
            nextProps
          );
          break;
        default:
          workInProgress2.memoizedState = null;
      }
      return workInProgress2.child;
    }
    function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
      null !== current && (workInProgress2.dependencies = current.dependencies);
      workInProgressRootSkippedLanes |= workInProgress2.lanes;
      if (0 === (renderLanes2 & workInProgress2.childLanes))
        if (null !== current) {
          if (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), 0 === (renderLanes2 & workInProgress2.childLanes))
            return null;
        } else return null;
      if (null !== current && workInProgress2.child !== current.child)
        throw Error(formatProdErrorMessage(153));
      if (null !== workInProgress2.child) {
        current = workInProgress2.child;
        renderLanes2 = createWorkInProgress(current, current.pendingProps);
        workInProgress2.child = renderLanes2;
        for (renderLanes2.return = workInProgress2; null !== current.sibling; )
          current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
      }
      return workInProgress2.child;
    }
    function checkScheduledUpdateOrContext(current, renderLanes2) {
      if (0 !== (current.lanes & renderLanes2)) return true;
      current = current.dependencies;
      return null !== current && checkIfContextChanged(current) ? true : false;
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
      switch (workInProgress2.tag) {
        case 3:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
          resetHydrationState();
          break;
        case 27:
        case 5:
          pushHostContext(workInProgress2);
          break;
        case 4:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          break;
        case 10:
          pushProvider(
            workInProgress2,
            workInProgress2.type,
            workInProgress2.memoizedProps.value
          );
          break;
        case 31:
          if (null !== workInProgress2.memoizedState)
            return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
          break;
        case 13:
          var state$102 = workInProgress2.memoizedState;
          if (null !== state$102) {
            if (null !== state$102.dehydrated)
              return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
            if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
              return updateSuspenseComponent(current, workInProgress2, renderLanes2);
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            current = bailoutOnAlreadyFinishedWork(
              current,
              workInProgress2,
              renderLanes2
            );
            return null !== current ? current.sibling : null;
          }
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          break;
        case 19:
          var didSuspendBefore = 0 !== (current.flags & 128);
          state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes);
          state$102 || (propagateParentContextChanges(
            current,
            workInProgress2,
            renderLanes2,
            false
          ), state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes));
          if (didSuspendBefore) {
            if (state$102)
              return updateSuspenseListComponent(
                current,
                workInProgress2,
                renderLanes2
              );
            workInProgress2.flags |= 128;
          }
          didSuspendBefore = workInProgress2.memoizedState;
          null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
          push(suspenseStackCursor, suspenseStackCursor.current);
          if (state$102) break;
          else return null;
        case 22:
          return workInProgress2.lanes = 0, updateOffscreenComponent(
            current,
            workInProgress2,
            renderLanes2,
            workInProgress2.pendingProps
          );
        case 24:
          pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
      }
      return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    }
    function beginWork(current, workInProgress2, renderLanes2) {
      if (null !== current)
        if (current.memoizedProps !== workInProgress2.pendingProps)
          didReceiveUpdate = true;
        else {
          if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
            return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
              current,
              workInProgress2,
              renderLanes2
            );
          didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
        }
      else
        didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
      workInProgress2.lanes = 0;
      switch (workInProgress2.tag) {
        case 16:
          a: {
            var props = workInProgress2.pendingProps;
            current = resolveLazy(workInProgress2.elementType);
            workInProgress2.type = current;
            if ("function" === typeof current)
              shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                null,
                workInProgress2,
                current,
                props,
                renderLanes2
              )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                null,
                workInProgress2,
                current,
                props,
                renderLanes2
              ));
            else {
              if (void 0 !== current && null !== current) {
                var $$typeof = current.$$typeof;
                if ($$typeof === REACT_FORWARD_REF_TYPE) {
                  workInProgress2.tag = 11;
                  workInProgress2 = updateForwardRef(
                    null,
                    workInProgress2,
                    current,
                    props,
                    renderLanes2
                  );
                  break a;
                } else if ($$typeof === REACT_MEMO_TYPE) {
                  workInProgress2.tag = 14;
                  workInProgress2 = updateMemoComponent(
                    null,
                    workInProgress2,
                    current,
                    props,
                    renderLanes2
                  );
                  break a;
                }
              }
              workInProgress2 = getComponentNameFromType(current) || current;
              throw Error(formatProdErrorMessage(306, workInProgress2, ""));
            }
          }
          return workInProgress2;
        case 0:
          return updateFunctionComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 1:
          return props = workInProgress2.type, $$typeof = resolveClassComponentProps(
            props,
            workInProgress2.pendingProps
          ), updateClassComponent(
            current,
            workInProgress2,
            props,
            $$typeof,
            renderLanes2
          );
        case 3:
          a: {
            pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            );
            if (null === current) throw Error(formatProdErrorMessage(387));
            props = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            $$typeof = prevState.element;
            cloneUpdateQueue(current, workInProgress2);
            processUpdateQueue(workInProgress2, props, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            props = nextState.cache;
            pushProvider(workInProgress2, CacheContext, props);
            props !== prevState.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            );
            suspendIfUpdateReadFromEntangledAsyncAction();
            props = nextState.element;
            if (prevState.isDehydrated)
              if (prevState = {
                element: props,
                isDehydrated: false,
                cache: nextState.cache
              }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  props,
                  renderLanes2
                );
                break a;
              } else if (props !== $$typeof) {
                $$typeof = createCapturedValueAtFiber(
                  Error(formatProdErrorMessage(424)),
                  workInProgress2
                );
                queueHydrationError($$typeof);
                workInProgress2 = mountHostRootWithoutHydrating(
                  current,
                  workInProgress2,
                  props,
                  renderLanes2
                );
                break a;
              } else {
                current = workInProgress2.stateNode.containerInfo;
                switch (current.nodeType) {
                  case 9:
                    current = current.body;
                    break;
                  default:
                    current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                }
                nextHydratableInstance = getNextHydratable(current.firstChild);
                hydrationParentFiber = workInProgress2;
                isHydrating = true;
                hydrationErrors = null;
                rootOrSingletonContext = true;
                renderLanes2 = mountChildFibers(
                  workInProgress2,
                  null,
                  props,
                  renderLanes2
                );
                for (workInProgress2.child = renderLanes2; renderLanes2; )
                  renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
              }
            else {
              resetHydrationState();
              if (props === $$typeof) {
                workInProgress2 = bailoutOnAlreadyFinishedWork(
                  current,
                  workInProgress2,
                  renderLanes2
                );
                break a;
              }
              reconcileChildren(current, workInProgress2, props, renderLanes2);
            }
            workInProgress2 = workInProgress2.child;
          }
          return workInProgress2;
        case 26:
          return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
            workInProgress2.type,
            null,
            workInProgress2.pendingProps,
            null
          )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, props = getOwnerDocumentFromRootContainer(
            rootInstanceStackCursor.current
          ).createElement(renderLanes2), props[internalInstanceKey] = workInProgress2, props[internalPropsKey] = current, setInitialProperties(props, renderLanes2, current), markNodeAsHoistable(props), workInProgress2.stateNode = props) : workInProgress2.memoizedState = getResource(
            workInProgress2.type,
            current.memoizedProps,
            workInProgress2.pendingProps,
            current.memoizedState
          ), null;
        case 27:
          return pushHostContext(workInProgress2), null === current && isHydrating && (props = workInProgress2.stateNode = resolveSingletonInstance(
            workInProgress2.type,
            workInProgress2.pendingProps,
            rootInstanceStackCursor.current
          ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
        case 5:
          if (null === current && isHydrating) {
            if ($$typeof = props = nextHydratableInstance)
              props = canHydrateInstance(
                props,
                workInProgress2.type,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== props ? (workInProgress2.stateNode = props, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = false, $$typeof = true) : $$typeof = false;
            $$typeof || throwOnHydrationMismatch(workInProgress2);
          }
          pushHostContext(workInProgress2);
          $$typeof = workInProgress2.type;
          prevState = workInProgress2.pendingProps;
          nextState = null !== current ? current.memoizedProps : null;
          props = prevState.children;
          shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress2.flags |= 32);
          null !== workInProgress2.memoizedState && ($$typeof = renderWithHooks(
            current,
            workInProgress2,
            TransitionAwareHostComponent,
            null,
            null,
            renderLanes2
          ), HostTransitionContext._currentValue = $$typeof);
          markRef(current, workInProgress2);
          reconcileChildren(current, workInProgress2, props, renderLanes2);
          return workInProgress2.child;
        case 6:
          if (null === current && isHydrating) {
            if (current = renderLanes2 = nextHydratableInstance)
              renderLanes2 = canHydrateTextInstance(
                renderLanes2,
                workInProgress2.pendingProps,
                rootOrSingletonContext
              ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
            current || throwOnHydrationMismatch(workInProgress2);
          }
          return null;
        case 13:
          return updateSuspenseComponent(current, workInProgress2, renderLanes2);
        case 4:
          return pushHostContainer(
            workInProgress2,
            workInProgress2.stateNode.containerInfo
          ), props = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
            workInProgress2,
            null,
            props,
            renderLanes2
          ) : reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
        case 11:
          return updateForwardRef(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 7:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps,
            renderLanes2
          ), workInProgress2.child;
        case 8:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 12:
          return reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 10:
          return props = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, props.value), reconcileChildren(current, workInProgress2, props.children, renderLanes2), workInProgress2.child;
        case 9:
          return $$typeof = workInProgress2.type._context, props = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
        case 14:
          return updateMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 15:
          return updateSimpleMemoComponent(
            current,
            workInProgress2,
            workInProgress2.type,
            workInProgress2.pendingProps,
            renderLanes2
          );
        case 19:
          return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
        case 31:
          return updateActivityComponent(current, workInProgress2, renderLanes2);
        case 22:
          return updateOffscreenComponent(
            current,
            workInProgress2,
            renderLanes2,
            workInProgress2.pendingProps
          );
        case 24:
          return prepareToReadContext(workInProgress2), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes2), $$typeof = prevState), workInProgress2.memoizedState = { parent: props, cache: $$typeof }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress2.memoizedState, $$typeof.parent !== props ? ($$typeof = { parent: props, cache: props }, workInProgress2.memoizedState = $$typeof, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = $$typeof), pushProvider(workInProgress2, CacheContext, props)) : (props = prevState.cache, pushProvider(workInProgress2, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(
            workInProgress2,
            [CacheContext],
            renderLanes2,
            true
          ))), reconcileChildren(
            current,
            workInProgress2,
            workInProgress2.pendingProps.children,
            renderLanes2
          ), workInProgress2.child;
        case 29:
          throw workInProgress2.pendingProps;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    function markUpdate(workInProgress2) {
      workInProgress2.flags |= 4;
    }
    function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
      if (type = 0 !== (workInProgress2.mode & 32)) type = false;
      if (type) {
        if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
          if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
          else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
          else
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
      } else workInProgress2.flags &= -16777217;
    }
    function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
      if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
        workInProgress2.flags &= -16777217;
      else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
        if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
        else
          throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
    }
    function scheduleRetryEffect(workInProgress2, retryQueue) {
      null !== retryQueue && (workInProgress2.flags |= 4);
      workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
    }
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!isHydrating)
        switch (renderState.tailMode) {
          case "hidden":
            hasRenderedATailFallback = renderState.tail;
            for (var lastTailNode = null; null !== hasRenderedATailFallback; )
              null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
            null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
            break;
          case "collapsed":
            lastTailNode = renderState.tail;
            for (var lastTailNode$106 = null; null !== lastTailNode; )
              null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
            null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
      if (didBailout)
        for (var child$107 = completedWork.child; null !== child$107; )
          newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
      else
        for (child$107 = completedWork.child; null !== child$107; )
          newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
      completedWork.subtreeFlags |= subtreeFlags;
      completedWork.childLanes = newChildLanes;
      return didBailout;
    }
    function completeWork(current, workInProgress2, renderLanes2) {
      var newProps = workInProgress2.pendingProps;
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return bubbleProperties(workInProgress2), null;
        case 1:
          return bubbleProperties(workInProgress2), null;
        case 3:
          renderLanes2 = workInProgress2.stateNode;
          newProps = null;
          null !== current && (newProps = current.memoizedState.cache);
          workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
          popProvider(CacheContext);
          popHostContainer();
          renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
          if (null === current || null === current.child)
            popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
          bubbleProperties(workInProgress2);
          return null;
        case 26:
          var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
          null === current ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            type,
            null,
            newProps,
            renderLanes2
          ))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            type,
            current,
            newProps,
            renderLanes2
          ));
          return null;
        case 27:
          popHostContext(workInProgress2);
          renderLanes2 = rootInstanceStackCursor.current;
          type = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            current = contextStackCursor.current;
            popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
          }
          bubbleProperties(workInProgress2);
          return null;
        case 5:
          popHostContext(workInProgress2);
          type = workInProgress2.type;
          if (null !== current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if (!newProps) {
              if (null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              bubbleProperties(workInProgress2);
              return null;
            }
            nextResource = contextStackCursor.current;
            if (popHydrationState(workInProgress2))
              prepareToHydrateHostInstance(workInProgress2, nextResource);
            else {
              var ownerDocument = getOwnerDocumentFromRootContainer(
                rootInstanceStackCursor.current
              );
              switch (nextResource) {
                case 1:
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/2000/svg",
                    type
                  );
                  break;
                case 2:
                  nextResource = ownerDocument.createElementNS(
                    "http://www.w3.org/1998/Math/MathML",
                    type
                  );
                  break;
                default:
                  switch (type) {
                    case "svg":
                      nextResource = ownerDocument.createElementNS(
                        "http://www.w3.org/2000/svg",
                        type
                      );
                      break;
                    case "math":
                      nextResource = ownerDocument.createElementNS(
                        "http://www.w3.org/1998/Math/MathML",
                        type
                      );
                      break;
                    case "script":
                      nextResource = ownerDocument.createElement("div");
                      nextResource.innerHTML = "<script><\/script>";
                      nextResource = nextResource.removeChild(
                        nextResource.firstChild
                      );
                      break;
                    case "select":
                      nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", {
                        is: newProps.is
                      }) : ownerDocument.createElement("select");
                      newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                      break;
                    default:
                      nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type, { is: newProps.is }) : ownerDocument.createElement(type);
                  }
              }
              nextResource[internalInstanceKey] = workInProgress2;
              nextResource[internalPropsKey] = newProps;
              a: for (ownerDocument = workInProgress2.child; null !== ownerDocument; ) {
                if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                  nextResource.appendChild(ownerDocument.stateNode);
                else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
                  ownerDocument.child.return = ownerDocument;
                  ownerDocument = ownerDocument.child;
                  continue;
                }
                if (ownerDocument === workInProgress2) break a;
                for (; null === ownerDocument.sibling; ) {
                  if (null === ownerDocument.return || ownerDocument.return === workInProgress2)
                    break a;
                  ownerDocument = ownerDocument.return;
                }
                ownerDocument.sibling.return = ownerDocument.return;
                ownerDocument = ownerDocument.sibling;
              }
              workInProgress2.stateNode = nextResource;
              a: switch (setInitialProperties(nextResource, type, newProps), type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  newProps = !!newProps.autoFocus;
                  break a;
                case "img":
                  newProps = true;
                  break a;
                default:
                  newProps = false;
              }
              newProps && markUpdate(workInProgress2);
            }
          }
          bubbleProperties(workInProgress2);
          preloadInstanceAndSuspendIfNeeded(
            workInProgress2,
            workInProgress2.type,
            null === current ? null : current.memoizedProps,
            workInProgress2.pendingProps,
            renderLanes2
          );
          return null;
        case 6:
          if (current && null != workInProgress2.stateNode)
            current.memoizedProps !== newProps && markUpdate(workInProgress2);
          else {
            if ("string" !== typeof newProps && null === workInProgress2.stateNode)
              throw Error(formatProdErrorMessage(166));
            current = rootInstanceStackCursor.current;
            if (popHydrationState(workInProgress2)) {
              current = workInProgress2.stateNode;
              renderLanes2 = workInProgress2.memoizedProps;
              newProps = null;
              type = hydrationParentFiber;
              if (null !== type)
                switch (type.tag) {
                  case 27:
                  case 5:
                    newProps = type.memoizedProps;
                }
              current[internalInstanceKey] = workInProgress2;
              current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
              current || throwOnHydrationMismatch(workInProgress2, true);
            } else
              current = getOwnerDocumentFromRootContainer(current).createTextNode(
                newProps
              ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
          }
          bubbleProperties(workInProgress2);
          return null;
        case 31:
          renderLanes2 = workInProgress2.memoizedState;
          if (null === current || null !== current.memoizedState) {
            newProps = popHydrationState(workInProgress2);
            if (null !== renderLanes2) {
              if (null === current) {
                if (!newProps) throw Error(formatProdErrorMessage(318));
                current = workInProgress2.memoizedState;
                current = null !== current ? current.dehydrated : null;
                if (!current) throw Error(formatProdErrorMessage(557));
                current[internalInstanceKey] = workInProgress2;
              } else
                resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
              bubbleProperties(workInProgress2);
              current = false;
            } else
              renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes2), current = true;
            if (!current) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
            if (0 !== (workInProgress2.flags & 128))
              throw Error(formatProdErrorMessage(558));
          }
          bubbleProperties(workInProgress2);
          return null;
        case 13:
          newProps = workInProgress2.memoizedState;
          if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
            type = popHydrationState(workInProgress2);
            if (null !== newProps && null !== newProps.dehydrated) {
              if (null === current) {
                if (!type) throw Error(formatProdErrorMessage(318));
                type = workInProgress2.memoizedState;
                type = null !== type ? type.dehydrated : null;
                if (!type) throw Error(formatProdErrorMessage(317));
                type[internalInstanceKey] = workInProgress2;
              } else
                resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
              bubbleProperties(workInProgress2);
              type = false;
            } else
              type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
            if (!type) {
              if (workInProgress2.flags & 256)
                return popSuspenseHandler(workInProgress2), workInProgress2;
              popSuspenseHandler(workInProgress2);
              return null;
            }
          }
          popSuspenseHandler(workInProgress2);
          if (0 !== (workInProgress2.flags & 128))
            return workInProgress2.lanes = renderLanes2, workInProgress2;
          renderLanes2 = null !== newProps;
          current = null !== current && null !== current.memoizedState;
          renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
          renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
          scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
          bubbleProperties(workInProgress2);
          return null;
        case 4:
          return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
        case 10:
          return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
        case 19:
          pop(suspenseStackCursor);
          newProps = workInProgress2.memoizedState;
          if (null === newProps) return bubbleProperties(workInProgress2), null;
          type = 0 !== (workInProgress2.flags & 128);
          nextResource = newProps.rendering;
          if (null === nextResource)
            if (type) cutOffTailIfNeeded(newProps, false);
            else {
              if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                for (current = workInProgress2.child; null !== current; ) {
                  nextResource = findFirstSuspended(current);
                  if (null !== nextResource) {
                    workInProgress2.flags |= 128;
                    cutOffTailIfNeeded(newProps, false);
                    current = nextResource.updateQueue;
                    workInProgress2.updateQueue = current;
                    scheduleRetryEffect(workInProgress2, current);
                    workInProgress2.subtreeFlags = 0;
                    current = renderLanes2;
                    for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                      resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                    push(
                      suspenseStackCursor,
                      suspenseStackCursor.current & 1 | 2
                    );
                    isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                    return workInProgress2.child;
                  }
                  current = current.sibling;
                }
              null !== newProps.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            }
          else {
            if (!type)
              if (current = findFirstSuspended(nextResource), null !== current) {
                if (workInProgress2.flags |= 128, type = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                  return bubbleProperties(workInProgress2), null;
              } else
                2 * now() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
            newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
          }
          if (null !== newProps.tail)
            return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now(), current.sibling = null, renderLanes2 = suspenseStackCursor.current, push(
              suspenseStackCursor,
              type ? renderLanes2 & 1 | 2 : renderLanes2 & 1
            ), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current;
          bubbleProperties(workInProgress2);
          return null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
        case 24:
          return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(formatProdErrorMessage(156, workInProgress2.tag));
    }
    function unwindWork(current, workInProgress2) {
      popTreeContext(workInProgress2);
      switch (workInProgress2.tag) {
        case 1:
          return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 3:
          return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 26:
        case 27:
        case 5:
          return popHostContext(workInProgress2), null;
        case 31:
          if (null !== workInProgress2.memoizedState) {
            popSuspenseHandler(workInProgress2);
            if (null === workInProgress2.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress2.flags;
          return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 13:
          popSuspenseHandler(workInProgress2);
          current = workInProgress2.memoizedState;
          if (null !== current && null !== current.dehydrated) {
            if (null === workInProgress2.alternate)
              throw Error(formatProdErrorMessage(340));
            resetHydrationState();
          }
          current = workInProgress2.flags;
          return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 19:
          return pop(suspenseStackCursor), null;
        case 4:
          return popHostContainer(), null;
        case 10:
          return popProvider(workInProgress2.type), null;
        case 22:
        case 23:
          return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
        case 24:
          return popProvider(CacheContext), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current, interruptedWork) {
      popTreeContext(interruptedWork);
      switch (interruptedWork.tag) {
        case 3:
          popProvider(CacheContext);
          popHostContainer();
          break;
        case 26:
        case 27:
        case 5:
          popHostContext(interruptedWork);
          break;
        case 4:
          popHostContainer();
          break;
        case 31:
          null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
          break;
        case 13:
          popSuspenseHandler(interruptedWork);
          break;
        case 19:
          pop(suspenseStackCursor);
          break;
        case 10:
          popProvider(interruptedWork.type);
          break;
        case 22:
        case 23:
          popSuspenseHandler(interruptedWork);
          popHiddenContext();
          null !== current && pop(resumedCache);
          break;
        case 24:
          popProvider(CacheContext);
      }
    }
    function commitHookEffectListMount(flags, finishedWork) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              lastEffect = void 0;
              var create = updateQueue.create, inst = updateQueue.inst;
              lastEffect = create();
              inst.destroy = lastEffect;
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
      try {
        var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
        if (null !== lastEffect) {
          var firstEffect = lastEffect.next;
          updateQueue = firstEffect;
          do {
            if ((updateQueue.tag & flags) === flags) {
              var inst = updateQueue.inst, destroy = inst.destroy;
              if (void 0 !== destroy) {
                inst.destroy = void 0;
                lastEffect = finishedWork;
                var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                try {
                  destroy_();
                } catch (error) {
                  captureCommitPhaseError(
                    lastEffect,
                    nearestMountedAncestor,
                    error
                  );
                }
              }
            }
            updateQueue = updateQueue.next;
          } while (updateQueue !== firstEffect);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitClassCallbacks(finishedWork) {
      var updateQueue = finishedWork.updateQueue;
      if (null !== updateQueue) {
        var instance = finishedWork.stateNode;
        try {
          commitCallbacks(updateQueue, instance);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
      instance.props = resolveClassComponentProps(
        current.type,
        current.memoizedProps
      );
      instance.state = current.memoizedState;
      try {
        instance.componentWillUnmount();
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyAttachRef(current, nearestMountedAncestor) {
      try {
        var ref = current.ref;
        if (null !== ref) {
          switch (current.tag) {
            case 26:
            case 27:
            case 5:
              var instanceToUse = current.stateNode;
              break;
            case 30:
              instanceToUse = current.stateNode;
              break;
            default:
              instanceToUse = current.stateNode;
          }
          "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
        }
      } catch (error) {
        captureCommitPhaseError(current, nearestMountedAncestor, error);
      }
    }
    function safelyDetachRef(current, nearestMountedAncestor) {
      var ref = current.ref, refCleanup = current.refCleanup;
      if (null !== ref)
        if ("function" === typeof refCleanup)
          try {
            refCleanup();
          } catch (error) {
            captureCommitPhaseError(current, nearestMountedAncestor, error);
          } finally {
            current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
          }
        else if ("function" === typeof ref)
          try {
            ref(null);
          } catch (error$140) {
            captureCommitPhaseError(current, nearestMountedAncestor, error$140);
          }
        else ref.current = null;
    }
    function commitHostMount(finishedWork) {
      var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
      try {
        a: switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            props.autoFocus && instance.focus();
            break a;
          case "img":
            props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function commitHostUpdate(finishedWork, newProps, oldProps) {
      try {
        var domElement = finishedWork.stateNode;
        updateProperties(domElement, finishedWork.type, oldProps, newProps);
        domElement[internalPropsKey] = newProps;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    function isHostParent(fiber) {
      return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
    }
    function getHostSibling(fiber) {
      a: for (; ; ) {
        for (; null === fiber.sibling; ) {
          if (null === fiber.return || isHostParent(fiber.return)) return null;
          fiber = fiber.return;
        }
        fiber.sibling.return = fiber.return;
        for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
          if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
          if (fiber.flags & 2) continue a;
          if (null === fiber.child || 4 === fiber.tag) continue a;
          else fiber.child.return = fiber, fiber = fiber.child;
        }
        if (!(fiber.flags & 2)) return fiber.stateNode;
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
      else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
        for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
          insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
    }
    function insertOrAppendPlacementNode(node, before, parent) {
      var tag = node.tag;
      if (5 === tag || 6 === tag)
        node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
      else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
        for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
          insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
    }
    function commitHostSingletonAcquisition(finishedWork) {
      var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
      try {
        for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
          singleton.removeAttributeNode(attributes[0]);
        setInitialProperties(singleton, type, props);
        singleton[internalInstanceKey] = finishedWork;
        singleton[internalPropsKey] = props;
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
    var offscreenSubtreeIsHidden = false;
    var offscreenSubtreeWasHidden = false;
    var needsFormReset = false;
    var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
    var nextEffect = null;
    function commitBeforeMutationEffects(root2, firstChild) {
      root2 = root2.containerInfo;
      eventsEnabled = _enabled;
      root2 = getActiveElementDeep(root2);
      if (hasSelectionCapabilities(root2)) {
        if ("selectionStart" in root2)
          var JSCompiler_temp = {
            start: root2.selectionStart,
            end: root2.selectionEnd
          };
        else
          a: {
            JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
            var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
            if (selection && 0 !== selection.rangeCount) {
              JSCompiler_temp = selection.anchorNode;
              var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
              selection = selection.focusOffset;
              try {
                JSCompiler_temp.nodeType, focusNode.nodeType;
              } catch (e$20) {
                JSCompiler_temp = null;
                break a;
              }
              var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
              b: for (; ; ) {
                for (var next; ; ) {
                  node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                  node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                  3 === node.nodeType && (length += node.nodeValue.length);
                  if (null === (next = node.firstChild)) break;
                  parentNode = node;
                  node = next;
                }
                for (; ; ) {
                  if (node === root2) break b;
                  parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                  parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                  if (null !== (next = node.nextSibling)) break;
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
              JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
            } else JSCompiler_temp = null;
          }
        JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
      } else JSCompiler_temp = null;
      selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
      _enabled = false;
      for (nextEffect = firstChild; null !== nextEffect; )
        if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
          root2.return = firstChild, nextEffect = root2;
        else
          for (; null !== nextEffect; ) {
            firstChild = nextEffect;
            focusNode = firstChild.alternate;
            root2 = firstChild.flags;
            switch (firstChild.tag) {
              case 0:
                if (0 !== (root2 & 4) && (root2 = firstChild.updateQueue, root2 = null !== root2 ? root2.events : null, null !== root2))
                  for (JSCompiler_temp = 0; JSCompiler_temp < root2.length; JSCompiler_temp++)
                    anchorOffset = root2[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
                break;
              case 11:
              case 15:
                break;
              case 1:
                if (0 !== (root2 & 1024) && null !== focusNode) {
                  root2 = void 0;
                  JSCompiler_temp = firstChild;
                  anchorOffset = focusNode.memoizedProps;
                  focusNode = focusNode.memoizedState;
                  selection = JSCompiler_temp.stateNode;
                  try {
                    var resolvedPrevProps = resolveClassComponentProps(
                      JSCompiler_temp.type,
                      anchorOffset
                    );
                    root2 = selection.getSnapshotBeforeUpdate(
                      resolvedPrevProps,
                      focusNode
                    );
                    selection.__reactInternalSnapshotBeforeUpdate = root2;
                  } catch (error) {
                    captureCommitPhaseError(
                      JSCompiler_temp,
                      JSCompiler_temp.return,
                      error
                    );
                  }
                }
                break;
              case 3:
                if (0 !== (root2 & 1024)) {
                  if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                    clearContainerSparingly(root2);
                  else if (1 === JSCompiler_temp)
                    switch (root2.nodeName) {
                      case "HEAD":
                      case "HTML":
                      case "BODY":
                        clearContainerSparingly(root2);
                        break;
                      default:
                        root2.textContent = "";
                    }
                }
                break;
              case 5:
              case 26:
              case 27:
              case 6:
              case 4:
              case 17:
                break;
              default:
                if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
            }
            root2 = firstChild.sibling;
            if (null !== root2) {
              root2.return = firstChild.return;
              nextEffect = root2;
              break;
            }
            nextEffect = firstChild.return;
          }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitHookEffectListMount(5, finishedWork);
          break;
        case 1:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 4)
            if (finishedRoot = finishedWork.stateNode, null === current)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            else {
              var prevProps = resolveClassComponentProps(
                finishedWork.type,
                current.memoizedProps
              );
              current = current.memoizedState;
              try {
                finishedRoot.componentDidUpdate(
                  prevProps,
                  current,
                  finishedRoot.__reactInternalSnapshotBeforeUpdate
                );
              } catch (error$139) {
                captureCommitPhaseError(
                  finishedWork,
                  finishedWork.return,
                  error$139
                );
              }
            }
          flags & 64 && commitClassCallbacks(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
            current = null;
            if (null !== finishedWork.child)
              switch (finishedWork.child.tag) {
                case 27:
                case 5:
                  current = finishedWork.child.stateNode;
                  break;
                case 1:
                  current = finishedWork.child.stateNode;
              }
            try {
              commitCallbacks(finishedRoot, current);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 27:
          null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          null === current && flags & 4 && commitHostMount(finishedWork);
          flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          break;
        case 31:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
            null,
            finishedWork
          ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
          break;
        case 22:
          flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
          if (!flags) {
            current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
            prevProps = offscreenSubtreeIsHidden;
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = flags;
            (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              0 !== (finishedWork.subtreeFlags & 8772)
            ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            offscreenSubtreeIsHidden = prevProps;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          }
          break;
        case 30:
          break;
        default:
          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
      }
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      fiber.child = null;
      fiber.deletions = null;
      fiber.sibling = null;
      5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
      fiber.stateNode = null;
      fiber.return = null;
      fiber.dependencies = null;
      fiber.memoizedProps = null;
      fiber.memoizedState = null;
      fiber.pendingProps = null;
      fiber.stateNode = null;
      fiber.updateQueue = null;
    }
    var hostParent = null;
    var hostParentIsContainer = false;
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (parent = parent.child; null !== parent; )
        commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
        try {
          injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
        } catch (err) {
        }
      switch (deletedFiber.tag) {
        case 26:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
          break;
        case 27:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
          isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          releaseSingletonInstance(deletedFiber.stateNode);
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 5:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case 6:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = null;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          if (null !== hostParent)
            if (hostParentIsContainer)
              try {
                (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
            else
              try {
                hostParent.removeChild(deletedFiber.stateNode);
              } catch (error) {
                captureCommitPhaseError(
                  deletedFiber,
                  nearestMountedAncestor,
                  error
                );
              }
          break;
        case 18:
          null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
            9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
            deletedFiber.stateNode
          ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
          break;
        case 4:
          prevHostParent = hostParent;
          prevHostParentIsContainer = hostParentIsContainer;
          hostParent = deletedFiber.stateNode.containerInfo;
          hostParentIsContainer = true;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          hostParent = prevHostParent;
          hostParentIsContainer = prevHostParentIsContainer;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
          offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 1:
          offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
            deletedFiber,
            nearestMountedAncestor,
            prevHostParent
          ));
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 21:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          break;
        case 22:
          offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
          offscreenSubtreeWasHidden = prevHostParent;
          break;
        default:
          recursivelyTraverseDeletionEffects(
            finishedRoot,
            nearestMountedAncestor,
            deletedFiber
          );
      }
    }
    function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
        finishedRoot = finishedRoot.dehydrated;
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
        try {
          retryIfBlockedOn(finishedRoot);
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
    }
    function getRetryCache(finishedWork) {
      switch (finishedWork.tag) {
        case 31:
        case 13:
        case 19:
          var retryCache = finishedWork.stateNode;
          null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
          return retryCache;
        case 22:
          return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
        default:
          throw Error(formatProdErrorMessage(435, finishedWork.tag));
      }
    }
    function attachSuspenseRetryListeners(finishedWork, wakeables) {
      var retryCache = getRetryCache(finishedWork);
      wakeables.forEach(function(wakeable) {
        if (!retryCache.has(wakeable)) {
          retryCache.add(wakeable);
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          wakeable.then(retry, retry);
        }
      });
    }
    function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
      var deletions = parentFiber.deletions;
      if (null !== deletions)
        for (var i = 0; i < deletions.length; i++) {
          var childToDelete = deletions[i], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
          a: for (; null !== parent; ) {
            switch (parent.tag) {
              case 27:
                if (isSingletonScope(parent.type)) {
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                }
                break;
              case 5:
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break a;
              case 3:
              case 4:
                hostParent = parent.stateNode.containerInfo;
                hostParentIsContainer = true;
                break a;
            }
            parent = parent.return;
          }
          if (null === hostParent) throw Error(formatProdErrorMessage(160));
          commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
          hostParent = null;
          hostParentIsContainer = false;
          root2 = childToDelete.alternate;
          null !== root2 && (root2.return = null);
          childToDelete.return = null;
        }
      if (parentFiber.subtreeFlags & 13886)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
    }
    var currentHoistableRoot = null;
    function commitMutationEffectsOnFiber(finishedWork, root2) {
      var current = finishedWork.alternate, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
          break;
        case 1:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
          break;
        case 26:
          var hoistableRoot = currentHoistableRoot;
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (flags & 4) {
            var currentResource = null !== current ? current.memoizedState : null;
            flags = finishedWork.memoizedState;
            if (null === current)
              if (null === flags)
                if (null === finishedWork.stateNode) {
                  a: {
                    flags = finishedWork.type;
                    current = finishedWork.memoizedProps;
                    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                    b: switch (flags) {
                      case "title":
                        currentResource = hoistableRoot.getElementsByTagName("title")[0];
                        if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                          currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                            currentResource,
                            hoistableRoot.querySelector("head > title")
                          );
                        setInitialProperties(currentResource, flags, current);
                        currentResource[internalInstanceKey] = finishedWork;
                        markNodeAsHoistable(currentResource);
                        flags = currentResource;
                        break a;
                      case "link":
                        var maybeNodes = getHydratableHoistableCache(
                          "link",
                          "href",
                          hoistableRoot
                        ).get(flags + (current.href || ""));
                        if (maybeNodes) {
                          for (var i = 0; i < maybeNodes.length; i++)
                            if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      case "meta":
                        if (maybeNodes = getHydratableHoistableCache(
                          "meta",
                          "content",
                          hoistableRoot
                        ).get(flags + (current.content || ""))) {
                          for (i = 0; i < maybeNodes.length; i++)
                            if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                              maybeNodes.splice(i, 1);
                              break b;
                            }
                        }
                        currentResource = hoistableRoot.createElement(flags);
                        setInitialProperties(currentResource, flags, current);
                        hoistableRoot.head.appendChild(currentResource);
                        break;
                      default:
                        throw Error(formatProdErrorMessage(468, flags));
                    }
                    currentResource[internalInstanceKey] = finishedWork;
                    markNodeAsHoistable(currentResource);
                    flags = currentResource;
                  }
                  finishedWork.stateNode = flags;
                } else
                  mountHoistable(
                    hoistableRoot,
                    finishedWork.type,
                    finishedWork.stateNode
                  );
              else
                finishedWork.stateNode = acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                );
            else
              currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                hoistableRoot,
                finishedWork.type,
                finishedWork.stateNode
              ) : acquireResource(
                hoistableRoot,
                flags,
                finishedWork.memoizedProps
              )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                finishedWork,
                finishedWork.memoizedProps,
                current.memoizedProps
              );
          }
          break;
        case 27:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          null !== current && flags & 4 && commitHostUpdate(
            finishedWork,
            finishedWork.memoizedProps,
            current.memoizedProps
          );
          break;
        case 5:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
          if (finishedWork.flags & 32) {
            hoistableRoot = finishedWork.stateNode;
            try {
              setTextContent(hoistableRoot, "");
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
            finishedWork,
            hoistableRoot,
            null !== current ? current.memoizedProps : hoistableRoot
          ));
          flags & 1024 && (needsFormReset = true);
          break;
        case 6:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          if (flags & 4) {
            if (null === finishedWork.stateNode)
              throw Error(formatProdErrorMessage(162));
            flags = finishedWork.memoizedProps;
            current = finishedWork.stateNode;
            try {
              current.nodeValue = flags;
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          }
          break;
        case 3:
          tagCaches = null;
          hoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(root2.containerInfo);
          recursivelyTraverseMutationEffects(root2, finishedWork);
          currentHoistableRoot = hoistableRoot;
          commitReconciliationEffects(finishedWork);
          if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
            try {
              retryIfBlockedOn(root2.containerInfo);
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
          break;
        case 4:
          flags = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(
            finishedWork.stateNode.containerInfo
          );
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          currentHoistableRoot = flags;
          break;
        case 12:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          break;
        case 31:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 13:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 22:
          hoistableRoot = null !== finishedWork.memoizedState;
          var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
          recursivelyTraverseMutationEffects(root2, finishedWork);
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
          commitReconciliationEffects(finishedWork);
          if (flags & 8192)
            a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
              if (5 === root2.tag || 26 === root2.tag) {
                if (null === current) {
                  wasHidden = current = root2;
                  try {
                    if (currentResource = wasHidden.stateNode, hoistableRoot)
                      maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                    else {
                      i = wasHidden.stateNode;
                      var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                      i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                    }
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (6 === root2.tag) {
                if (null === current) {
                  wasHidden = root2;
                  try {
                    wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if (18 === root2.tag) {
                if (null === current) {
                  wasHidden = root2;
                  try {
                    var instance = wasHidden.stateNode;
                    hoistableRoot ? hideOrUnhideDehydratedBoundary(instance, true) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, false);
                  } catch (error) {
                    captureCommitPhaseError(wasHidden, wasHidden.return, error);
                  }
                }
              } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
                root2.child.return = root2;
                root2 = root2.child;
                continue;
              }
              if (root2 === finishedWork) break a;
              for (; null === root2.sibling; ) {
                if (null === root2.return || root2.return === finishedWork) break a;
                current === root2 && (current = null);
                root2 = root2.return;
              }
              current === root2 && (current = null);
              root2.sibling.return = root2.return;
              root2 = root2.sibling;
            }
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
          break;
        case 19:
          recursivelyTraverseMutationEffects(root2, finishedWork);
          commitReconciliationEffects(finishedWork);
          flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
      }
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & 2) {
        try {
          for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
            if (isHostParent(parentFiber)) {
              hostParentFiber = parentFiber;
              break;
            }
            parentFiber = parentFiber.return;
          }
          if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
          switch (hostParentFiber.tag) {
            case 27:
              var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before, parent);
              break;
            case 5:
              var parent$141 = hostParentFiber.stateNode;
              hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
              var before$142 = getHostSibling(finishedWork);
              insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
              break;
            case 3:
            case 4:
              var parent$143 = hostParentFiber.stateNode.containerInfo, before$144 = getHostSibling(finishedWork);
              insertOrAppendPlacementNodeIntoContainer(
                finishedWork,
                before$144,
                parent$143
              );
              break;
            default:
              throw Error(formatProdErrorMessage(161));
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
        finishedWork.flags &= -3;
      }
      flags & 4096 && (finishedWork.flags &= -4097);
    }
    function recursivelyResetForms(parentFiber) {
      if (parentFiber.subtreeFlags & 1024)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var fiber = parentFiber;
          recursivelyResetForms(fiber);
          5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
          parentFiber = parentFiber.sibling;
        }
    }
    function recursivelyTraverseLayoutEffects(root2, parentFiber) {
      if (parentFiber.subtreeFlags & 8772)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
    }
    function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedWork = parentFiber;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 1:
            safelyDetachRef(finishedWork, finishedWork.return);
            var instance = finishedWork.stateNode;
            "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
              finishedWork,
              finishedWork.return,
              instance
            );
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 27:
            releaseSingletonInstance(finishedWork.stateNode);
          case 26:
          case 5:
            safelyDetachRef(finishedWork, finishedWork.return);
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          case 30:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
            break;
          default:
            recursivelyTraverseDisappearLayoutEffects(finishedWork);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(4, finishedWork);
            break;
          case 1:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            current = finishedWork;
            finishedRoot = current.stateNode;
            if ("function" === typeof finishedRoot.componentDidMount)
              try {
                finishedRoot.componentDidMount();
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            current = finishedWork;
            finishedRoot = current.updateQueue;
            if (null !== finishedRoot) {
              var instance = current.stateNode;
              try {
                var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                if (null !== hiddenCallbacks)
                  for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                    callCallback(hiddenCallbacks[finishedRoot], instance);
              } catch (error) {
                captureCommitPhaseError(current, current.return, error);
              }
            }
            includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 27:
            commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            break;
          case 31:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            break;
          case 22:
            null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
            safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 30:
            break;
          default:
            recursivelyTraverseReappearLayoutEffects(
              finishedRoot,
              finishedWork,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitOffscreenPassiveMountEffects(current, finishedWork) {
      var previousCache = null;
      null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
      current = null;
      null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
      current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
    }
    function commitCachePassiveMountEffect(current, finishedWork) {
      current = null;
      null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
      finishedWork = finishedWork.memoizedState.cache;
      finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
    }
    function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveMountOnFiber(
            root2,
            parentFiber,
            committedLanes,
            committedTransitions
          ), parentFiber = parentFiber.sibling;
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
      var flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitHookEffectListMount(9, finishedWork);
          break;
        case 1:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 3:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
          break;
        case 12:
          if (flags & 2048) {
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            finishedRoot = finishedWork.stateNode;
            try {
              var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
              "function" === typeof onPostCommit && onPostCommit(
                id,
                null === finishedWork.alternate ? "mount" : "update",
                finishedRoot.passiveEffectDuration,
                -0
              );
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          } else
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
          break;
        case 31:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 13:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          break;
        case 23:
          break;
        case 22:
          _finishedWork$memoize2 = finishedWork.stateNode;
          id = finishedWork.alternate;
          null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            0 !== (finishedWork.subtreeFlags & 10256) || false
          ));
          flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
          break;
        case 24:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
      }
    }
    function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
      includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || false);
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            commitHookEffectListMount(8, finishedWork);
            break;
          case 23:
            break;
          case 22:
            var instance = finishedWork.stateNode;
            null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ) : recursivelyTraverseAtomicPassiveEffects(
              finishedRoot,
              finishedWork
            ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            ));
            includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
            break;
          case 24:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
            includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              includeWorkInProgressEffects
            );
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 22:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
              flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
    }
    var suspenseyCommitFlag = 8192;
    function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
      if (parentFiber.subtreeFlags & suspenseyCommitFlag)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          accumulateSuspenseyCommitOnFiber(
            parentFiber,
            committedLanes,
            suspendedState
          ), parentFiber = parentFiber.sibling;
    }
    function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
      switch (fiber.tag) {
        case 26:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
            suspendedState,
            currentHoistableRoot,
            fiber.memoizedState,
            fiber.memoizedProps
          );
          break;
        case 5:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          break;
        case 3:
        case 4:
          var previousHoistableRoot = currentHoistableRoot;
          currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
          currentHoistableRoot = previousHoistableRoot;
          break;
        case 22:
          null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          ));
          break;
        default:
          recursivelyAccumulateSuspenseyCommit(
            fiber,
            committedLanes,
            suspendedState
          );
      }
    }
    function detachAlternateSiblings(parentFiber) {
      var previousFiber = parentFiber.alternate;
      if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
        previousFiber.child = null;
        do
          previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
        while (null !== parentFiber);
      }
    }
    function recursivelyTraversePassiveUnmountEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      if (parentFiber.subtreeFlags & 10256)
        for (parentFiber = parentFiber.child; null !== parentFiber; )
          commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
          break;
        case 3:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 12:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        case 22:
          var instance = finishedWork.stateNode;
          null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
          break;
        default:
          recursivelyTraversePassiveUnmountEffects(finishedWork);
      }
    }
    function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
      var deletions = parentFiber.deletions;
      if (0 !== (parentFiber.flags & 16)) {
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i];
            nextEffect = childToDelete;
            commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
              childToDelete,
              parentFiber
            );
          }
        detachAlternateSiblings(parentFiber);
      }
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        deletions = parentFiber;
        switch (deletions.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, deletions, deletions.return);
            recursivelyTraverseDisconnectPassiveEffects(deletions);
            break;
          case 22:
            i = deletions.stateNode;
            i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
            break;
          default:
            recursivelyTraverseDisconnectPassiveEffects(deletions);
        }
        parentFiber = parentFiber.sibling;
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
      for (; null !== nextEffect; ) {
        var fiber = nextEffect;
        switch (fiber.tag) {
          case 0:
          case 11:
          case 15:
            commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
            break;
          case 23:
          case 22:
            if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
              var cache = fiber.memoizedState.cachePool.pool;
              null != cache && cache.refCount++;
            }
            break;
          case 24:
            releaseCache(fiber.memoizedState.cache);
        }
        cache = fiber.child;
        if (null !== cache) cache.return = fiber, nextEffect = cache;
        else
          a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
            cache = nextEffect;
            var sibling = cache.sibling, returnFiber = cache.return;
            detachFiberAfterEffects(cache);
            if (cache === fiber) {
              nextEffect = null;
              break a;
            }
            if (null !== sibling) {
              sibling.return = returnFiber;
              nextEffect = sibling;
              break a;
            }
            nextEffect = returnFiber;
          }
      }
    }
    var DefaultAsyncDispatcher = {
      getCacheForType: function(resourceType) {
        var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
        void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
        return cacheForType;
      },
      cacheSignal: function() {
        return readContext(CacheContext).controller.signal;
      }
    };
    var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
    var executionContext = 0;
    var workInProgressRoot = null;
    var workInProgress = null;
    var workInProgressRootRenderLanes = 0;
    var workInProgressSuspendedReason = 0;
    var workInProgressThrownValue = null;
    var workInProgressRootDidSkipSuspendedSiblings = false;
    var workInProgressRootIsPrerendering = false;
    var workInProgressRootDidAttachPingListener = false;
    var entangledRenderLanes = 0;
    var workInProgressRootExitStatus = 0;
    var workInProgressRootSkippedLanes = 0;
    var workInProgressRootInterleavedUpdatedLanes = 0;
    var workInProgressRootPingedLanes = 0;
    var workInProgressDeferredLane = 0;
    var workInProgressSuspendedRetryLanes = 0;
    var workInProgressRootConcurrentErrors = null;
    var workInProgressRootRecoverableErrors = null;
    var workInProgressRootDidIncludeRecursiveRenderUpdate = false;
    var globalMostRecentFallbackTime = 0;
    var globalMostRecentTransitionTime = 0;
    var workInProgressRootRenderTargetTime = Infinity;
    var workInProgressTransitions = null;
    var legacyErrorBoundariesThatAlreadyFailed = null;
    var pendingEffectsStatus = 0;
    var pendingEffectsRoot = null;
    var pendingFinishedWork = null;
    var pendingEffectsLanes = 0;
    var pendingEffectsRemainingLanes = 0;
    var pendingPassiveTransitions = null;
    var pendingRecoverableErrors = null;
    var nestedUpdateCount = 0;
    var rootWithNestedUpdates = null;
    function requestUpdateLane() {
      return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
    }
    function requestDeferredLane() {
      if (0 === workInProgressDeferredLane)
        if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
          var lane = nextTransitionDeferredLane;
          nextTransitionDeferredLane <<= 1;
          0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
          workInProgressDeferredLane = lane;
        } else workInProgressDeferredLane = 536870912;
      lane = suspenseHandlerStackCursor.current;
      null !== lane && (lane.flags |= 32);
      return workInProgressDeferredLane;
    }
    function scheduleUpdateOnFiber(root2, fiber, lane) {
      if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
        prepareFreshStack(root2, 0), markRootSuspended(
          root2,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      markRootUpdated$1(root2, lane);
      if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
        root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
          root2,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        )), ensureRootIsScheduled(root2);
    }
    function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
      do {
        if (0 === exitStatus) {
          workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
          break;
        } else {
          forceSync = root$jscomp$0.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
            exitStatus = renderRootSync(root$jscomp$0, lanes, false);
            renderWasConcurrent = false;
            continue;
          }
          if (2 === exitStatus) {
            renderWasConcurrent = lanes;
            if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
              var JSCompiler_inline_result = 0;
            else
              JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
            if (0 !== JSCompiler_inline_result) {
              lanes = JSCompiler_inline_result;
              a: {
                var root2 = root$jscomp$0;
                exitStatus = workInProgressRootConcurrentErrors;
                var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
                wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
                JSCompiler_inline_result = renderRootSync(
                  root2,
                  JSCompiler_inline_result,
                  false
                );
                if (2 !== JSCompiler_inline_result) {
                  if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                    root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                    workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                    exitStatus = 4;
                    break a;
                  }
                  renderWasConcurrent = workInProgressRootRecoverableErrors;
                  workInProgressRootRecoverableErrors = exitStatus;
                  null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                    workInProgressRootRecoverableErrors,
                    renderWasConcurrent
                  ));
                }
                exitStatus = JSCompiler_inline_result;
              }
              renderWasConcurrent = false;
              if (2 !== exitStatus) continue;
            }
          }
          if (1 === exitStatus) {
            prepareFreshStack(root$jscomp$0, 0);
            markRootSuspended(root$jscomp$0, lanes, 0, true);
            break;
          }
          a: {
            shouldTimeSlice = root$jscomp$0;
            renderWasConcurrent = exitStatus;
            switch (renderWasConcurrent) {
              case 0:
              case 1:
                throw Error(formatProdErrorMessage(345));
              case 4:
                if ((lanes & 4194048) !== lanes) break;
              case 6:
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                break a;
              case 2:
                workInProgressRootRecoverableErrors = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(formatProdErrorMessage(329));
            }
            if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
              markRootSuspended(
                shouldTimeSlice,
                lanes,
                workInProgressDeferredLane,
                !workInProgressRootDidSkipSuspendedSiblings
              );
              if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
              pendingEffectsLanes = lanes;
              shouldTimeSlice.timeoutHandle = scheduleTimeout(
                commitRootWhenReady.bind(
                  null,
                  shouldTimeSlice,
                  forceSync,
                  workInProgressRootRecoverableErrors,
                  workInProgressTransitions,
                  workInProgressRootDidIncludeRecursiveRenderUpdate,
                  lanes,
                  workInProgressDeferredLane,
                  workInProgressRootInterleavedUpdatedLanes,
                  workInProgressSuspendedRetryLanes,
                  workInProgressRootDidSkipSuspendedSiblings,
                  renderWasConcurrent,
                  "Throttled",
                  -0,
                  0
                ),
                exitStatus
              );
              break a;
            }
            commitRootWhenReady(
              shouldTimeSlice,
              forceSync,
              workInProgressRootRecoverableErrors,
              workInProgressTransitions,
              workInProgressRootDidIncludeRecursiveRenderUpdate,
              lanes,
              workInProgressDeferredLane,
              workInProgressRootInterleavedUpdatedLanes,
              workInProgressSuspendedRetryLanes,
              workInProgressRootDidSkipSuspendedSiblings,
              renderWasConcurrent,
              null,
              -0,
              0
            );
          }
        }
        break;
      } while (1);
      ensureRootIsScheduled(root$jscomp$0);
    }
    function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
      root2.timeoutHandle = -1;
      suspendedCommitReason = finishedWork.subtreeFlags;
      if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
        suspendedCommitReason = {
          stylesheets: null,
          count: 0,
          imgCount: 0,
          imgBytes: 0,
          suspenseyImages: [],
          waitingForImages: true,
          waitingForViewTransition: false,
          unsuspend: noop$1
        };
        accumulateSuspenseyCommitOnFiber(
          finishedWork,
          lanes,
          suspendedCommitReason
        );
        var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now() : 0;
        timeoutOffset = waitForCommitToBeReady(
          suspendedCommitReason,
          timeoutOffset
        );
        if (null !== timeoutOffset) {
          pendingEffectsLanes = lanes;
          root2.cancelPendingCommit = timeoutOffset(
            commitRoot.bind(
              null,
              root2,
              finishedWork,
              lanes,
              recoverableErrors,
              transitions,
              didIncludeRenderPhaseUpdate,
              spawnedLane,
              updatedLanes,
              suspendedRetryLanes,
              exitStatus,
              suspendedCommitReason,
              null,
              completedRenderStartTime,
              completedRenderEndTime
            )
          );
          markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
          return;
        }
      }
      commitRoot(
        root2,
        finishedWork,
        lanes,
        recoverableErrors,
        transitions,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      );
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node = finishedWork; ; ) {
        var tag = node.tag;
        if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
          for (var i = 0; i < tag.length; i++) {
            var check = tag[i], getSnapshot = check.getSnapshot;
            check = check.value;
            try {
              if (!objectIs(getSnapshot(), check)) return false;
            } catch (error) {
              return false;
            }
          }
        tag = node.child;
        if (node.subtreeFlags & 16384 && null !== tag)
          tag.return = node, node = tag;
        else {
          if (node === finishedWork) break;
          for (; null === node.sibling; ) {
            if (null === node.return || node.return === finishedWork) return true;
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      return true;
    }
    function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
      suspendedLanes &= ~workInProgressRootPingedLanes;
      suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
      root2.suspendedLanes |= suspendedLanes;
      root2.pingedLanes &= ~suspendedLanes;
      didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
      didAttemptEntireTree = root2.expirationTimes;
      for (var lanes = suspendedLanes; 0 < lanes; ) {
        var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
        didAttemptEntireTree[index$6] = -1;
        lanes &= ~lane;
      }
      0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
    }
    function flushSyncWork$1() {
      return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
    }
    function resetWorkInProgressStack() {
      if (null !== workInProgress) {
        if (0 === workInProgressSuspendedReason)
          var interruptedWork = workInProgress.return;
        else
          interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
        for (; null !== interruptedWork; )
          unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
        workInProgress = null;
      }
    }
    function prepareFreshStack(root2, lanes) {
      var timeoutHandle = root2.timeoutHandle;
      -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
      timeoutHandle = root2.cancelPendingCommit;
      null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
      pendingEffectsLanes = 0;
      resetWorkInProgressStack();
      workInProgressRoot = root2;
      workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
      workInProgressRootRenderLanes = lanes;
      workInProgressSuspendedReason = 0;
      workInProgressThrownValue = null;
      workInProgressRootDidSkipSuspendedSiblings = false;
      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
      workInProgressRootDidAttachPingListener = false;
      workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
      workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
      workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      0 !== (lanes & 8) && (lanes |= lanes & 32);
      var allEntangledLanes = root2.entangledLanes;
      if (0 !== allEntangledLanes)
        for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
          var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
          lanes |= root2[index$4];
          allEntangledLanes &= ~lane;
        }
      entangledRenderLanes = lanes;
      finishQueueingConcurrentUpdates();
      return timeoutHandle;
    }
    function handleThrow(root2, thrownValue) {
      currentlyRenderingFiber = null;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
      workInProgressThrownValue = thrownValue;
      null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
        root2,
        createCapturedValueAtFiber(thrownValue, root2.current)
      ));
    }
    function shouldRemainOnPreviousScreen() {
      var handler = suspenseHandlerStackCursor.current;
      return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
    }
    function pushDispatcher() {
      var prevDispatcher = ReactSharedInternals.H;
      ReactSharedInternals.H = ContextOnlyDispatcher;
      return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
    }
    function pushAsyncDispatcher() {
      var prevAsyncDispatcher = ReactSharedInternals.A;
      ReactSharedInternals.A = DefaultAsyncDispatcher;
      return prevAsyncDispatcher;
    }
    function renderDidSuspendDelayIfPossible() {
      workInProgressRootExitStatus = 4;
      workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
      0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
        workInProgressRoot,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        false
      );
    }
    function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
        workInProgressTransitions = null, prepareFreshStack(root2, lanes);
      lanes = false;
      var exitStatus = workInProgressRootExitStatus;
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
            switch (workInProgressSuspendedReason) {
              case 8:
                resetWorkInProgressStack();
                exitStatus = 6;
                break a;
              case 3:
              case 2:
              case 9:
              case 6:
                null === suspenseHandlerStackCursor.current && (lanes = true);
                var reason = workInProgressSuspendedReason;
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
                if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                  exitStatus = 0;
                  break a;
                }
                break;
              default:
                reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
            }
          }
          workLoopSync();
          exitStatus = workInProgressRootExitStatus;
          break;
        } catch (thrownValue$165) {
          handleThrow(root2, thrownValue$165);
        }
      while (1);
      lanes && root2.shellSuspendCounter++;
      lastContextDependency = currentlyRenderingFiber$1 = null;
      executionContext = prevExecutionContext;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
      return exitStatus;
    }
    function workLoopSync() {
      for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root2, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= 2;
      var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
      workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
        root2,
        lanes
      );
      a: do
        try {
          if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
            lanes = workInProgress;
            var thrownValue = workInProgressThrownValue;
            b: switch (workInProgressSuspendedReason) {
              case 1:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
                break;
              case 2:
              case 9:
                if (isThenableResolved(thrownValue)) {
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  replaySuspendedUnitOfWork(lanes);
                  break;
                }
                lanes = function() {
                  2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
                  ensureRootIsScheduled(root2);
                };
                thrownValue.then(lanes, lanes);
                break a;
              case 3:
                workInProgressSuspendedReason = 7;
                break a;
              case 4:
                workInProgressSuspendedReason = 5;
                break a;
              case 7:
                isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
                break;
              case 5:
                var resource = null;
                switch (workInProgress.tag) {
                  case 26:
                    resource = workInProgress.memoizedState;
                  case 5:
                  case 27:
                    var hostFiber = workInProgress;
                    if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                      workInProgressSuspendedReason = 0;
                      workInProgressThrownValue = null;
                      var sibling = hostFiber.sibling;
                      if (null !== sibling) workInProgress = sibling;
                      else {
                        var returnFiber = hostFiber.return;
                        null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                      }
                      break b;
                    }
                }
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
                break;
              case 6:
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
                break;
              case 8:
                resetWorkInProgressStack();
                workInProgressRootExitStatus = 6;
                break a;
              default:
                throw Error(formatProdErrorMessage(462));
            }
          }
          workLoopConcurrentByScheduler();
          break;
        } catch (thrownValue$167) {
          handleThrow(root2, thrownValue$167);
        }
      while (1);
      lastContextDependency = currentlyRenderingFiber$1 = null;
      ReactSharedInternals.H = prevDispatcher;
      ReactSharedInternals.A = prevAsyncDispatcher;
      executionContext = prevExecutionContext;
      if (null !== workInProgress) return 0;
      workInProgressRoot = null;
      workInProgressRootRenderLanes = 0;
      finishQueueingConcurrentUpdates();
      return workInProgressRootExitStatus;
    }
    function workLoopConcurrentByScheduler() {
      for (; null !== workInProgress && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    function replaySuspendedUnitOfWork(unitOfWork) {
      var next = unitOfWork;
      var current = next.alternate;
      switch (next.tag) {
        case 15:
        case 0:
          next = replayFunctionComponent(
            current,
            next,
            next.pendingProps,
            next.type,
            void 0,
            workInProgressRootRenderLanes
          );
          break;
        case 11:
          next = replayFunctionComponent(
            current,
            next,
            next.pendingProps,
            next.type.render,
            next.ref,
            workInProgressRootRenderLanes
          );
          break;
        case 5:
          resetHooksOnUnwind(next);
        default:
          unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
      }
      unitOfWork.memoizedProps = unitOfWork.pendingProps;
      null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
    }
    function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
      lastContextDependency = currentlyRenderingFiber$1 = null;
      resetHooksOnUnwind(unitOfWork);
      thenableState$1 = null;
      thenableIndexCounter$1 = 0;
      var returnFiber = unitOfWork.return;
      try {
        if (throwException(
          root2,
          returnFiber,
          unitOfWork,
          thrownValue,
          workInProgressRootRenderLanes
        )) {
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root2,
            createCapturedValueAtFiber(thrownValue, root2.current)
          );
          workInProgress = null;
          return;
        }
      } catch (error) {
        if (null !== returnFiber) throw workInProgress = returnFiber, error;
        workInProgressRootExitStatus = 1;
        logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        );
        workInProgress = null;
        return;
      }
      if (unitOfWork.flags & 32768) {
        if (isHydrating || 1 === suspendedReason) root2 = true;
        else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
          root2 = false;
        else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
          suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
        unwindUnitOfWork(unitOfWork, root2);
      } else completeUnitOfWork(unitOfWork);
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        if (0 !== (completedWork.flags & 32768)) {
          unwindUnitOfWork(
            completedWork,
            workInProgressRootDidSkipSuspendedSiblings
          );
          return;
        }
        unitOfWork = completedWork.return;
        var next = completeWork(
          completedWork.alternate,
          completedWork,
          entangledRenderLanes
        );
        if (null !== next) {
          workInProgress = next;
          return;
        }
        completedWork = completedWork.sibling;
        if (null !== completedWork) {
          workInProgress = completedWork;
          return;
        }
        workInProgress = completedWork = unitOfWork;
      } while (null !== completedWork);
      0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
    }
    function unwindUnitOfWork(unitOfWork, skipSiblings) {
      do {
        var next = unwindWork(unitOfWork.alternate, unitOfWork);
        if (null !== next) {
          next.flags &= 32767;
          workInProgress = next;
          return;
        }
        next = unitOfWork.return;
        null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
        if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
          workInProgress = unitOfWork;
          return;
        }
        workInProgress = unitOfWork = next;
      } while (null !== unitOfWork);
      workInProgressRootExitStatus = 6;
      workInProgress = null;
    }
    function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
      root2.cancelPendingCommit = null;
      do
        flushPendingEffects();
      while (0 !== pendingEffectsStatus);
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
      if (null !== finishedWork) {
        if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
        didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
        didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
        markRootFinished(
          root2,
          lanes,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
        root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
        pendingFinishedWork = finishedWork;
        pendingEffectsRoot = root2;
        pendingEffectsLanes = lanes;
        pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
        pendingPassiveTransitions = transitions;
        pendingRecoverableErrors = recoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
          flushPassiveEffects();
          return null;
        })) : (root2.callbackNode = null, root2.callbackPriority = 0);
        recoverableErrors = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
          recoverableErrors = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          transitions = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          spawnedLane = executionContext;
          executionContext |= 4;
          try {
            commitBeforeMutationEffects(root2, finishedWork, lanes);
          } finally {
            executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
          }
        }
        pendingEffectsStatus = 1;
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
      }
    }
    function flushMutationEffects() {
      if (1 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
        if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
          rootMutationHasEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitMutationEffectsOnFiber(finishedWork, root2);
            var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
              priorFocusedElem.ownerDocument.documentElement,
              priorFocusedElem
            )) {
              if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                var start = priorSelectionRange.start, end = priorSelectionRange.end;
                void 0 === end && (end = start);
                if ("selectionStart" in priorFocusedElem)
                  priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                    end,
                    priorFocusedElem.value.length
                  );
                else {
                  var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                  if (win.getSelection) {
                    var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                    !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                    var startMarker = getNodeForCharacterOffset(
                      priorFocusedElem,
                      start$jscomp$0
                    ), endMarker = getNodeForCharacterOffset(
                      priorFocusedElem,
                      end$jscomp$0
                    );
                    if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                      var range = doc.createRange();
                      range.setStart(startMarker.node, startMarker.offset);
                      selection.removeAllRanges();
                      start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                    }
                  }
                }
              }
              doc = [];
              for (selection = priorFocusedElem; selection = selection.parentNode; )
                1 === selection.nodeType && doc.push({
                  element: selection,
                  left: selection.scrollLeft,
                  top: selection.scrollTop
                });
              "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
              for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                var info = doc[priorFocusedElem];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
            _enabled = !!eventsEnabled;
            selectionInformation = eventsEnabled = null;
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
          }
        }
        root2.current = finishedWork;
        pendingEffectsStatus = 2;
      }
    }
    function flushLayoutEffects() {
      if (2 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
        if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
          rootHasLayoutEffect = ReactSharedInternals.T;
          ReactSharedInternals.T = null;
          var previousPriority = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          try {
            commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
          } finally {
            executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
          }
        }
        pendingEffectsStatus = 3;
      }
    }
    function flushSpawnedWork() {
      if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
        pendingEffectsStatus = 0;
        requestPaint();
        var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
        0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
        var remainingLanes = root2.pendingLanes;
        0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
        lanesToEventPriority(lanes);
        finishedWork = finishedWork.stateNode;
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
          try {
            injectedHook.onCommitFiberRoot(
              rendererID,
              finishedWork,
              void 0,
              128 === (finishedWork.current.flags & 128)
            );
          } catch (err) {
          }
        if (null !== recoverableErrors) {
          finishedWork = ReactSharedInternals.T;
          remainingLanes = ReactDOMSharedInternals.p;
          ReactDOMSharedInternals.p = 2;
          ReactSharedInternals.T = null;
          try {
            for (var onRecoverableError = root2.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
              var recoverableError = recoverableErrors[i];
              onRecoverableError(recoverableError.value, {
                componentStack: recoverableError.stack
              });
            }
          } finally {
            ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
          }
        }
        0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
        ensureRootIsScheduled(root2);
        remainingLanes = root2.pendingLanes;
        0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
        flushSyncWorkAcrossRoots_impl(0, false);
      }
    }
    function releaseRootPooledCache(root2, remainingLanes) {
      0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
    }
    function flushPendingEffects() {
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
      return flushPassiveEffects();
    }
    function flushPassiveEffects() {
      if (5 !== pendingEffectsStatus) return false;
      var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
      pendingEffectsRemainingLanes = 0;
      var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
        ReactSharedInternals.T = null;
        renderPriority = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
        pendingEffectsStatus = 0;
        pendingFinishedWork = pendingEffectsRoot = null;
        pendingEffectsLanes = 0;
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        commitPassiveUnmountOnFiber(root$jscomp$0.current);
        commitPassiveMountOnFiber(
          root$jscomp$0,
          root$jscomp$0.current,
          lanes,
          renderPriority
        );
        executionContext = prevExecutionContext;
        flushSyncWorkAcrossRoots_impl(0, false);
        if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
          } catch (err) {
          }
        return true;
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
      }
    }
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
      sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
      sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
      rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
      null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
      if (3 === sourceFiber.tag)
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
      else
        for (; null !== nearestMountedAncestor; ) {
          if (3 === nearestMountedAncestor.tag) {
            captureCommitPhaseErrorOnRoot(
              nearestMountedAncestor,
              sourceFiber,
              error
            );
            break;
          } else if (1 === nearestMountedAncestor.tag) {
            var instance = nearestMountedAncestor.stateNode;
            if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
              sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
              error = createClassErrorUpdate(2);
              instance = enqueueUpdate(nearestMountedAncestor, error, 2);
              null !== instance && (initializeClassErrorUpdate(
                error,
                instance,
                nearestMountedAncestor,
                sourceFiber
              ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
              break;
            }
          }
          nearestMountedAncestor = nearestMountedAncestor.return;
        }
    }
    function attachPingListener(root2, wakeable, lanes) {
      var pingCache = root2.pingCache;
      if (null === pingCache) {
        pingCache = root2.pingCache = new PossiblyWeakMap();
        var threadIDs = /* @__PURE__ */ new Set();
        pingCache.set(wakeable, threadIDs);
      } else
        threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
      threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
    }
    function pingSuspendedRoot(root2, wakeable, pingedLanes) {
      var pingCache = root2.pingCache;
      null !== pingCache && pingCache.delete(wakeable);
      root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
      root2.warmLanes &= ~pingedLanes;
      workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
      ensureRootIsScheduled(root2);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      0 === retryLane && (retryLane = claimNextRetryLane());
      boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
      null !== suspenseState && (retryLane = suspenseState.retryLane);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = 0;
      switch (boundaryFiber.tag) {
        case 31:
        case 13:
          var retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          null !== suspenseState && (retryLane = suspenseState.retryLane);
          break;
        case 19:
          retryCache = boundaryFiber.stateNode;
          break;
        case 22:
          retryCache = boundaryFiber.stateNode._retryCache;
          break;
        default:
          throw Error(formatProdErrorMessage(314));
      }
      null !== retryCache && retryCache.delete(wakeable);
      retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function scheduleCallback$1(priorityLevel, callback) {
      return scheduleCallback$3(priorityLevel, callback);
    }
    var firstScheduledRoot = null;
    var lastScheduledRoot = null;
    var didScheduleMicrotask = false;
    var mightHavePendingSyncWork = false;
    var isFlushingWork = false;
    var currentEventTransitionLane = 0;
    function ensureRootIsScheduled(root2) {
      root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
      mightHavePendingSyncWork = true;
      didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
    }
    function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
      if (!isFlushingWork && mightHavePendingSyncWork) {
        isFlushingWork = true;
        do {
          var didPerformSomeWork = false;
          for (var root$170 = firstScheduledRoot; null !== root$170; ) {
            if (!onlyLegacy)
              if (0 !== syncTransitionLanes) {
                var pendingLanes = root$170.pendingLanes;
                if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                else {
                  var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
                  JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                  JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                  JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                }
                0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
              } else
                JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                  root$170,
                  root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
                  null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle
                ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
            root$170 = root$170.next;
          }
        } while (didPerformSomeWork);
        isFlushingWork = false;
      }
    }
    function processRootScheduleInImmediateTask() {
      processRootScheduleInMicrotask();
    }
    function processRootScheduleInMicrotask() {
      mightHavePendingSyncWork = didScheduleMicrotask = false;
      var syncTransitionLanes = 0;
      0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
      for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
        var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
        if (0 === nextLanes)
          root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
        else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
          mightHavePendingSyncWork = true;
        root2 = next;
      }
      0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
      0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
    }
    function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
      for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
        var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
        if (-1 === expirationTime) {
          if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
            expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
        } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
        lanes &= ~lane;
      }
      currentTime = workInProgressRoot;
      suspendedLanes = workInProgressRootRenderLanes;
      suspendedLanes = getNextLanes(
        root2,
        root2 === currentTime ? suspendedLanes : 0,
        null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
      );
      pingedLanes = root2.callbackNode;
      if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
        return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
      if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
        currentTime = suspendedLanes & -suspendedLanes;
        if (currentTime === root2.callbackPriority) return currentTime;
        null !== pingedLanes && cancelCallback$1(pingedLanes);
        switch (lanesToEventPriority(suspendedLanes)) {
          case 2:
          case 8:
            suspendedLanes = UserBlockingPriority;
            break;
          case 32:
            suspendedLanes = NormalPriority$1;
            break;
          case 268435456:
            suspendedLanes = IdlePriority;
            break;
          default:
            suspendedLanes = NormalPriority$1;
        }
        pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
        suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
        root2.callbackPriority = currentTime;
        root2.callbackNode = suspendedLanes;
        return currentTime;
      }
      null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
      root2.callbackPriority = 2;
      root2.callbackNode = null;
      return 2;
    }
    function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
      if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
        return root2.callbackNode = null, root2.callbackPriority = 0, null;
      var originalCallbackNode = root2.callbackNode;
      if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
        return null;
      var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
      workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
        root2,
        root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
        null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
      );
      if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
      performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
      scheduleTaskForRootDuringMicrotask(root2, now());
      return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
    }
    function performSyncWorkOnRoot(root2, lanes) {
      if (flushPendingEffects()) return null;
      performWorkOnRoot(root2, lanes, true);
    }
    function scheduleImmediateRootScheduleTask() {
      scheduleMicrotask(function() {
        0 !== (executionContext & 6) ? scheduleCallback$3(
          ImmediatePriority,
          processRootScheduleInImmediateTask
        ) : processRootScheduleInMicrotask();
      });
    }
    function requestTransitionLane() {
      if (0 === currentEventTransitionLane) {
        var actionScopeLane = currentEntangledLane;
        0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
        currentEventTransitionLane = actionScopeLane;
      }
      return currentEventTransitionLane;
    }
    function coerceFormActionProp(actionProp) {
      return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
    }
    function createFormDataWithSubmitter(form, submitter) {
      var temp = submitter.ownerDocument.createElement("input");
      temp.name = submitter.name;
      temp.value = submitter.value;
      form.id && temp.setAttribute("form", form.id);
      submitter.parentNode.insertBefore(temp, submitter);
      form = new FormData(form);
      temp.parentNode.removeChild(temp);
      return form;
    }
    function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
      if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
        var action = coerceFormActionProp(
          (nativeEventTarget[internalPropsKey] || null).action
        ), submitter = nativeEvent.submitter;
        submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
        var event = new SyntheticEvent(
          "action",
          "action",
          null,
          nativeEvent,
          nativeEventTarget
        );
        dispatchQueue.push({
          event,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (nativeEvent.defaultPrevented) {
                  if (0 !== currentEventTransitionLane) {
                    var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                    startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      null,
                      formData
                    );
                  }
                } else
                  "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                    maybeTargetInst,
                    {
                      pending: true,
                      data: formData,
                      method: nativeEventTarget.method,
                      action
                    },
                    action,
                    formData
                  ));
              },
              currentTarget: nativeEventTarget
            }
          ]
        });
      }
    }
    for (i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
      eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577], domEventName$jscomp$inline_1579 = eventName$jscomp$inline_1578.toLowerCase(), capitalizedEvent$jscomp$inline_1580 = eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1);
      registerSimpleEvent(
        domEventName$jscomp$inline_1579,
        "on" + capitalizedEvent$jscomp$inline_1580
      );
    }
    var eventName$jscomp$inline_1578;
    var domEventName$jscomp$inline_1579;
    var capitalizedEvent$jscomp$inline_1580;
    var i$jscomp$inline_1577;
    registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
    registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
    registerSimpleEvent(ANIMATION_START, "onAnimationStart");
    registerSimpleEvent("dblclick", "onDoubleClick");
    registerSimpleEvent("focusin", "onFocus");
    registerSimpleEvent("focusout", "onBlur");
    registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
    registerSimpleEvent(TRANSITION_START, "onTransitionStart");
    registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
    registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
    registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
    registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
    registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    registerTwoPhaseEvent(
      "onChange",
      "change click focusin focusout input keydown keyup selectionchange".split(" ")
    );
    registerTwoPhaseEvent(
      "onSelect",
      "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
        " "
      )
    );
    registerTwoPhaseEvent("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]);
    registerTwoPhaseEvent(
      "onCompositionEnd",
      "compositionend focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionStart",
      "compositionstart focusout keydown keypress keyup mousedown".split(" ")
    );
    registerTwoPhaseEvent(
      "onCompositionUpdate",
      "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
    );
    var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    );
    var nonDelegatedEvents = new Set(
      "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
    );
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      eventSystemFlags = 0 !== (eventSystemFlags & 4);
      for (var i = 0; i < dispatchQueue.length; i++) {
        var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
        _dispatchQueue$i = _dispatchQueue$i.listeners;
        a: {
          var previousInstance = void 0;
          if (eventSystemFlags)
            for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
              var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
          else
            for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
              _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
              instance = _dispatchListeners$i.instance;
              currentTarget = _dispatchListeners$i.currentTarget;
              _dispatchListeners$i = _dispatchListeners$i.listener;
              if (instance !== previousInstance && event.isPropagationStopped())
                break a;
              previousInstance = _dispatchListeners$i;
              event.currentTarget = currentTarget;
              try {
                previousInstance(event);
              } catch (error) {
                reportGlobalError(error);
              }
              event.currentTarget = null;
              previousInstance = instance;
            }
        }
      }
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
      void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
      var listenerSetKey = domEventName + "__bubble";
      JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= 4);
      addTrappedEventListener(
        target,
        domEventName,
        eventSystemFlags,
        isCapturePhaseListener
      );
    }
    var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = true;
        allNativeEvents.forEach(function(domEventName) {
          "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
        });
        var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
        null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
      }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
      switch (getEventPriority(domEventName)) {
        case 2:
          var listenerWrapper = dispatchDiscreteEvent;
          break;
        case 8:
          listenerWrapper = dispatchContinuousEvent;
          break;
        default:
          listenerWrapper = dispatchEvent;
      }
      eventSystemFlags = listenerWrapper.bind(
        null,
        domEventName,
        eventSystemFlags,
        targetContainer
      );
      listenerWrapper = void 0;
      !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
      isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        capture: true,
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
        passive: listenerWrapper
      }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
      var ancestorInst = targetInst$jscomp$0;
      if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
        a: for (; ; ) {
          if (null === targetInst$jscomp$0) return;
          var nodeTag = targetInst$jscomp$0.tag;
          if (3 === nodeTag || 4 === nodeTag) {
            var container = targetInst$jscomp$0.stateNode.containerInfo;
            if (container === targetContainer) break;
            if (4 === nodeTag)
              for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                var grandTag = nodeTag.tag;
                if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                  return;
                nodeTag = nodeTag.return;
              }
            for (; null !== container; ) {
              nodeTag = getClosestInstanceFromNode(container);
              if (null === nodeTag) return;
              grandTag = nodeTag.tag;
              if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                targetInst$jscomp$0 = ancestorInst = nodeTag;
                continue a;
              }
              container = container.parentNode;
            }
          }
          targetInst$jscomp$0 = targetInst$jscomp$0.return;
        }
      batchedUpdates$1(function() {
        var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
        a: {
          var reactName = topLevelEventsToReactNames.get(domEventName);
          if (void 0 !== reactName) {
            var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (0 === getEventCharCode(nativeEvent)) break a;
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (2 === nativeEvent.button) break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
              case "scrollend":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
              case "toggle":
              case "beforetoggle":
                SyntheticEventCtor = SyntheticToggleEvent;
            }
            var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
            inCapturePhase = [];
            for (var instance = targetInst, lastHostComponent; null !== instance; ) {
              var _instance = instance;
              lastHostComponent = _instance.stateNode;
              _instance = _instance.tag;
              5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
                createDispatchListener(instance, _instance, lastHostComponent)
              ));
              if (accumulateTargetOnly) break;
              instance = instance.return;
            }
            0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
              reactName,
              reactEventType,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
          }
        }
        if (0 === (eventSystemFlags & 7)) {
          a: {
            reactName = "mouseover" === domEventName || "pointerover" === domEventName;
            SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
            if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
              break a;
            if (SyntheticEventCtor || reactName) {
              reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
              if (SyntheticEventCtor) {
                if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                  reactEventType = null;
              } else SyntheticEventCtor = null, reactEventType = targetInst;
              if (SyntheticEventCtor !== reactEventType) {
                inCapturePhase = SyntheticMouseEvent;
                _instance = "onMouseLeave";
                reactEventName = "onMouseEnter";
                instance = "mouse";
                if ("pointerout" === domEventName || "pointerover" === domEventName)
                  inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
                accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                reactName = new inCapturePhase(
                  _instance,
                  instance + "leave",
                  SyntheticEventCtor,
                  nativeEvent,
                  nativeEventTarget
                );
                reactName.target = accumulateTargetOnly;
                reactName.relatedTarget = lastHostComponent;
                _instance = null;
                getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                  reactEventName,
                  instance + "enter",
                  reactEventType,
                  nativeEvent,
                  nativeEventTarget
                ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                accumulateTargetOnly = _instance;
                if (SyntheticEventCtor && reactEventType)
                  b: {
                    inCapturePhase = getParent;
                    reactEventName = SyntheticEventCtor;
                    instance = reactEventType;
                    lastHostComponent = 0;
                    for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance))
                      lastHostComponent++;
                    _instance = 0;
                    for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                      _instance++;
                    for (; 0 < lastHostComponent - _instance; )
                      reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                    for (; 0 < _instance - lastHostComponent; )
                      instance = inCapturePhase(instance), _instance--;
                    for (; lastHostComponent--; ) {
                      if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                        inCapturePhase = reactEventName;
                        break b;
                      }
                      reactEventName = inCapturePhase(reactEventName);
                      instance = inCapturePhase(instance);
                    }
                    inCapturePhase = null;
                  }
                else inCapturePhase = null;
                null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  reactName,
                  SyntheticEventCtor,
                  inCapturePhase,
                  false
                );
                null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                  dispatchQueue,
                  accumulateTargetOnly,
                  reactEventType,
                  inCapturePhase,
                  true
                );
              }
            }
          }
          a: {
            reactName = targetInst ? getNodeFromInstance(targetInst) : window;
            SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
            if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
              var getTargetInstFunc = getTargetInstForChangeEvent;
            else if (isTextInputElement(reactName))
              if (isInputEventSupported)
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                var handleEventFunc = handleEventsForInputEventPolyfill;
              }
            else
              SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
            if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
              createAndAccumulateChangeEvent(
                dispatchQueue,
                getTargetInstFunc,
                nativeEvent,
                nativeEventTarget
              );
              break a;
            }
            handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
            "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
          }
          handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
          switch (domEventName) {
            case "focusin":
              if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
              break;
            case "focusout":
              lastSelection = activeElementInst = activeElement = null;
              break;
            case "mousedown":
              mouseDown = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              mouseDown = false;
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
              break;
            case "selectionchange":
              if (skipSelectionChangeEvent) break;
            case "keydown":
            case "keyup":
              constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          }
          var fallbackData;
          if (canUseCompositionEvent)
            b: {
              switch (domEventName) {
                case "compositionstart":
                  var eventType = "onCompositionStart";
                  break b;
                case "compositionend":
                  eventType = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  eventType = "onCompositionUpdate";
                  break b;
              }
              eventType = void 0;
            }
          else
            isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
          eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
            eventType,
            domEventName,
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
          if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
            eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
              "onBeforeInput",
              "beforeinput",
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({
              event: handleEventFunc,
              listeners: eventType
            }), handleEventFunc.data = fallbackData);
          extractEvents$1(
            dispatchQueue,
            domEventName,
            targetInst,
            nativeEvent,
            nativeEventTarget
          );
        }
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance,
        listener,
        currentTarget
      };
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
        var _instance2 = targetFiber, stateNode = _instance2.stateNode;
        _instance2 = _instance2.tag;
        5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
          createDispatchListener(targetFiber, _instance2, stateNode)
        ));
        if (3 === targetFiber.tag) return listeners;
        targetFiber = targetFiber.return;
      }
      return [];
    }
    function getParent(inst) {
      if (null === inst) return null;
      do
        inst = inst.return;
      while (inst && 5 !== inst.tag && 27 !== inst.tag);
      return inst ? inst : null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
      for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
        var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
        _instance3 = _instance3.tag;
        if (null !== alternate && alternate === common) break;
        5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
          createDispatchListener(target, stateNode, alternate)
        )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
          createDispatchListener(target, stateNode, alternate)
        )));
        target = target.return;
      }
      0 !== listeners.length && dispatchQueue.push({ event, listeners });
    }
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
    var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
    function normalizeMarkupForTextOrAttribute(markup) {
      return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText) {
      clientText = normalizeMarkupForTextOrAttribute(clientText);
      return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
    }
    function setProp(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "children":
          "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
          break;
        case "className":
          setValueForKnownAttribute(domElement, "class", value);
          break;
        case "tabIndex":
          setValueForKnownAttribute(domElement, "tabindex", value);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          setValueForKnownAttribute(domElement, key, value);
          break;
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "data":
          if ("object" !== tag) {
            setValueForKnownAttribute(domElement, "data", value);
            break;
          }
        case "src":
        case "href":
          if ("" === value && ("a" !== tag || "href" !== key)) {
            domElement.removeAttribute(key);
            break;
          }
          if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "action":
        case "formAction":
          if ("function" === typeof value) {
            domElement.setAttribute(
              key,
              "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
            );
            break;
          } else
            "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
              domElement,
              tag,
              "formEncType",
              props.formEncType,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formMethod",
              props.formMethod,
              props,
              null
            ), setProp(
              domElement,
              tag,
              "formTarget",
              props.formTarget,
              props,
              null
            )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
          if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
            domElement.removeAttribute(key);
            break;
          }
          value = sanitizeURL("" + value);
          domElement.setAttribute(key, value);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$1);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "multiple":
          domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "muted":
          domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
            domElement.removeAttribute("xlink:href");
            break;
          }
          key = sanitizeURL("" + value);
          domElement.setAttributeNS(
            "http://www.w3.org/1999/xlink",
            "xlink:href",
            key
          );
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
          break;
        case "capture":
        case "download":
          true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
          break;
        case "rowSpan":
        case "start":
          null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
          break;
        case "popover":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          setValueForAttribute(domElement, "popover", value);
          break;
        case "xlinkActuate":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:actuate",
            value
          );
          break;
        case "xlinkArcrole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:arcrole",
            value
          );
          break;
        case "xlinkRole":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:role",
            value
          );
          break;
        case "xlinkShow":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:show",
            value
          );
          break;
        case "xlinkTitle":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:title",
            value
          );
          break;
        case "xlinkType":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/1999/xlink",
            "xlink:type",
            value
          );
          break;
        case "xmlBase":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:base",
            value
          );
          break;
        case "xmlLang":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:lang",
            value
          );
          break;
        case "xmlSpace":
          setValueForNamespacedAttribute(
            domElement,
            "http://www.w3.org/XML/1998/namespace",
            "xml:space",
            value
          );
          break;
        case "is":
          setValueForAttribute(domElement, "is", value);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
            key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
      }
    }
    function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
      switch (key) {
        case "style":
          setValueForStyles(domElement, value, prevValue);
          break;
        case "dangerouslySetInnerHTML":
          if (null != value) {
            if ("object" !== typeof value || !("__html" in value))
              throw Error(formatProdErrorMessage(61));
            key = value.__html;
            if (null != key) {
              if (null != props.children) throw Error(formatProdErrorMessage(60));
              domElement.innerHTML = key;
            }
          }
          break;
        case "children":
          "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
          break;
        case "onScroll":
          null != value && listenToNonDelegatedEvent("scroll", domElement);
          break;
        case "onScrollEnd":
          null != value && listenToNonDelegatedEvent("scrollend", domElement);
          break;
        case "onClick":
          null != value && (domElement.onclick = noop$1);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!registrationNameDependencies.hasOwnProperty(key))
            a: {
              if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                domElement.addEventListener(tag, value, props);
                break a;
              }
              key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
            }
      }
    }
    function setInitialProperties(domElement, tag, props) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          var hasSrc = false, hasSrcSet = false, propKey;
          for (propKey in props)
            if (props.hasOwnProperty(propKey)) {
              var propValue = props[propKey];
              if (null != propValue)
                switch (propKey) {
                  case "src":
                    hasSrc = true;
                    break;
                  case "srcSet":
                    hasSrcSet = true;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, propKey, propValue, props, null);
                }
            }
          hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
          hasSrc && setProp(domElement, tag, "src", props.src, props, null);
          return;
        case "input":
          listenToNonDelegatedEvent("invalid", domElement);
          var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
          for (hasSrc in props)
            if (props.hasOwnProperty(hasSrc)) {
              var propValue$184 = props[hasSrc];
              if (null != propValue$184)
                switch (hasSrc) {
                  case "name":
                    hasSrcSet = propValue$184;
                    break;
                  case "type":
                    propValue = propValue$184;
                    break;
                  case "checked":
                    checked = propValue$184;
                    break;
                  case "defaultChecked":
                    defaultChecked = propValue$184;
                    break;
                  case "value":
                    propKey = propValue$184;
                    break;
                  case "defaultValue":
                    defaultValue = propValue$184;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propValue$184)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(domElement, tag, hasSrc, propValue$184, props, null);
                }
            }
          initInput(
            domElement,
            propKey,
            defaultValue,
            checked,
            defaultChecked,
            propValue,
            hasSrcSet,
            false
          );
          return;
        case "select":
          listenToNonDelegatedEvent("invalid", domElement);
          hasSrc = propValue = propKey = null;
          for (hasSrcSet in props)
            if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
              switch (hasSrcSet) {
                case "value":
                  propKey = defaultValue;
                  break;
                case "defaultValue":
                  propValue = defaultValue;
                  break;
                case "multiple":
                  hasSrc = defaultValue;
                default:
                  setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
              }
          tag = propKey;
          props = propValue;
          domElement.multiple = !!hasSrc;
          null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
          return;
        case "textarea":
          listenToNonDelegatedEvent("invalid", domElement);
          propKey = hasSrcSet = hasSrc = null;
          for (propValue in props)
            if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
              switch (propValue) {
                case "value":
                  hasSrc = defaultValue;
                  break;
                case "defaultValue":
                  hasSrcSet = defaultValue;
                  break;
                case "children":
                  propKey = defaultValue;
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  setProp(domElement, tag, propValue, defaultValue, props, null);
              }
          initTextarea(domElement, hasSrc, hasSrcSet, propKey);
          return;
        case "option":
          for (checked in props)
            if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
              switch (checked) {
                case "selected":
                  domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                  break;
                default:
                  setProp(domElement, tag, checked, hasSrc, props, null);
              }
          return;
        case "dialog":
          listenToNonDelegatedEvent("beforetoggle", domElement);
          listenToNonDelegatedEvent("toggle", domElement);
          listenToNonDelegatedEvent("cancel", domElement);
          listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
            listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
          break;
        case "image":
          listenToNonDelegatedEvent("error", domElement);
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "embed":
        case "source":
        case "link":
          listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (defaultChecked in props)
            if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
              switch (defaultChecked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(137, tag));
                default:
                  setProp(domElement, tag, defaultChecked, hasSrc, props, null);
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (propValue$184 in props)
              props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(
                domElement,
                tag,
                propValue$184,
                hasSrc,
                props,
                void 0
              ));
            return;
          }
      }
      for (defaultValue in props)
        props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
    }
    function updateProperties(domElement, tag, lastProps, nextProps) {
      switch (tag) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
          for (propKey in lastProps) {
            var lastProp = lastProps[propKey];
            if (lastProps.hasOwnProperty(propKey) && null != lastProp)
              switch (propKey) {
                case "checked":
                  break;
                case "value":
                  break;
                case "defaultValue":
                  lastDefaultValue = lastProp;
                default:
                  nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
              }
          }
          for (var propKey$201 in nextProps) {
            var propKey = nextProps[propKey$201];
            lastProp = lastProps[propKey$201];
            if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp))
              switch (propKey$201) {
                case "type":
                  type = propKey;
                  break;
                case "name":
                  name = propKey;
                  break;
                case "checked":
                  checked = propKey;
                  break;
                case "defaultChecked":
                  defaultChecked = propKey;
                  break;
                case "value":
                  value = propKey;
                  break;
                case "defaultValue":
                  defaultValue = propKey;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  propKey !== lastProp && setProp(
                    domElement,
                    tag,
                    propKey$201,
                    propKey,
                    nextProps,
                    lastProp
                  );
              }
          }
          updateInput(
            domElement,
            value,
            defaultValue,
            lastDefaultValue,
            checked,
            defaultChecked,
            type,
            name
          );
          return;
        case "select":
          propKey = value = defaultValue = propKey$201 = null;
          for (type in lastProps)
            if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
              switch (type) {
                case "value":
                  break;
                case "multiple":
                  propKey = lastDefaultValue;
                default:
                  nextProps.hasOwnProperty(type) || setProp(
                    domElement,
                    tag,
                    type,
                    null,
                    nextProps,
                    lastDefaultValue
                  );
              }
          for (name in nextProps)
            if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
              switch (name) {
                case "value":
                  propKey$201 = type;
                  break;
                case "defaultValue":
                  defaultValue = type;
                  break;
                case "multiple":
                  value = type;
                default:
                  type !== lastDefaultValue && setProp(
                    domElement,
                    tag,
                    name,
                    type,
                    nextProps,
                    lastDefaultValue
                  );
              }
          tag = defaultValue;
          lastProps = value;
          nextProps = propKey;
          null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
          return;
        case "textarea":
          propKey = propKey$201 = null;
          for (defaultValue in lastProps)
            if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
              switch (defaultValue) {
                case "value":
                  break;
                case "children":
                  break;
                default:
                  setProp(domElement, tag, defaultValue, null, nextProps, name);
              }
          for (value in nextProps)
            if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
              switch (value) {
                case "value":
                  propKey$201 = name;
                  break;
                case "defaultValue":
                  propKey = name;
                  break;
                case "children":
                  break;
                case "dangerouslySetInnerHTML":
                  if (null != name) throw Error(formatProdErrorMessage(91));
                  break;
                default:
                  name !== type && setProp(domElement, tag, value, name, nextProps, type);
              }
          updateTextarea(domElement, propKey$201, propKey);
          return;
        case "option":
          for (var propKey$217 in lastProps)
            if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217))
              switch (propKey$217) {
                case "selected":
                  domElement.selected = false;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    propKey$217,
                    null,
                    nextProps,
                    propKey$201
                  );
              }
          for (lastDefaultValue in nextProps)
            if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
              switch (lastDefaultValue) {
                case "selected":
                  domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    lastDefaultValue,
                    propKey$201,
                    nextProps,
                    propKey
                  );
              }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var propKey$222 in lastProps)
            propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
          for (checked in nextProps)
            if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
              switch (checked) {
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propKey$201)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  setProp(
                    domElement,
                    tag,
                    checked,
                    propKey$201,
                    nextProps,
                    propKey
                  );
              }
          return;
        default:
          if (isCustomElement(tag)) {
            for (var propKey$227 in lastProps)
              propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(
                domElement,
                tag,
                propKey$227,
                void 0,
                nextProps,
                propKey$201
              );
            for (defaultChecked in nextProps)
              propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(
                domElement,
                tag,
                defaultChecked,
                propKey$201,
                nextProps,
                propKey
              );
            return;
          }
      }
      for (var propKey$232 in lastProps)
        propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
      for (lastProp in nextProps)
        propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
    }
    function isLikelyStaticResource(initiatorType) {
      switch (initiatorType) {
        case "css":
        case "script":
        case "font":
        case "img":
        case "image":
        case "input":
        case "link":
          return true;
        default:
          return false;
      }
    }
    function estimateBandwidth() {
      if ("function" === typeof performance.getEntriesByType) {
        for (var count2 = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i = 0; i < resourceEntries.length; i++) {
          var entry = resourceEntries[i], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
          if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
            initiatorType = 0;
            duration = entry.responseEnd;
            for (i += 1; i < resourceEntries.length; i++) {
              var overlapEntry = resourceEntries[i], overlapStartTime = overlapEntry.startTime;
              if (overlapStartTime > duration) break;
              var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
              overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
            }
            --i;
            bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
            count2++;
            if (10 < count2) break;
          }
        }
        if (0 < count2) return bits / count2 / 1e6;
      }
      return navigator.connection && (count2 = navigator.connection.downlink, "number" === typeof count2) ? count2 : 5;
    }
    var eventsEnabled = null;
    var selectionInformation = null;
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function getOwnHostContext(namespaceURI) {
      switch (namespaceURI) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function getChildHostContextProd(parentNamespace, type) {
      if (0 === parentNamespace)
        switch (type) {
          case "svg":
            return 1;
          case "math":
            return 2;
          default:
            return 0;
        }
      return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
    }
    function shouldSetTextContent(type, props) {
      return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
    }
    var currentPopstateTransitionEvent = null;
    function shouldAttemptEagerTransition() {
      var event = window.event;
      if (event && "popstate" === event.type) {
        if (event === currentPopstateTransitionEvent) return false;
        currentPopstateTransitionEvent = event;
        return true;
      }
      currentPopstateTransitionEvent = null;
      return false;
    }
    var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0;
    var cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0;
    var localPromise = "function" === typeof Promise ? Promise : void 0;
    var scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
      return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
    } : scheduleTimeout;
    function handleErrorInNextTick(error) {
      setTimeout(function() {
        throw error;
      });
    }
    function isSingletonScope(type) {
      return "head" === type;
    }
    function clearHydrationBoundary(parentInstance, hydrationInstance) {
      var node = hydrationInstance, depth = 0;
      do {
        var nextNode = node.nextSibling;
        parentInstance.removeChild(node);
        if (nextNode && 8 === nextNode.nodeType)
          if (node = nextNode.data, "/$" === node || "/&" === node) {
            if (0 === depth) {
              parentInstance.removeChild(nextNode);
              retryIfBlockedOn(hydrationInstance);
              return;
            }
            depth--;
          } else if ("$" === node || "$?" === node || "$~" === node || "$!" === node || "&" === node)
            depth++;
          else if ("html" === node)
            releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
          else if ("head" === node) {
            node = parentInstance.ownerDocument.head;
            releaseSingletonInstance(node);
            for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
              var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
              node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
              node$jscomp$0 = nextNode$jscomp$0;
            }
          } else
            "body" === node && releaseSingletonInstance(parentInstance.ownerDocument.body);
        node = nextNode;
      } while (node);
      retryIfBlockedOn(hydrationInstance);
    }
    function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden) {
      var node = suspenseInstance;
      suspenseInstance = 0;
      do {
        var nextNode = node.nextSibling;
        1 === node.nodeType ? isHidden ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
        if (nextNode && 8 === nextNode.nodeType)
          if (node = nextNode.data, "/$" === node)
            if (0 === suspenseInstance) break;
            else suspenseInstance--;
          else
            "$" !== node && "$?" !== node && "$~" !== node && "$!" !== node || suspenseInstance++;
        node = nextNode;
      } while (node);
    }
    function clearContainerSparingly(container) {
      var nextNode = container.firstChild;
      nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
      for (; nextNode; ) {
        var node = nextNode;
        nextNode = nextNode.nextSibling;
        switch (node.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            clearContainerSparingly(node);
            detachDeletedInstance(node);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if ("stylesheet" === node.rel.toLowerCase()) continue;
        }
        container.removeChild(node);
      }
    }
    function canHydrateInstance(instance, type, props, inRootOrSingleton) {
      for (; 1 === instance.nodeType; ) {
        var anyProps = props;
        if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
          if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
            break;
        } else if (!inRootOrSingleton)
          if ("input" === type && "hidden" === instance.type) {
            var name = null == anyProps.name ? null : "" + anyProps.name;
            if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
              return instance;
          } else return instance;
        else if (!instance[internalHoistableMarker])
          switch (type) {
            case "meta":
              if (!instance.hasAttribute("itemprop")) break;
              return instance;
            case "link":
              name = instance.getAttribute("rel");
              if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
                break;
              else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                break;
              return instance;
            case "style":
              if (instance.hasAttribute("data-precedence")) break;
              return instance;
            case "script":
              name = instance.getAttribute("src");
              if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
                break;
              return instance;
            default:
              return instance;
          }
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) break;
      }
      return null;
    }
    function canHydrateTextInstance(instance, text, inRootOrSingleton) {
      if ("" === text) return null;
      for (; 3 !== instance.nodeType; ) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
      for (; 8 !== instance.nodeType; ) {
        if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
          return null;
        instance = getNextHydratable(instance.nextSibling);
        if (null === instance) return null;
      }
      return instance;
    }
    function isSuspenseInstancePending(instance) {
      return "$?" === instance.data || "$~" === instance.data;
    }
    function isSuspenseInstanceFallback(instance) {
      return "$!" === instance.data || "$?" === instance.data && "loading" !== instance.ownerDocument.readyState;
    }
    function registerSuspenseInstanceRetry(instance, callback) {
      var ownerDocument = instance.ownerDocument;
      if ("$~" === instance.data) instance._reactRetry = callback;
      else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
        callback();
      else {
        var listener = function() {
          callback();
          ownerDocument.removeEventListener("DOMContentLoaded", listener);
        };
        ownerDocument.addEventListener("DOMContentLoaded", listener);
        instance._reactRetry = listener;
      }
    }
    function getNextHydratable(node) {
      for (; null != node; node = node.nextSibling) {
        var nodeType = node.nodeType;
        if (1 === nodeType || 3 === nodeType) break;
        if (8 === nodeType) {
          nodeType = node.data;
          if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType)
            break;
          if ("/$" === nodeType || "/&" === nodeType) return null;
        }
      }
      return node;
    }
    var previousHydratableOnEnteringScopedSingleton = null;
    function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
      hydrationInstance = hydrationInstance.nextSibling;
      for (var depth = 0; hydrationInstance; ) {
        if (8 === hydrationInstance.nodeType) {
          var data = hydrationInstance.data;
          if ("/$" === data || "/&" === data) {
            if (0 === depth)
              return getNextHydratable(hydrationInstance.nextSibling);
            depth--;
          } else
            "$" !== data && "$!" !== data && "$?" !== data && "$~" !== data && "&" !== data || depth++;
        }
        hydrationInstance = hydrationInstance.nextSibling;
      }
      return null;
    }
    function getParentHydrationBoundary(targetInstance) {
      targetInstance = targetInstance.previousSibling;
      for (var depth = 0; targetInstance; ) {
        if (8 === targetInstance.nodeType) {
          var data = targetInstance.data;
          if ("$" === data || "$!" === data || "$?" === data || "$~" === data || "&" === data) {
            if (0 === depth) return targetInstance;
            depth--;
          } else "/$" !== data && "/&" !== data || depth++;
        }
        targetInstance = targetInstance.previousSibling;
      }
      return null;
    }
    function resolveSingletonInstance(type, props, rootContainerInstance) {
      props = getOwnerDocumentFromRootContainer(rootContainerInstance);
      switch (type) {
        case "html":
          type = props.documentElement;
          if (!type) throw Error(formatProdErrorMessage(452));
          return type;
        case "head":
          type = props.head;
          if (!type) throw Error(formatProdErrorMessage(453));
          return type;
        case "body":
          type = props.body;
          if (!type) throw Error(formatProdErrorMessage(454));
          return type;
        default:
          throw Error(formatProdErrorMessage(451));
      }
    }
    function releaseSingletonInstance(instance) {
      for (var attributes = instance.attributes; attributes.length; )
        instance.removeAttributeNode(attributes[0]);
      detachDeletedInstance(instance);
    }
    var preloadPropsMap = /* @__PURE__ */ new Map();
    var preconnectsSet = /* @__PURE__ */ new Set();
    function getHoistableRoot(container) {
      return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
    }
    var previousDispatcher = ReactDOMSharedInternals.d;
    ReactDOMSharedInternals.d = {
      f: flushSyncWork,
      r: requestFormReset,
      D: prefetchDNS,
      C: preconnect,
      L: preload,
      m: preloadModule,
      X: preinitScript,
      S: preinitStyle,
      M: preinitModuleScript
    };
    function flushSyncWork() {
      var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
      return previousWasRendering || wasRendering;
    }
    function requestFormReset(form) {
      var formInst = getInstanceFromNode(form);
      null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
    }
    var globalDocument = "undefined" === typeof document ? null : document;
    function preconnectAs(rel, href, crossOrigin) {
      var ownerDocument = globalDocument;
      if (ownerDocument && "string" === typeof href && href) {
        var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
        limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
        "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
        preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
      }
    }
    function prefetchDNS(href) {
      previousDispatcher.D(href);
      preconnectAs("dns-prefetch", href, null);
    }
    function preconnect(href, crossOrigin) {
      previousDispatcher.C(href, crossOrigin);
      preconnectAs("preconnect", href, crossOrigin);
    }
    function preload(href, as, options2) {
      previousDispatcher.L(href, as, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href && as) {
        var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
        "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSrcSet
        ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
          options2.imageSizes
        ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
        var key = preloadSelector;
        switch (as) {
          case "style":
            key = getStyleKey(href);
            break;
          case "script":
            key = getScriptKey(href);
        }
        preloadPropsMap.has(key) || (href = assign(
          {
            rel: "preload",
            href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
            as
          },
          options2
        ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
      }
    }
    function preloadModule(href, options2) {
      previousDispatcher.m(href, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
        switch (as) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            key = getScriptKey(href);
        }
        if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
                return;
          }
          as = ownerDocument.createElement("link");
          setInitialProperties(as, "link", href);
          markNodeAsHoistable(as);
          ownerDocument.head.appendChild(as);
        }
      }
    }
    function preinitStyle(href, precedence, options2) {
      previousDispatcher.S(href, precedence, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && href) {
        var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
        precedence = precedence || "default";
        var resource = styles.get(key);
        if (!resource) {
          var state = { loading: 0, preload: null };
          if (resource = ownerDocument.querySelector(
            getStylesheetSelectorFromKey(key)
          ))
            state.loading = 5;
          else {
            href = assign(
              { rel: "stylesheet", href, "data-precedence": precedence },
              options2
            );
            (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
            var link = resource = ownerDocument.createElement("link");
            markNodeAsHoistable(link);
            setInitialProperties(link, "link", href);
            link._p = new Promise(function(resolve, reject) {
              link.onload = resolve;
              link.onerror = reject;
            });
            link.addEventListener("load", function() {
              state.loading |= 1;
            });
            link.addEventListener("error", function() {
              state.loading |= 2;
            });
            state.loading |= 4;
            insertStylesheet(resource, precedence, ownerDocument);
          }
          resource = {
            type: "stylesheet",
            instance: resource,
            count: 1,
            state
          };
          styles.set(key, resource);
        }
      }
    }
    function preinitScript(src, options2) {
      previousDispatcher.X(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    }
    function preinitModuleScript(src, options2) {
      previousDispatcher.M(src, options2);
      var ownerDocument = globalDocument;
      if (ownerDocument && src) {
        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
        resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
          type: "script",
          instance: resource,
          count: 1,
          state: null
        }, scripts.set(key, resource));
      }
    }
    function getResource(type, currentProps, pendingProps, currentResource) {
      var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
      if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
      switch (type) {
        case "meta":
        case "title":
          return null;
        case "style":
          return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        case "link":
          if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
            type = getStyleKey(pendingProps.href);
            var styles$243 = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, resource$244 = styles$243.get(type);
            resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: { loading: 0, preload: null }
            }, styles$243.set(type, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(
              getStylesheetSelectorFromKey(type)
            )) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
              rel: "preload",
              as: "style",
              href: pendingProps.href,
              crossOrigin: pendingProps.crossOrigin,
              integrity: pendingProps.integrity,
              media: pendingProps.media,
              hrefLang: pendingProps.hrefLang,
              referrerPolicy: pendingProps.referrerPolicy
            }, preloadPropsMap.set(type, pendingProps), styles$243 || preloadStylesheet(
              JSCompiler_inline_result,
              type,
              pendingProps,
              resource$244.state
            )));
            if (currentProps && null === currentResource)
              throw Error(formatProdErrorMessage(528, ""));
            return resource$244;
          }
          if (currentProps && null !== currentResource)
            throw Error(formatProdErrorMessage(529, ""));
          return null;
        case "script":
          return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
        default:
          throw Error(formatProdErrorMessage(444, type));
      }
    }
    function getStyleKey(href) {
      return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
    }
    function getStylesheetSelectorFromKey(key) {
      return 'link[rel="stylesheet"][' + key + "]";
    }
    function stylesheetPropsFromRawProps(rawProps) {
      return assign({}, rawProps, {
        "data-precedence": rawProps.precedence,
        precedence: null
      });
    }
    function preloadStylesheet(ownerDocument, key, preloadProps, state) {
      ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
        return state.loading |= 1;
      }), key.addEventListener("error", function() {
        return state.loading |= 2;
      }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
    }
    function getScriptKey(src) {
      return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
    }
    function getScriptSelectorFromKey(key) {
      return "script[async]" + key;
    }
    function acquireResource(hoistableRoot, resource, props) {
      resource.count++;
      if (null === resource.instance)
        switch (resource.type) {
          case "style":
            var instance = hoistableRoot.querySelector(
              'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
            );
            if (instance)
              return resource.instance = instance, markNodeAsHoistable(instance), instance;
            var styleProps = assign({}, props, {
              "data-href": props.href,
              "data-precedence": props.precedence,
              href: null,
              precedence: null
            });
            instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
              "style"
            );
            markNodeAsHoistable(instance);
            setInitialProperties(instance, "style", styleProps);
            insertStylesheet(instance, props.precedence, hoistableRoot);
            return resource.instance = instance;
          case "stylesheet":
            styleProps = getStyleKey(props.href);
            var instance$249 = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(styleProps)
            );
            if (instance$249)
              return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
            instance = stylesheetPropsFromRawProps(props);
            (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
            instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
            markNodeAsHoistable(instance$249);
            var linkInstance = instance$249;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance$249, "link", instance);
            resource.state.loading |= 4;
            insertStylesheet(instance$249, props.precedence, hoistableRoot);
            return resource.instance = instance$249;
          case "script":
            instance$249 = getScriptKey(props.src);
            if (styleProps = hoistableRoot.querySelector(
              getScriptSelectorFromKey(instance$249)
            ))
              return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
            instance = props;
            if (styleProps = preloadPropsMap.get(instance$249))
              instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
            hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
            styleProps = hoistableRoot.createElement("script");
            markNodeAsHoistable(styleProps);
            setInitialProperties(styleProps, "link", instance);
            hoistableRoot.head.appendChild(styleProps);
            return resource.instance = styleProps;
          case "void":
            return null;
          default:
            throw Error(formatProdErrorMessage(443, resource.type));
        }
      else
        "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
      return resource.instance;
    }
    function insertStylesheet(instance, precedence, root2) {
      for (var nodes = root2.querySelectorAll(
        'link[rel="stylesheet"][data-precedence],style[data-precedence]'
      ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        if (node.dataset.precedence === precedence) prior = node;
        else if (prior !== last) break;
      }
      prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
    }
    function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
      null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
      null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
      null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
    }
    function adoptPreloadPropsForScript(scriptProps, preloadProps) {
      null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
      null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
      null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
    }
    var tagCaches = null;
    function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
      if (null === tagCaches) {
        var cache = /* @__PURE__ */ new Map();
        var caches = tagCaches = /* @__PURE__ */ new Map();
        caches.set(ownerDocument, cache);
      } else
        caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
      if (cache.has(type)) return cache;
      cache.set(type, null);
      ownerDocument = ownerDocument.getElementsByTagName(type);
      for (caches = 0; caches < ownerDocument.length; caches++) {
        var node = ownerDocument[caches];
        if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
          var nodeKey = node.getAttribute(keyAttribute) || "";
          nodeKey = type + nodeKey;
          var existing = cache.get(nodeKey);
          existing ? existing.push(node) : cache.set(nodeKey, [node]);
        }
      }
      return cache;
    }
    function mountHoistable(hoistableRoot, type, instance) {
      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
      hoistableRoot.head.insertBefore(
        instance,
        "title" === type ? hoistableRoot.querySelector("head > title") : null
      );
    }
    function isHostHoistableType(type, props, hostContext) {
      if (1 === hostContext || null != props.itemProp) return false;
      switch (type) {
        case "meta":
        case "title":
          return true;
        case "style":
          if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
            break;
          return true;
        case "link":
          if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
            break;
          switch (props.rel) {
            case "stylesheet":
              return type = props.disabled, "string" === typeof props.precedence && null == type;
            default:
              return true;
          }
        case "script":
          if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
            return true;
      }
      return false;
    }
    function preloadResource(resource) {
      return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
    }
    function suspendResource(state, hoistableRoot, resource, props) {
      if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
        if (null === resource.instance) {
          var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
            getStylesheetSelectorFromKey(key)
          );
          if (instance) {
            hoistableRoot = instance._p;
            null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
            resource.state.loading |= 4;
            resource.instance = instance;
            markNodeAsHoistable(instance);
            return;
          }
          instance = hoistableRoot.ownerDocument || hoistableRoot;
          props = stylesheetPropsFromRawProps(props);
          (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
          instance = instance.createElement("link");
          markNodeAsHoistable(instance);
          var linkInstance = instance;
          linkInstance._p = new Promise(function(resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance, "link", props);
          resource.instance = instance;
        }
        null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
        state.stylesheets.set(resource, hoistableRoot);
        (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
      }
    }
    var estimatedBytesWithinLimit = 0;
    function waitForCommitToBeReady(state, timeoutOffset) {
      state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
      return 0 < state.count || 0 < state.imgCount ? function(commit) {
        var stylesheetTimer = setTimeout(function() {
          state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
          if (state.unsuspend) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        }, 6e4 + timeoutOffset);
        0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
        var imgTimer = setTimeout(
          function() {
            state.waitingForImages = false;
            if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          },
          (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset
        );
        state.unsuspend = commit;
        return function() {
          state.unsuspend = null;
          clearTimeout(stylesheetTimer);
          clearTimeout(imgTimer);
        };
      } : null;
    }
    function onUnsuspend() {
      this.count--;
      if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
        if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
        else if (this.unsuspend) {
          var unsuspend = this.unsuspend;
          this.unsuspend = null;
          unsuspend();
        }
      }
    }
    var precedencesByRoot = null;
    function insertSuspendedStylesheets(state, resources) {
      state.stylesheets = null;
      null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
    }
    function insertStylesheetIntoRoot(root2, resource) {
      if (!(resource.state.loading & 4)) {
        var precedences = precedencesByRoot.get(root2);
        if (precedences) var last = precedences.get(null);
        else {
          precedences = /* @__PURE__ */ new Map();
          precedencesByRoot.set(root2, precedences);
          for (var nodes = root2.querySelectorAll(
            "link[data-precedence],style[data-precedence]"
          ), i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
              precedences.set(node.dataset.precedence, node), last = node;
          }
          last && precedences.set(null, last);
        }
        nodes = resource.instance;
        node = nodes.getAttribute("data-precedence");
        i = precedences.get(node) || last;
        i === last && precedences.set(null, nodes);
        precedences.set(node, nodes);
        this.count++;
        last = onUnsuspend.bind(this);
        nodes.addEventListener("load", last);
        nodes.addEventListener("error", last);
        i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
        resource.state.loading |= 4;
      }
    }
    var HostTransitionContext = {
      $$typeof: REACT_CONTEXT_TYPE,
      Provider: null,
      Consumer: null,
      _currentValue: sharedNotPendingObject,
      _currentValue2: sharedNotPendingObject,
      _threadCount: 0
    };
    function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
      this.tag = 1;
      this.containerInfo = containerInfo;
      this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
      this.callbackPriority = 0;
      this.expirationTimes = createLaneMap(-1);
      this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = createLaneMap(0);
      this.hiddenUpdates = createLaneMap(null);
      this.identifierPrefix = identifierPrefix;
      this.onUncaughtError = onUncaughtError;
      this.onCaughtError = onCaughtError;
      this.onRecoverableError = onRecoverableError;
      this.pooledCache = null;
      this.pooledCacheLanes = 0;
      this.formState = formState;
      this.incompleteTransitions = /* @__PURE__ */ new Map();
    }
    function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
      containerInfo = new FiberRootNode(
        containerInfo,
        tag,
        hydrate,
        identifierPrefix,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        onDefaultTransitionIndicator,
        formState
      );
      tag = 1;
      true === isStrictMode && (tag |= 24);
      isStrictMode = createFiberImplClass(3, null, null, tag);
      containerInfo.current = isStrictMode;
      isStrictMode.stateNode = containerInfo;
      tag = createCache();
      tag.refCount++;
      containerInfo.pooledCache = tag;
      tag.refCount++;
      isStrictMode.memoizedState = {
        element: initialChildren,
        isDehydrated: hydrate,
        cache: tag
      };
      initializeUpdateQueue(isStrictMode);
      return containerInfo;
    }
    function getContextForSubtree(parentComponent) {
      if (!parentComponent) return emptyContextObject;
      parentComponent = emptyContextObject;
      return parentComponent;
    }
    function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
      parentComponent = getContextForSubtree(parentComponent);
      null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
      container = createUpdate(lane);
      container.payload = { element };
      callback = void 0 === callback ? null : callback;
      null !== callback && (container.callback = callback);
      element = enqueueUpdate(rootFiber, container, lane);
      null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
    }
    function markRetryLaneImpl(fiber, retryLane) {
      fiber = fiber.memoizedState;
      if (null !== fiber && null !== fiber.dehydrated) {
        var a = fiber.retryLane;
        fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
      }
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
    }
    function attemptContinuousHydration(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
        markRetryLaneIfNotHydrated(fiber, 67108864);
      }
    }
    function attemptHydrationAtCurrentPriority(fiber) {
      if (13 === fiber.tag || 31 === fiber.tag) {
        var lane = requestUpdateLane();
        lane = getBumpedLaneForHydrationByLane(lane);
        var root2 = enqueueConcurrentRenderForLane(fiber, lane);
        null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
        markRetryLaneIfNotHydrated(fiber, lane);
      }
    }
    var _enabled = true;
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var prevTransition = ReactSharedInternals.T;
      ReactSharedInternals.T = null;
      var previousPriority = ReactDOMSharedInternals.p;
      try {
        ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
      }
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (_enabled) {
        var blockedOn = findInstanceBlockingEvent(nativeEvent);
        if (null === blockedOn)
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          ), clearIfContinuousEvent(domEventName, nativeEvent);
        else if (queueIfContinuousEvent(
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ))
          nativeEvent.stopPropagation();
        else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
          for (; null !== blockedOn; ) {
            var fiber = getInstanceFromNode(blockedOn);
            if (null !== fiber)
              switch (fiber.tag) {
                case 3:
                  fiber = fiber.stateNode;
                  if (fiber.current.memoizedState.isDehydrated) {
                    var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                    if (0 !== lanes) {
                      var root2 = fiber;
                      root2.pendingLanes |= 2;
                      for (root2.entangledLanes |= 2; lanes; ) {
                        var lane = 1 << 31 - clz32(lanes);
                        root2.entanglements[1] |= lane;
                        lanes &= ~lane;
                      }
                      ensureRootIsScheduled(fiber);
                      0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, false));
                    }
                  }
                  break;
                case 31:
                case 13:
                  root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
              }
            fiber = findInstanceBlockingEvent(nativeEvent);
            null === fiber && dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            );
            if (fiber === blockedOn) break;
            blockedOn = fiber;
          }
          null !== blockedOn && nativeEvent.stopPropagation();
        } else
          dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            null,
            targetContainer
          );
      }
    }
    function findInstanceBlockingEvent(nativeEvent) {
      nativeEvent = getEventTarget(nativeEvent);
      return findInstanceBlockingTarget(nativeEvent);
    }
    var return_targetInst = null;
    function findInstanceBlockingTarget(targetNode) {
      return_targetInst = null;
      targetNode = getClosestInstanceFromNode(targetNode);
      if (null !== targetNode) {
        var nearestMounted = getNearestMountedFiber(targetNode);
        if (null === nearestMounted) targetNode = null;
        else {
          var tag = nearestMounted.tag;
          if (13 === tag) {
            targetNode = getSuspenseInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (31 === tag) {
            targetNode = getActivityInstanceFromFiber(nearestMounted);
            if (null !== targetNode) return targetNode;
            targetNode = null;
          } else if (3 === tag) {
            if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
              return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            targetNode = null;
          } else nearestMounted !== targetNode && (targetNode = null);
        }
      }
      return_targetInst = targetNode;
      return null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (getCurrentPriorityLevel()) {
            case ImmediatePriority:
              return 2;
            case UserBlockingPriority:
              return 8;
            case NormalPriority$1:
            case LowPriority:
              return 32;
            case IdlePriority:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var hasScheduledReplayAttempt = false;
    var queuedFocus = null;
    var queuedDrag = null;
    var queuedMouse = null;
    var queuedPointers = /* @__PURE__ */ new Map();
    var queuedPointerCaptures = /* @__PURE__ */ new Map();
    var queuedExplicitHydrationTargets = [];
    var discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
      " "
    );
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout":
          queuedPointers.delete(nativeEvent.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          queuedPointerCaptures.delete(nativeEvent.pointerId);
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
        return existingQueuedEvent = {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer]
        }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      blockedOn = existingQueuedEvent.targetContainers;
      null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
      return existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      switch (domEventName) {
        case "focusin":
          return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedFocus,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "dragenter":
          return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedDrag,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "mouseover":
          return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedMouse,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ), true;
        case "pointerover":
          var pointerId = nativeEvent.pointerId;
          queuedPointers.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointers.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          );
          return true;
        case "gotpointercapture":
          return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
            pointerId,
            accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedPointerCaptures.get(pointerId) || null,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            )
          ), true;
      }
      return false;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (null !== targetInst) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (null !== nearestMounted) {
          if (targetInst = nearestMounted.tag, 13 === targetInst) {
            if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (31 === targetInst) {
            if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
              queuedTarget.blockedOn = targetInst;
              runWithPriority(queuedTarget.priority, function() {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
            queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
            return;
          }
        }
      }
      queuedTarget.blockedOn = null;
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (null !== queuedEvent.blockedOn) return false;
      for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
        var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
        if (null === nextBlockedOn) {
          nextBlockedOn = queuedEvent.nativeEvent;
          var nativeEventClone = new nextBlockedOn.constructor(
            nextBlockedOn.type,
            nextBlockedOn
          );
          currentReplayingEvent = nativeEventClone;
          nextBlockedOn.target.dispatchEvent(nativeEventClone);
          currentReplayingEvent = null;
        } else
          return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
        targetContainers.shift();
      }
      return true;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = false;
      null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
      null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
      null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
      queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
      queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        replayUnblockedEvents
      )));
    }
    var lastScheduledReplayQueue = null;
    function scheduleReplayQueueIfNeeded(formReplayingQueue) {
      lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
        Scheduler.unstable_NormalPriority,
        function() {
          lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
          for (var i = 0; i < formReplayingQueue.length; i += 3) {
            var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
            if ("function" !== typeof submitterOrAction)
              if (null === findInstanceBlockingTarget(submitterOrAction || form))
                continue;
              else break;
            var formInst = getInstanceFromNode(form);
            null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
              formInst,
              {
                pending: true,
                data: formData,
                method: form.method,
                action: submitterOrAction
              },
              submitterOrAction,
              formData
            ));
          }
        }
      ));
    }
    function retryIfBlockedOn(unblocked) {
      function unblock(queuedEvent) {
        return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
      }
      null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
      null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
      null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      queuedPointers.forEach(unblock);
      queuedPointerCaptures.forEach(unblock);
      for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
        var queuedTarget = queuedExplicitHydrationTargets[i];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
        attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
      i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
      if (null != i)
        for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
          var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
          if ("function" === typeof submitterOrAction)
            formProps || scheduleReplayQueueIfNeeded(i);
          else if (formProps) {
            var action = null;
            if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
              if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                action = formProps.formAction;
              else {
                if (null !== findInstanceBlockingTarget(form)) continue;
              }
            else action = formProps.action;
            "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
            scheduleReplayQueueIfNeeded(i);
          }
        }
    }
    function defaultOnDefaultTransitionIndicator() {
      function handleNavigate(event) {
        event.canIntercept && "react-transition" === event.info && event.intercept({
          handler: function() {
            return new Promise(function(resolve) {
              return pendingResolve = resolve;
            });
          },
          focusReset: "manual",
          scroll: "manual"
        });
      }
      function handleNavigateComplete() {
        null !== pendingResolve && (pendingResolve(), pendingResolve = null);
        isCancelled || setTimeout(startFakeNavigation, 20);
      }
      function startFakeNavigation() {
        if (!isCancelled && !navigation.transition) {
          var currentEntry = navigation.currentEntry;
          currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
            state: currentEntry.getState(),
            info: "react-transition",
            history: "replace"
          });
        }
      }
      if ("object" === typeof navigation) {
        var isCancelled = false, pendingResolve = null;
        navigation.addEventListener("navigate", handleNavigate);
        navigation.addEventListener("navigatesuccess", handleNavigateComplete);
        navigation.addEventListener("navigateerror", handleNavigateComplete);
        setTimeout(startFakeNavigation, 100);
        return function() {
          isCancelled = true;
          navigation.removeEventListener("navigate", handleNavigate);
          navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
          navigation.removeEventListener("navigateerror", handleNavigateComplete);
          null !== pendingResolve && (pendingResolve(), pendingResolve = null);
        };
      }
    }
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
      var root2 = this._internalRoot;
      if (null === root2) throw Error(formatProdErrorMessage(409));
      var current = root2.current, lane = requestUpdateLane();
      updateContainerImpl(current, lane, children, root2, null, null);
    };
    ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
      var root2 = this._internalRoot;
      if (null !== root2) {
        this._internalRoot = null;
        var container = root2.containerInfo;
        updateContainerImpl(root2.current, 2, null, root2, null, null);
        flushSyncWork$1();
        container[internalContainerInstanceKey] = null;
      }
    };
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
      if (target) {
        var updatePriority = resolveUpdatePriority();
        target = { blockedOn: null, target, priority: updatePriority };
        for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
        queuedExplicitHydrationTargets.splice(i, 0, target);
        0 === i && attemptExplicitHydrationTarget(target);
      }
    };
    var isomorphicReactPackageVersion$jscomp$inline_1840 = React25.version;
    if ("19.2.3" !== isomorphicReactPackageVersion$jscomp$inline_1840)
      throw Error(
        formatProdErrorMessage(
          527,
          isomorphicReactPackageVersion$jscomp$inline_1840,
          "19.2.3"
        )
      );
    ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
      var fiber = componentOrElement._reactInternals;
      if (void 0 === fiber) {
        if ("function" === typeof componentOrElement.render)
          throw Error(formatProdErrorMessage(188));
        componentOrElement = Object.keys(componentOrElement).join(",");
        throw Error(formatProdErrorMessage(268, componentOrElement));
      }
      componentOrElement = findCurrentFiberUsingSlowPath(fiber);
      componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
      componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
      return componentOrElement;
    };
    var internals$jscomp$inline_2347 = {
      bundleType: 0,
      version: "19.2.3",
      rendererPackageName: "react-dom",
      currentDispatcherRef: ReactSharedInternals,
      reconcilerVersion: "19.2.3"
    };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber)
        try {
          rendererID = hook$jscomp$inline_2348.inject(
            internals$jscomp$inline_2347
          ), injectedHook = hook$jscomp$inline_2348;
        } catch (err) {
        }
    }
    var hook$jscomp$inline_2348;
    exports.createRoot = function(container, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError));
      options2 = createFiberRoot(
        container,
        1,
        false,
        null,
        null,
        isStrictMode,
        identifierPrefix,
        null,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator
      );
      container[internalContainerInstanceKey] = options2.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMRoot(options2);
    };
    exports.hydrateRoot = function(container, initialChildren, options2) {
      if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
      var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
      null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.formState && (formState = options2.formState));
      initialChildren = createFiberRoot(
        container,
        1,
        true,
        initialChildren,
        null != options2 ? options2 : null,
        isStrictMode,
        identifierPrefix,
        formState,
        onUncaughtError,
        onCaughtError,
        onRecoverableError,
        defaultOnDefaultTransitionIndicator
      );
      initialChildren.context = getContextForSubtree(null);
      options2 = initialChildren.current;
      isStrictMode = requestUpdateLane();
      isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
      identifierPrefix = createUpdate(isStrictMode);
      identifierPrefix.callback = null;
      enqueueUpdate(options2, identifierPrefix, isStrictMode);
      options2 = isStrictMode;
      initialChildren.current.lanes = options2;
      markRootUpdated$1(initialChildren, options2);
      ensureRootIsScheduled(initialChildren);
      container[internalContainerInstanceKey] = initialChildren.current;
      listenToAllSupportedEvents(container);
      return new ReactDOMHydrationRoot(initialChildren);
    };
    exports.version = "19.2.3";
  }
});

// node_modules/react-dom/client.js
var require_client = __commonJS({
  "node_modules/react-dom/client.js"(exports, module) {
    "use strict";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      if (false) {
        throw new Error("^_^");
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    if (true) {
      checkDCE();
      module.exports = require_react_dom_client_production();
    } else {
      module.exports = null;
    }
  }
});

// node_modules/@openai/apps-sdk-ui/dist/es/components/Button/Button.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime());

// node_modules/clsx/dist/clsx.mjs
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) {
    var o2 = e.length;
    for (t = 0; t < o2; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  } else for (f in e) e[f] && (n && (n += " "), n += f);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = "", o2 = arguments.length; f < o2; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_default = clsx;

// node_modules/@openai/apps-sdk-ui/dist/es/components/Button/Button.js
var import_react10 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/lib/helpers.js
var import_react = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/lib/environment.js
var META_ENV = typeof import.meta !== "undefined" ? import.meta.env : void 0;
var NODE_ENV = typeof process !== "undefined" && "production" ? "production" : "production";
var isDev = NODE_ENV === "development" || !!META_ENV?.DEV;
var isJSDomLike = typeof navigator !== "undefined" && /(jsdom|happy-dom)/i.test(navigator.userAgent) || typeof globalThis.happyDOM === "object";
var isTest = NODE_ENV === "test" || META_ENV?.MODE === "test" || isJSDomLike;
var hasWindow = typeof window !== "undefined";
var hasDocument = typeof document !== "undefined";
var canUseDOM = hasWindow && hasDocument;

// node_modules/@openai/apps-sdk-ui/dist/es/lib/helpers.js
var handlePressableMouseEnter = (evt) => {
  const target = evt.currentTarget;
  if (!(target instanceof HTMLElement)) {
    return;
  }
  const elementWidth = target.offsetWidth;
  let scale = 0.985;
  if (elementWidth <= 80) {
    scale = 0.96;
  } else if (elementWidth <= 150) {
    scale = 0.97;
  } else if (elementWidth <= 220) {
    scale = 0.98;
  } else if (elementWidth > 600) {
    scale = 0.995;
  }
  target.style.setProperty("--scale", scale.toString());
};
var waitForAnimationFrame = (cb, options) => {
  const runAfterTick = () => {
    const id = setTimeout(cb);
    return () => {
      clearTimeout(id);
    };
  };
  if (!canUseDOM || typeof window.requestAnimationFrame !== "function") {
    return runAfterTick();
  }
  const visibilityHidden = hasDocument && document.visibilityState === "hidden";
  if (visibilityHidden) {
    return runAfterTick();
  }
  let frames = options?.frames ?? 2;
  let animationFrame = window.requestAnimationFrame(function recurse() {
    frames -= 1;
    if (frames === 0) {
      cb();
    } else {
      animationFrame = window.requestAnimationFrame(recurse);
    }
  });
  return () => {
    if (typeof window.cancelAnimationFrame === "function") {
      window.cancelAnimationFrame(animationFrame);
    }
  };
};
var toCssVariables = (variables) => {
  const formattedVariables = Object.keys(variables).reduce((acc, variable) => {
    const value = variables[variable];
    if (value || value === 0) {
      const prefix = variable.startsWith("--") ? "" : "--";
      const formattedValue = typeof value === "number" ? `${value}px` : value;
      acc[`${prefix}${variable}`] = formattedValue;
    }
    return acc;
  }, {});
  return formattedVariables;
};
var preventDefaultHandler = (evt) => {
  evt.preventDefault();
};

// node_modules/@openai/apps-sdk-ui/dist/es/lib/renderHelpers.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react2 = __toESM(require_react());
var flattenTextNodes = (children) => {
  const nodes = import_react2.Children.toArray(children);
  const result = [];
  let buffer = "";
  const flush = () => {
    if (buffer !== "") {
      result.push(buffer);
      buffer = "";
    }
  };
  for (const node of nodes) {
    if (node == null || typeof node === "boolean") {
      continue;
    }
    if (typeof node === "string" || typeof node === "number") {
      buffer += String(node);
      continue;
    }
    flush();
    result.push(node);
  }
  flush();
  return result;
};
var wrapTextNodeSiblings = (children) => {
  const flattenedChildren = flattenTextNodes(children);
  const childrenCount = import_react2.Children.count(flattenedChildren);
  return import_react2.Children.map(flattenedChildren, (child) => {
    if (typeof child === "string" && !!child.trim()) {
      if (childrenCount <= 1) {
        return child;
      }
      return (0, import_jsx_runtime.jsx)("span", { children: child });
    }
    if ((0, import_react2.isValidElement)(child)) {
      const element = child;
      const { children: innerChildren, ...restProps } = element.props;
      if (innerChildren != null) {
        return (0, import_react2.cloneElement)(element, restProps, wrapTextNodeSiblings(innerChildren));
      }
      return element;
    }
    return child;
  });
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/AppsSDKUIProvider/internal.js
var import_react4 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/components/AppsSDKUIProvider/AppsSDKUIContext.js
var import_react3 = __toESM(require_react());
var AppsSDKUIContext = (0, import_react3.createContext)(null);

// node_modules/@openai/apps-sdk-ui/dist/es/components/Indicator/CircularProgress.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var import_react7 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/hooks/useSimulatedProgress.js
var import_react6 = __toESM(require_react());

// node_modules/usehooks-ts/dist/index.js
var import_react5 = __toESM(require_react(), 1);
var import_lodash = __toESM(require_lodash(), 1);
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react5.useLayoutEffect : import_react5.useEffect;
function useTimeout(callback, delay) {
  const savedCallback = (0, import_react5.useRef)(callback);
  useIsomorphicLayoutEffect(() => {
    savedCallback.current = callback;
  }, [callback]);
  (0, import_react5.useEffect)(() => {
    if (!delay && delay !== 0) {
      return;
    }
    const id = setTimeout(() => {
      savedCallback.current();
    }, delay);
    return () => {
      clearTimeout(id);
    };
  }, [delay]);
}

// node_modules/@openai/apps-sdk-ui/dist/es/components/Indicator/LoadingDots.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Indicator/LoadingIndicator.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Indicator/LoadingIndicator.module.css
var LoadingIndicator_default = {
  LoadingIndicator: "LoadingIndicator_LoadingIndicator",
  rotate: "LoadingIndicator_rotate"
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/Indicator/LoadingIndicator.js
var LoadingIndicator = ({ className, size: size4, strokeWidth, style, ...restProps }) => {
  return (0, import_jsx_runtime4.jsx)("div", { ...restProps, className: clsx_default(LoadingIndicator_default.LoadingIndicator, className), style: style || toCssVariables({
    "indicator-size": size4,
    "indicator-stroke": strokeWidth
  }) });
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/TransitionGroup.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var import_react9 = __toESM(require_react());

// node_modules/react-merge-refs/dist/index.mjs
function o(f) {
  return (r2) => {
    f.forEach((n) => {
      typeof n == "function" ? n(r2) : n != null && (n.current = r2);
    });
  };
}

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/getDisableAnimations.js
var getDisableAnimations_default = () => isTest;

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/shared.js
var import_react8 = __toESM(require_react());
var ChildrenWithKeys = (children, shouldThrow = false, componentName = "TransitionGroup") => {
  const validChildren = [];
  import_react8.Children.forEach(children, (child) => {
    if (child && typeof child === "object" && "key" in child && !!child.key) {
      validChildren.push(child);
    } else if (shouldThrow) {
      throw new Error(`Child elements of <${componentName} /> must include a \`key\``);
    }
  });
  return validChildren;
};
var noop = () => {
};
var useChildCallback = (cb) => {
  const ref = (0, import_react8.useRef)(cb);
  ref.current = cb;
  return (0, import_react8.useCallback)((element) => ref.current(element), []);
};
function computeNextRenderChildren(propChildrenArray, currentRenderChildren, createDefaultRenderChildProps, insertMethod) {
  const propChildKeyMap = propChildrenArray.reduce((acc, child) => ({ ...acc, [child.key]: 1 }), {});
  const currentRenderChildKeyMap = currentRenderChildren.reduce((acc, child) => ({ ...acc, [child.component.key]: 1 }), {});
  const newRenderChildren = propChildrenArray.filter((propChild) => !currentRenderChildKeyMap[propChild.key]).map(createDefaultRenderChildProps);
  const updatedCurrentChildren = currentRenderChildren.map((childProps) => ({
    ...childProps,
    component: propChildrenArray.find(({ key }) => key === childProps.component.key) || childProps.component,
    shouldRender: !!propChildKeyMap[childProps.component.key]
  }));
  return insertMethod === "append" ? updatedCurrentChildren.concat(newRenderChildren) : newRenderChildren.concat(updatedCurrentChildren);
}
function assertSingleChildWhenRef(componentName, ref, childrenCount) {
  if ((isTest || isDev) && ref && childrenCount > 1) {
    throw new Error(`Cannot use forwardRef with multiple children in <${componentName} />`);
  }
}

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/TransitionGroup.module.css
var TransitionGroup_default = {
  TransitionGroupChild: "TransitionGroup_TransitionGroupChild"
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/transitionReducer.js
var RESTING_TRANSITION_STATE = {
  enter: false,
  enterActive: false,
  exit: false,
  exitActive: false,
  interrupted: false
};
var getInitialTransitionState = (preventMountTransition) => ({
  ...RESTING_TRANSITION_STATE,
  enter: !preventMountTransition
});
var transitionReducer = (state, action) => {
  switch (action.type) {
    case "enter-before":
      return {
        enter: true,
        enterActive: false,
        exit: false,
        exitActive: false,
        interrupted: state.interrupted || state.exit
      };
    case "enter-active":
      return {
        enter: true,
        enterActive: true,
        exit: false,
        exitActive: false,
        interrupted: false
      };
    case "exit-before":
      return {
        enter: false,
        enterActive: false,
        exit: true,
        exitActive: false,
        interrupted: state.interrupted || state.enter
      };
    case "exit-active":
      return {
        enter: false,
        enterActive: false,
        exit: true,
        exitActive: true,
        interrupted: false
      };
    case "done":
    default:
      return RESTING_TRANSITION_STATE;
  }
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/TransitionGroup.js
var TransitionGroupChildInner = ({ ref: forwardedRef, as: TagName, children, className, transitionId, style, preventMountTransition, shouldRender, enterDuration, exitDuration, removeChild, onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete }) => {
  const [state, dispatch] = (0, import_react9.useReducer)(transitionReducer, getInitialTransitionState(preventMountTransition || false));
  const preventedMountTransition = (0, import_react9.useRef)(false);
  const elementRef = (0, import_react9.useRef)(null);
  const enterDurationRef = (0, import_react9.useRef)(enterDuration);
  enterDurationRef.current = enterDuration;
  const exitDurationRef = (0, import_react9.useRef)(exitDuration);
  exitDurationRef.current = exitDuration;
  const lastCallbackRef = (0, import_react9.useRef)(null);
  const triggerCallback = (0, import_react9.useCallback)((callbackType) => {
    const element = elementRef.current;
    if (!element || callbackType === lastCallbackRef.current) {
      return;
    }
    lastCallbackRef.current = callbackType;
    switch (callbackType) {
      case "enter":
        onEnter(element);
        break;
      case "enter-active":
        onEnterActive(element);
        break;
      case "enter-complete":
        onEnterComplete(element);
        break;
      case "exit":
        onExit(element);
        break;
      case "exit-active":
        onExitActive(element);
        break;
      case "exit-complete":
        onExitComplete(element);
        break;
      default:
        callbackType;
        break;
    }
  }, [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete]);
  import_react9.default.useLayoutEffect(() => {
    if (!shouldRender) {
      let exitTimeout;
      dispatch({ type: "exit-before" });
      triggerCallback("exit");
      const cancelAnimationFrame3 = waitForAnimationFrame(() => {
        dispatch({ type: "exit-active" });
        triggerCallback("exit-active");
        exitTimeout = window.setTimeout(() => {
          triggerCallback("exit-complete");
          removeChild();
        }, exitDurationRef.current);
      });
      return () => {
        cancelAnimationFrame3();
        if (exitTimeout !== void 0)
          clearTimeout(exitTimeout);
      };
    }
    if (preventMountTransition && !preventedMountTransition.current) {
      preventedMountTransition.current = true;
      return;
    }
    let enterTimeout;
    dispatch({ type: "enter-before" });
    triggerCallback("enter");
    const cancelAnimationFrame2 = waitForAnimationFrame(() => {
      dispatch({ type: "enter-active" });
      triggerCallback("enter-active");
      enterTimeout = window.setTimeout(() => {
        dispatch({ type: "done" });
        triggerCallback("enter-complete");
      }, enterDurationRef.current);
    });
    return () => {
      cancelAnimationFrame2();
      if (enterTimeout !== void 0)
        clearTimeout(enterTimeout);
    };
  }, [
    shouldRender,
    // This value is immutable after <TransitionGroup> is created, and does not change on re-renders.
    preventMountTransition,
    removeChild,
    triggerCallback
  ]);
  (0, import_react9.useEffect)(() => {
    return () => {
      preventedMountTransition.current = false;
    };
  }, []);
  return (0, import_jsx_runtime5.jsx)(TagName, { ref: o([elementRef, forwardedRef]), className: clsx_default(className, TransitionGroup_default.TransitionGroupChild), "data-transition-id": transitionId, style, "data-entering": state.enter ? "" : void 0, "data-entering-active": state.enterActive ? "" : void 0, "data-exiting": state.exit ? "" : void 0, "data-exiting-active": state.exitActive ? "" : void 0, "data-interrupted": state.interrupted ? "" : void 0, children });
};
var TransitionGroupChild = (props) => {
  const { enterMountDelay, preventMountTransition } = props;
  const mountDelay = !preventMountTransition && enterMountDelay != null ? enterMountDelay : null;
  const [mounted, setMounted] = (0, import_react9.useState)(mountDelay == null);
  useTimeout(() => setMounted(true), mounted ? null : mountDelay);
  return mounted ? (0, import_jsx_runtime5.jsx)(TransitionGroupChildInner, { ...props }) : null;
};
var TransitionGroup = (props) => {
  const { ref: forwardedRef, as: TagName = "span", children, className, transitionId, style, enterDuration = 0, exitDuration = 0, preventInitialTransition = true, enterMountDelay, insertMethod = "append", disableAnimations = getDisableAnimations_default() } = props;
  const onEnter = useChildCallback(props.onEnter ?? noop);
  const onEnterActive = useChildCallback(props.onEnterActive ?? noop);
  const onEnterComplete = useChildCallback(props.onEnterComplete ?? noop);
  const onExit = useChildCallback(props.onExit ?? noop);
  const onExitActive = useChildCallback(props.onExitActive ?? noop);
  const onExitComplete = useChildCallback(props.onExitComplete ?? noop);
  import_react9.Children.forEach(children, (child) => {
    if (child && !child.key) {
      throw new Error("Child elements of <TransitionGroup /> must include a `key`");
    }
  });
  const createDefaultRenderChildProps = (0, import_react9.useCallback)((child) => ({
    component: child,
    shouldRender: true,
    removeChild: () => {
      setRenderChildren((currentRenderChildren) => currentRenderChildren.filter((c) => child.key !== c.component.key));
    },
    onEnter,
    onEnterActive,
    onEnterComplete,
    onExit,
    onExitActive,
    onExitComplete
  }), [onEnter, onEnterActive, onEnterComplete, onExit, onExitActive, onExitComplete]);
  const [renderChildren, setRenderChildren] = (0, import_react9.useState)(() => {
    return ChildrenWithKeys(children).map((child) => ({
      ...createDefaultRenderChildProps(child),
      // Lock this value to whatever the value was on initial render of the TransitionGroup.
      // It doesn't make sense to change this once it is mounted.
      preventMountTransition: preventInitialTransition
    }));
  });
  (0, import_react9.useLayoutEffect)(() => {
    setRenderChildren((currentRenderChildren) => {
      const propChildrenArray = ChildrenWithKeys(children);
      return computeNextRenderChildren(propChildrenArray, currentRenderChildren, createDefaultRenderChildProps, insertMethod);
    });
  }, [children, insertMethod, createDefaultRenderChildProps]);
  assertSingleChildWhenRef("TransitionGroup", forwardedRef, import_react9.Children.count(children));
  if (disableAnimations) {
    return (0, import_jsx_runtime5.jsx)(import_jsx_runtime5.Fragment, { children: import_react9.Children.map(children, (child) => (0, import_jsx_runtime5.jsx)(
      TagName,
      {
        // @ts-expect-error -- TS is not happy about this forwardedRef, but it's fine.
        ref: forwardedRef,
        className,
        style,
        "data-transition-id": transitionId,
        children: child
      }
    )) });
  }
  return (0, import_jsx_runtime5.jsx)(import_jsx_runtime5.Fragment, { children: renderChildren.map(({ component, ...restProps }) => (0, import_jsx_runtime5.jsx)(TransitionGroupChild, { ...restProps, as: TagName, className, transitionId, enterDuration, exitDuration, enterMountDelay, style, ref: forwardedRef, children: component }, component.key)) });
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/Button/Button.module.css
var Button_default = {
  Button: "Button_Button",
  ButtonInner: "Button_ButtonInner",
  ButtonLoader: "Button_ButtonLoader"
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/Button/Button.js
var Button = (props) => {
  const {
    type = "button",
    color = "primary",
    variant = "solid",
    pill = true,
    uniform = false,
    size: size4 = "md",
    iconSize,
    gutterSize,
    loading,
    selected,
    block,
    opticallyAlign,
    children,
    className,
    onClick,
    disabled,
    disabledTone,
    // Defaults to `loading` state
    inert = loading,
    ...restProps
  } = props;
  const isInert = disabled || inert;
  const handleClick = (0, import_react10.useCallback)((e) => {
    if (disabled) {
      return;
    }
    onClick?.(e);
  }, [onClick, disabled]);
  return (0, import_jsx_runtime6.jsxs)("button", {
    type,
    className: clsx_default(Button_default.Button, className),
    "data-color": color,
    "data-variant": variant,
    "data-pill": pill ? "" : void 0,
    "data-uniform": uniform ? "" : void 0,
    "data-size": size4,
    "data-gutter-size": gutterSize,
    "data-icon-size": iconSize,
    "data-loading": loading ? "" : void 0,
    "data-selected": selected ? "" : void 0,
    "data-block": block ? "" : void 0,
    "data-optically-align": opticallyAlign,
    onPointerEnter: handlePressableMouseEnter,
    // Non-visual, accessible disablement
    // NOTE: Do not use literal `inert` because that is incorrect semantically
    disabled: isInert,
    "aria-disabled": isInert,
    tabIndex: isInert ? -1 : void 0,
    "data-disabled": disabled ? "" : void 0,
    "data-disabled-tone": disabled ? disabledTone : void 0,
    onClick: handleClick,
    ...restProps,
    children: [(0, import_jsx_runtime6.jsx)(TransitionGroup, { className: Button_default.ButtonLoader, enterDuration: 250, exitDuration: 150, children: loading && (0, import_jsx_runtime6.jsx)(LoadingIndicator, {}, "loader") }), (0, import_jsx_runtime6.jsx)("span", { className: Button_default.ButtonInner, children: wrapTextNodeSiblings(children) })]
  });
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/Button/CopyButton.js
var import_jsx_runtime756 = __toESM(require_jsx_runtime());
var import_react15 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AddMember.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AddSources.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Agent.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AgentMode.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AllGizmos.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AllProductsExplore.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Analytics.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AnalyzeData.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ApiKey.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ApiKeyAdmin.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ApiKeys.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ApiKeyServiceAccount.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Archive.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Array.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowBottomLeftSm.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowBottomRightSm.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowCurved.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowCurvedLeft.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowCurvedRight.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowCurvedRightXs.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowCurvedRightXs24px.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowDown.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowDownLg.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowDownSm.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowLeft.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowLeftLg.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowLeftSm.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowRight.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowRightLg.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowRightSm.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowRotateCcw.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowRotateCw.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowTopLeftSm.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowTopRightSm.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowUp.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowUpLg.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowUpRight.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ArrowUpSm.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AspectRatio11.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AspectRatio169.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AspectRatio34.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AspectRatio43.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AspectRatio916.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Assistant.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Astronout.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Atom.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AtSign.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Autocomplete.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AutoPairApps.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AutoSuggestedEdits.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AvatarFilledProfile.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/AvatarProfile.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Back10s.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Back15s.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BackgroundConversation.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BackLarge.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BackSmall.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BackToApp.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BalancingScale.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BarChart.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BarChartFilled.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Batch.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Batches.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Bell.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BellFilled.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Beta.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Bills.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Blend.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BlendingCurveSharp.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BlendingCurveSmooth.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BlendingCurveSubtle.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Bolt.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Book.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BookBookmark.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BookClock.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BookClosed.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BookOpen.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BookWrench.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Boolean.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Brain.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Branch.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BranchAlt.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Bug.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BuilderProfileCard.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BuildingWorkspace.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Business.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/BusinessFilled.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Cabinet.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Calendar.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CalendarAlt.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CalendarToday.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Camera.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CameraFilledPhoto.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CameraPhoto.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CaptionCcOff.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CaptionCcOn.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CaptionOff.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CaptionOn.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Card.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CaretDown.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CaretLeft.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CaretRight.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CaretUp.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Category.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Certificate.js
var import_jsx_runtime111 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Chart.js
var import_jsx_runtime112 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChartXAxis.js
var import_jsx_runtime113 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChartYAxis.js
var import_jsx_runtime114 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Chat.js
var import_jsx_runtime115 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChatCompose.js
var import_jsx_runtime116 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChatDashedCheckedTemp.js
var import_jsx_runtime117 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChatDashedTemp.js
var import_jsx_runtime118 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Chats.js
var import_jsx_runtime119 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChatTemporary.js
var import_jsx_runtime120 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChatTripleDots.js
var import_jsx_runtime121 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Check.js
var import_jsx_runtime122 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CheckCircle.js
var import_jsx_runtime123 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CheckCircleDashed.js
var import_jsx_runtime124 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CheckCircleFilled.js
var import_jsx_runtime125 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CheckLg.js
var import_jsx_runtime126 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CheckMd.js
var import_jsx_runtime127 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronDown.js
var import_jsx_runtime128 = __toESM(require_jsx_runtime());
var ChevronDown = (props) => (0, import_jsx_runtime128.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "currentColor", ...props, children: (0, import_jsx_runtime128.jsx)("path", { fillRule: "evenodd", d: "M4.293 8.293a1 1 0 0 1 1.414 0L12 14.586l6.293-6.293a1 1 0 1 1 1.414 1.414l-7 7a1 1 0 0 1-1.414 0l-7-7a1 1 0 0 1 0-1.414Z", clipRule: "evenodd" }) });
var ChevronDown_default = ChevronDown;

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronDownLg.js
var import_jsx_runtime129 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronDownMd.js
var import_jsx_runtime130 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronDownUp.js
var import_jsx_runtime131 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronDownVector.js
var import_jsx_runtime132 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronLeft.js
var import_jsx_runtime133 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronLeftLg.js
var import_jsx_runtime134 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronLeftMd.js
var import_jsx_runtime135 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronRight.js
var import_jsx_runtime136 = __toESM(require_jsx_runtime());
var ChevronRight = (props) => (0, import_jsx_runtime136.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "currentColor", ...props, children: (0, import_jsx_runtime136.jsx)("path", { fillRule: "evenodd", d: "M8.293 4.293a1 1 0 0 1 1.414 0l7 7a1 1 0 0 1 0 1.414l-7 7a1 1 0 0 1-1.414-1.414L14.586 12 8.293 5.707a1 1 0 0 1 0-1.414Z", clipRule: "evenodd" }) });
var ChevronRight_default = ChevronRight;

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronRightAlt.js
var import_jsx_runtime137 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronRightLg.js
var import_jsx_runtime138 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronRightMd.js
var import_jsx_runtime139 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronSmallDown.js
var import_jsx_runtime140 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronSmallLeft.js
var import_jsx_runtime141 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronSmallRight.js
var import_jsx_runtime142 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronSmallUp.js
var import_jsx_runtime143 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronUp.js
var import_jsx_runtime144 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronUpDown.js
var import_jsx_runtime145 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronUpLg.js
var import_jsx_runtime146 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ChevronUpMd.js
var import_jsx_runtime147 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Circle.js
var import_jsx_runtime148 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CircleDashed.js
var import_jsx_runtime149 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CircleQuestion.js
var import_jsx_runtime150 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ClappingBoardClosed.js
var import_jsx_runtime151 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ClappingBoardOpen.js
var import_jsx_runtime152 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Cleanup.js
var import_jsx_runtime153 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Clear.js
var import_jsx_runtime154 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Click.js
var import_jsx_runtime155 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Clip.js
var import_jsx_runtime156 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Clipboard.js
var import_jsx_runtime157 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ClipboardCopy.js
var import_jsx_runtime158 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Clock.js
var import_jsx_runtime159 = __toESM(require_jsx_runtime());
var Clock = (props) => (0, import_jsx_runtime159.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "currentColor", ...props, children: (0, import_jsx_runtime159.jsx)("path", { d: "M12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12C20 7.58172 16.4183 4 12 4ZM2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12ZM12 6C12.5523 6 13 6.44772 13 7V12C13 12.2652 12.8946 12.5196 12.7071 12.7071L10.2071 15.2071C9.81658 15.5976 9.18342 15.5976 8.79289 15.2071C8.40237 14.8166 8.40237 14.1834 8.79289 13.7929L11 11.5858V7C11 6.44772 11.4477 6 12 6Z", fill: "currentColor" }) });
var Clock_default = Clock;

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Clock10s.js
var import_jsx_runtime160 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Clock15s.js
var import_jsx_runtime161 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Clock20s.js
var import_jsx_runtime162 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Clock5s.js
var import_jsx_runtime163 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ClockOff.js
var import_jsx_runtime164 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CloseBold.js
var import_jsx_runtime165 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Code.js
var import_jsx_runtime166 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CodeSquareSlash.js
var import_jsx_runtime167 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Collapse.js
var import_jsx_runtime168 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CollapseLarge.js
var import_jsx_runtime169 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CollapseLeft.js
var import_jsx_runtime170 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CollapseLg.js
var import_jsx_runtime171 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CollapseRight.js
var import_jsx_runtime172 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CollapseSm.js
var import_jsx_runtime173 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CollapseSmall.js
var import_jsx_runtime174 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ColorTheme.js
var import_jsx_runtime175 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Comment.js
var import_jsx_runtime176 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Commit.js
var import_jsx_runtime177 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Compare.js
var import_jsx_runtime178 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CompareArrows.js
var import_jsx_runtime179 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Compass.js
var import_jsx_runtime180 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Complete.js
var import_jsx_runtime181 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ComposeCanvasEditStar.js
var import_jsx_runtime182 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ComposeDashedTemporary.js
var import_jsx_runtime183 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ComposeEditSquare.js
var import_jsx_runtime184 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Confetti.js
var import_jsx_runtime185 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ConfettiParty.js
var import_jsx_runtime186 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Connect.js
var import_jsx_runtime187 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ConnectApps.js
var import_jsx_runtime188 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ConnectedDynamicGpt.js
var import_jsx_runtime189 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ConnectorsConnectedApps.js
var import_jsx_runtime190 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Copy.js
var import_jsx_runtime191 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/CreditCard.js
var import_jsx_runtime192 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Credits.js
var import_jsx_runtime193 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Cube.js
var import_jsx_runtime194 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Cursor.js
var import_jsx_runtime195 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Customize.js
var import_jsx_runtime196 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DarkMode.js
var import_jsx_runtime197 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DataControls.js
var import_jsx_runtime198 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DeepSearchTelescope.js
var import_jsx_runtime199 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Delete.js
var import_jsx_runtime200 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DeleteAccount.js
var import_jsx_runtime201 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Desktop.js
var import_jsx_runtime202 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DiningEvents.js
var import_jsx_runtime203 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DisabledCursor.js
var import_jsx_runtime204 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Dock.js
var import_jsx_runtime205 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Document.js
var import_jsx_runtime206 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Documentation.js
var import_jsx_runtime207 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DollarCircle.js
var import_jsx_runtime208 = __toESM(require_jsx_runtime());
var DollarCircle = (props) => (0, import_jsx_runtime208.jsxs)("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "currentColor", ...props, children: [(0, import_jsx_runtime208.jsx)("path", { d: "M20 12C20 7.58172 16.4183 4 12 4C7.58172 4 4 7.58172 4 12C4 16.4183 7.58172 20 12 20C16.4183 20 20 16.4183 20 12ZM22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z", fill: "currentColor" }), (0, import_jsx_runtime208.jsx)("path", { d: "M11.0996 17.25V16.7725C10.4057 16.6136 9.68786 16.303 8.98926 15.8213C8.5801 15.5391 8.47665 14.9785 8.75879 14.5693C9.04097 14.1603 9.6016 14.0578 10.0107 14.3398C11.0844 15.0801 12.0786 15.1937 12.7334 15.041C13.4169 14.8816 13.5996 14.51 13.5996 14.2822C13.5995 13.9547 13.4792 13.7581 13.1963 13.5566C12.852 13.3116 12.3603 13.1315 11.7021 12.9004C11.1108 12.6927 10.3519 12.434 9.75879 12.0117C9.10449 11.5458 8.59972 10.8457 8.59961 9.82031C8.59961 8.49251 9.64509 7.60906 10.7383 7.27637C10.8559 7.24059 10.9765 7.21069 11.0996 7.18555V6.75C11.0996 6.25294 11.5029 5.84961 12 5.84961C12.4971 5.84961 12.9004 6.25294 12.9004 6.75V7.20508C13.4431 7.32441 13.9882 7.54853 14.502 7.89355C14.9144 8.17073 15.0242 8.73001 14.7471 9.14258C14.4699 9.55505 13.9106 9.66479 13.498 9.3877C12.7261 8.86929 11.882 8.80928 11.2617 8.99805C10.6051 9.19796 10.4004 9.5763 10.4004 9.82031C10.4005 10.1477 10.5208 10.3435 10.8037 10.5449C11.148 10.79 11.6395 10.9709 12.2979 11.2021C12.8893 11.4099 13.648 11.6684 14.2412 12.0908C14.8955 12.5569 15.4002 13.2569 15.4004 14.2822C15.4004 15.6256 14.333 16.5162 13.1416 16.7939C13.0624 16.8124 12.9819 16.8281 12.9004 16.8418V17.25C12.9004 17.7471 12.4971 18.1504 12 18.1504C11.5029 18.1504 11.0996 17.7471 11.0996 17.25Z", fill: "currentColor" })] });
var DollarCircle_default = DollarCircle;

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Dot.js
var import_jsx_runtime209 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DotsHorizontal.js
var import_jsx_runtime210 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DotsHorizontalCircle.js
var import_jsx_runtime211 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DotsHorizontalMoreMenu.js
var import_jsx_runtime212 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DotsVertical.js
var import_jsx_runtime213 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DotsVerticalCircle.js
var import_jsx_runtime214 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DotsVerticalMoreMenu.js
var import_jsx_runtime215 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DoubleChevronLeft.js
var import_jsx_runtime216 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DoubleChevronRight.js
var import_jsx_runtime217 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Download.js
var import_jsx_runtime218 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DownloadCircle.js
var import_jsx_runtime219 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DownloadGifWatermark.js
var import_jsx_runtime220 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DownloadSimple.js
var import_jsx_runtime221 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DownloadVideo.js
var import_jsx_runtime222 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DownloadVideoWatermark.js
var import_jsx_runtime223 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Dropdown.js
var import_jsx_runtime224 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/DropdownVector.js
var import_jsx_runtime225 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Dumbbell.js
var import_jsx_runtime226 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EarthTravelWorld.js
var import_jsx_runtime227 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Edit.js
var import_jsx_runtime228 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EditAlt.js
var import_jsx_runtime229 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EditDalleImage.js
var import_jsx_runtime230 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EditPencil.js
var import_jsx_runtime231 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EditStar.js
var import_jsx_runtime232 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EditXs.js
var import_jsx_runtime233 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Education.js
var import_jsx_runtime234 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Email.js
var import_jsx_runtime235 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EmojiAdd.js
var import_jsx_runtime236 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EmojiLists.js
var import_jsx_runtime237 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EmojiRemove.js
var import_jsx_runtime238 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EmojiSections.js
var import_jsx_runtime239 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EmojiWords.js
var import_jsx_runtime240 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EmptyCircle.js
var import_jsx_runtime241 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EmptyCircleFilled.js
var import_jsx_runtime242 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EnterLogin.js
var import_jsx_runtime243 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Enum.js
var import_jsx_runtime244 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Equal.js
var import_jsx_runtime245 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Error.js
var import_jsx_runtime246 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ExclamationMarkCircle.js
var import_jsx_runtime247 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ExitLogout.js
var import_jsx_runtime248 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Expand.js
var import_jsx_runtime249 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ExpandLarge.js
var import_jsx_runtime250 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ExpandLg.js
var import_jsx_runtime251 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ExpandMd.js
var import_jsx_runtime252 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ExpandSm.js
var import_jsx_runtime253 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ExpandSmall.js
var import_jsx_runtime254 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Explore.js
var import_jsx_runtime255 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ExploreSora.js
var import_jsx_runtime256 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ExternalLink.js
var import_jsx_runtime257 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Eye.js
var import_jsx_runtime258 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EyeClosed.js
var import_jsx_runtime259 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/EyeOff.js
var import_jsx_runtime260 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FeaturedWreath.js
var import_jsx_runtime261 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/File.js
var import_jsx_runtime262 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/File3d.js
var import_jsx_runtime263 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FileAudio.js
var import_jsx_runtime264 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FileBlank.js
var import_jsx_runtime265 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FileCode.js
var import_jsx_runtime266 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FileDocument.js
var import_jsx_runtime267 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FileImage.js
var import_jsx_runtime268 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FilePresentation.js
var import_jsx_runtime269 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FileSpreadsheet.js
var import_jsx_runtime270 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FileSpreedsheet.js
var import_jsx_runtime271 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FileUpload.js
var import_jsx_runtime272 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FileVideo.js
var import_jsx_runtime273 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FileZip.js
var import_jsx_runtime274 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Filter.js
var import_jsx_runtime275 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FineTuning.js
var import_jsx_runtime276 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FistBump.js
var import_jsx_runtime277 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Flag.js
var import_jsx_runtime278 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Flash.js
var import_jsx_runtime279 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Flask.js
var import_jsx_runtime280 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FlaskFilled.js
var import_jsx_runtime281 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Folder.js
var import_jsx_runtime282 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FolderDocumentsFinder.js
var import_jsx_runtime283 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FolderOpen.js
var import_jsx_runtime284 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FolderPlus.js
var import_jsx_runtime285 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FolderPlusAdd.js
var import_jsx_runtime286 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Folders.js
var import_jsx_runtime287 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FolderShared.js
var import_jsx_runtime288 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FolderSharedOpen.js
var import_jsx_runtime289 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FolderStuffed.js
var import_jsx_runtime290 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/FolderUnshare.js
var import_jsx_runtime291 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Followup.js
var import_jsx_runtime292 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Forum.js
var import_jsx_runtime293 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Forward.js
var import_jsx_runtime294 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Forward10s.js
var import_jsx_runtime295 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Forward15s.js
var import_jsx_runtime296 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Frozen.js
var import_jsx_runtime297 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Function.js
var import_jsx_runtime298 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Functions.js
var import_jsx_runtime299 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/GenerateSuggestedEdits.js
var import_jsx_runtime300 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Glasses.js
var import_jsx_runtime301 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Globe.js
var import_jsx_runtime302 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/GlobeAltRealTimeSearch.js
var import_jsx_runtime303 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/GlobeFilled.js
var import_jsx_runtime304 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/GlobeOffRealTimeSearch.js
var import_jsx_runtime305 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/GlobeRealTimeSearch.js
var import_jsx_runtime306 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/GlobeSpin.js
var import_jsx_runtime307 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Go.js
var import_jsx_runtime308 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/GoFilled.js
var import_jsx_runtime309 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Graduate.js
var import_jsx_runtime310 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/GraduationCap.js
var import_jsx_runtime311 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Grid.js
var import_jsx_runtime312 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/GridAlt.js
var import_jsx_runtime313 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Group.js
var import_jsx_runtime314 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/GroupFilled.js
var import_jsx_runtime315 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Groups.js
var import_jsx_runtime316 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Hamburger.js
var import_jsx_runtime317 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/HandBack.js
var import_jsx_runtime318 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/HandFront.js
var import_jsx_runtime319 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/HandPeace.js
var import_jsx_runtime320 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/HandRaised.js
var import_jsx_runtime321 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/HandRaisedHey.js
var import_jsx_runtime322 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/HandWavingBye.js
var import_jsx_runtime323 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/HapticFeedback.js
var import_jsx_runtime324 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Headphones.js
var import_jsx_runtime325 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Health.js
var import_jsx_runtime326 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Heart.js
var import_jsx_runtime327 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/HeartFilled.js
var import_jsx_runtime328 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/HeartFilledXs.js
var import_jsx_runtime329 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/HeartXs.js
var import_jsx_runtime330 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Help.js
var import_jsx_runtime331 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/History.js
var import_jsx_runtime332 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/HistoryOff.js
var import_jsx_runtime333 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/HistoryOn.js
var import_jsx_runtime334 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Home.js
var import_jsx_runtime335 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/HomeAlt.js
var import_jsx_runtime336 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Identity.js
var import_jsx_runtime337 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/IdentityMeSecure.js
var import_jsx_runtime338 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ImageCaption.js
var import_jsx_runtime339 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Images.js
var import_jsx_runtime340 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ImageSquare.js
var import_jsx_runtime341 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ImageSquarePictureLibrary.js
var import_jsx_runtime342 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ImageToText.js
var import_jsx_runtime343 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ImageWide.js
var import_jsx_runtime344 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ImageWideFilled.js
var import_jsx_runtime345 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ImageWidePictureLibrary.js
var import_jsx_runtime346 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Info.js
var import_jsx_runtime347 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/InfoCircle.js
var import_jsx_runtime348 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Inpaint.js
var import_jsx_runtime349 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/InpaintRespond.js
var import_jsx_runtime350 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Inspiration.js
var import_jsx_runtime351 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/InspirationFilled.js
var import_jsx_runtime352 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Interactiv.js
var import_jsx_runtime353 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/InternalKnowledge.js
var import_jsx_runtime354 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/InternalKnowledgeOptimizedForCircle.js
var import_jsx_runtime355 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Invoice.js
var import_jsx_runtime356 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Io.js
var import_jsx_runtime357 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/JumpToCaption.js
var import_jsx_runtime358 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Kettlebell.js
var import_jsx_runtime359 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Key.js
var import_jsx_runtime360 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Keyboard.js
var import_jsx_runtime361 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/KeyboardShortcut.js
var import_jsx_runtime362 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Lab.js
var import_jsx_runtime363 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Language.js
var import_jsx_runtime364 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Latency.js
var import_jsx_runtime365 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Lifesaver.js
var import_jsx_runtime366 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Lightbulb.js
var import_jsx_runtime367 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Lightbulb20.js
var import_jsx_runtime368 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Lightbulb22.js
var import_jsx_runtime369 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Lightbulb22Filled.js
var import_jsx_runtime370 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/LightbulbGlow.js
var import_jsx_runtime371 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/LightMode.js
var import_jsx_runtime372 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Link.js
var import_jsx_runtime373 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/LinkDisabledBold.js
var import_jsx_runtime374 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/LinkExternalWebsite.js
var import_jsx_runtime375 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/LocalServices.js
var import_jsx_runtime376 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Lock.js
var import_jsx_runtime377 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/LockKeyHole.js
var import_jsx_runtime378 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Logout.js
var import_jsx_runtime379 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Loop.js
var import_jsx_runtime380 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/LoopLong.js
var import_jsx_runtime381 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/LoopNormal.js
var import_jsx_runtime382 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/LoopShort.js
var import_jsx_runtime383 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/LoopXs.js
var import_jsx_runtime384 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Lotus.js
var import_jsx_runtime385 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Love.js
var import_jsx_runtime386 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MagnifyingGlassSearch.js
var import_jsx_runtime387 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MagnifyingGlassSmSearch.js
var import_jsx_runtime388 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Mail.js
var import_jsx_runtime389 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ManageHistory.js
var import_jsx_runtime390 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MapPin.js
var import_jsx_runtime391 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Maps.js
var import_jsx_runtime392 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MapsAddress.js
var import_jsx_runtime393 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MapsDirections.js
var import_jsx_runtime394 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MarkerCode.js
var import_jsx_runtime395 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MarkerData.js
var import_jsx_runtime396 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MarkerMultiple.js
var import_jsx_runtime397 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MarkerQuote.js
var import_jsx_runtime398 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Mcp.js
var import_jsx_runtime399 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Members.js
var import_jsx_runtime400 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MembersFilled.js
var import_jsx_runtime401 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MemoryFilledSm.js
var import_jsx_runtime402 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MemoryOffRemember.js
var import_jsx_runtime403 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MemoryOnRemember.js
var import_jsx_runtime404 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MemoryWriteSm.js
var import_jsx_runtime405 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Menu.js
var import_jsx_runtime406 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Menubar.js
var import_jsx_runtime407 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MenuInverted.js
var import_jsx_runtime408 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MenuSidebar.js
var import_jsx_runtime409 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Messaging.js
var import_jsx_runtime410 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Mic.js
var import_jsx_runtime411 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MicFilled.js
var import_jsx_runtime412 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MicFilledOff.js
var import_jsx_runtime413 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MicLgDictate.js
var import_jsx_runtime414 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MicOff.js
var import_jsx_runtime415 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MinimizeDown.js
var import_jsx_runtime416 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MinimizeLeft.js
var import_jsx_runtime417 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MinimizeRight.js
var import_jsx_runtime418 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MinimizeTop.js
var import_jsx_runtime419 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Minus.js
var import_jsx_runtime420 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MinusCircle.js
var import_jsx_runtime421 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MinusCircleFilled.js
var import_jsx_runtime422 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Mobile.js
var import_jsx_runtime423 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Moon.js
var import_jsx_runtime424 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MoonSunSystem.js
var import_jsx_runtime425 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MoreCircleMenuDots.js
var import_jsx_runtime426 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Music.js
var import_jsx_runtime427 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/MyGptProfileMe.js
var import_jsx_runtime428 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Name.js
var import_jsx_runtime429 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/NewsPaper.js
var import_jsx_runtime430 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Nodes.js
var import_jsx_runtime431 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Notebook.js
var import_jsx_runtime432 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/NotebookCheck.js
var import_jsx_runtime433 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/NotebookNarrow.js
var import_jsx_runtime434 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/NotebookPencil.js
var import_jsx_runtime435 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Notepad.js
var import_jsx_runtime436 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/NotificationBell.js
var import_jsx_runtime437 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/NotificationOffBell.js
var import_jsx_runtime438 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/NoTraining.js
var import_jsx_runtime439 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Number.js
var import_jsx_runtime440 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Object.js
var import_jsx_runtime441 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/On.js
var import_jsx_runtime442 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/OpenaiLogoBold.js
var import_jsx_runtime443 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/OpenaiLogoBoldBoundingBox.js
var import_jsx_runtime444 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/OpenaiLogoRegular.js
var import_jsx_runtime445 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/OpenaiLogoRegularBoundingBox.js
var import_jsx_runtime446 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/OpenaiLogoWebappVariable480.js
var import_jsx_runtime447 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/OpenLeft.js
var import_jsx_runtime448 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/OpenRight.js
var import_jsx_runtime449 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Operator.js
var import_jsx_runtime450 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Order.js
var import_jsx_runtime451 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PageBlank.js
var import_jsx_runtime452 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Paid.js
var import_jsx_runtime453 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Paperclip.js
var import_jsx_runtime454 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PaperclipAttach.js
var import_jsx_runtime455 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ParentControl.js
var import_jsx_runtime456 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PastedText.js
var import_jsx_runtime457 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Pause.js
var import_jsx_runtime458 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PauseCircle.js
var import_jsx_runtime459 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PauseCircleFilled.js
var import_jsx_runtime460 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PauseOutline.js
var import_jsx_runtime461 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PauseSm.js
var import_jsx_runtime462 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Paw.js
var import_jsx_runtime463 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Pencil.js
var import_jsx_runtime464 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PencilSparkle.js
var import_jsx_runtime465 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PencilSquare.js
var import_jsx_runtime466 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Pens.js
var import_jsx_runtime467 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Phone.js
var import_jsx_runtime468 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PhoneMissed.js
var import_jsx_runtime469 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PhoneRing.js
var import_jsx_runtime470 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PhoneWaves.js
var import_jsx_runtime471 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PictureInPicture.js
var import_jsx_runtime472 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Pin.js
var import_jsx_runtime473 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PinFilled.js
var import_jsx_runtime474 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PinWindow.js
var import_jsx_runtime475 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Plane.js
var import_jsx_runtime476 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlantDesk.js
var import_jsx_runtime477 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Play.js
var import_jsx_runtime478 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlayCircle.js
var import_jsx_runtime479 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlayCircleFilled.js
var import_jsx_runtime480 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Playground.js
var import_jsx_runtime481 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlayOutline.js
var import_jsx_runtime482 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlaySm.js
var import_jsx_runtime483 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlayTriangle.js
var import_jsx_runtime484 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Plugin.js
var import_jsx_runtime485 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PluginPuzzle.js
var import_jsx_runtime486 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Plus.js
var import_jsx_runtime487 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Plus14px.js
var import_jsx_runtime488 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlusCircle.js
var import_jsx_runtime489 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlusCircleAdd.js
var import_jsx_runtime490 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlusCircleFilled.js
var import_jsx_runtime491 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlusComposer.js
var import_jsx_runtime492 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlusFilled.js
var import_jsx_runtime493 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlusLg.js
var import_jsx_runtime494 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlusLg18pxAdd.js
var import_jsx_runtime495 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlusSm12px.js
var import_jsx_runtime496 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PlusSquareAdd.js
var import_jsx_runtime497 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PopOutWindow.js
var import_jsx_runtime498 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PresetDefault.js
var import_jsx_runtime499 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PresetSelected.js
var import_jsx_runtime500 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PrivacyIntern.js
var import_jsx_runtime501 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ProDiamond.js
var import_jsx_runtime502 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ProductTag.js
var import_jsx_runtime503 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ProFilledDiamond.js
var import_jsx_runtime504 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PullRequestClosed.js
var import_jsx_runtime505 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PullRequestDraft.js
var import_jsx_runtime506 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PullRequestMerged.js
var import_jsx_runtime507 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/PullRequestOpen.js
var import_jsx_runtime508 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Pulse.js
var import_jsx_runtime509 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Question.js
var import_jsx_runtime510 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/QuestionMark.js
var import_jsx_runtime511 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/QuestionMarkCircle.js
var import_jsx_runtime512 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/QuickStart.js
var import_jsx_runtime513 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Quote.js
var import_jsx_runtime514 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/QuoteReplyFilledQuoteXs.js
var import_jsx_runtime515 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/RadioSelected.js
var import_jsx_runtime516 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ReadingLevel.js
var import_jsx_runtime517 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Record.js
var import_jsx_runtime518 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Regenerate.js
var import_jsx_runtime519 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/RegenerateOff.js
var import_jsx_runtime520 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/RegenerateStar.js
var import_jsx_runtime521 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Reload.js
var import_jsx_runtime522 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/RemixMild.js
var import_jsx_runtime523 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/RemixMildXs.js
var import_jsx_runtime524 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/RemixStrong.js
var import_jsx_runtime525 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/RemixSubtle.js
var import_jsx_runtime526 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/RemoveForeverPermanently.js
var import_jsx_runtime527 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/RemoveRedEye.js
var import_jsx_runtime528 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Reply.js
var import_jsx_runtime529 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Report.js
var import_jsx_runtime530 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Resend.js
var import_jsx_runtime531 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ResetChat.js
var import_jsx_runtime532 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Resolution1080p.js
var import_jsx_runtime533 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Resolution360p.js
var import_jsx_runtime534 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Resolution480p.js
var import_jsx_runtime535 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Resolution720p.js
var import_jsx_runtime536 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/RestoreUntrash.js
var import_jsx_runtime537 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Rewind.js
var import_jsx_runtime538 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Robot.js
var import_jsx_runtime539 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/RobotHead.js
var import_jsx_runtime540 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/RobotHeadSad.js
var import_jsx_runtime541 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SavedFilledXs.js
var import_jsx_runtime542 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SavedXs.js
var import_jsx_runtime543 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Scales.js
var import_jsx_runtime544 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Scissor.js
var import_jsx_runtime545 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ScissorXs.js
var import_jsx_runtime546 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ScreenPosition.js
var import_jsx_runtime547 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Search.js
var import_jsx_runtime548 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SearchConnector.js
var import_jsx_runtime549 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SearchFeed.js
var import_jsx_runtime550 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SearchXs.js
var import_jsx_runtime551 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SelectText.js
var import_jsx_runtime552 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Settings.js
var import_jsx_runtime553 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SettingsCircle.js
var import_jsx_runtime554 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SettingsCog.js
var import_jsx_runtime555 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SettingsSlider.js
var import_jsx_runtime556 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SettingsWrench.js
var import_jsx_runtime557 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Share.js
var import_jsx_runtime558 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ShareChat.js
var import_jsx_runtime559 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ShareScreen.js
var import_jsx_runtime560 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ShareScreenFilled.js
var import_jsx_runtime561 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ShareScreenOff.js
var import_jsx_runtime562 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ShareScreenOffFilled.js
var import_jsx_runtime563 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ShieldCheck.js
var import_jsx_runtime564 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ShieldKey.js
var import_jsx_runtime565 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ShieldLock.js
var import_jsx_runtime566 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ShieldPerson.js
var import_jsx_runtime567 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ShoppingBag.js
var import_jsx_runtime568 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Shortcuts.js
var import_jsx_runtime569 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Shuffle.js
var import_jsx_runtime570 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Sidebar.js
var import_jsx_runtime571 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarCollapseLeft.js
var import_jsx_runtime572 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarCollapseRight.js
var import_jsx_runtime573 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarFloatingLeft.js
var import_jsx_runtime574 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarFloatingOpenLeft.js
var import_jsx_runtime575 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarFloatingOpenRight.js
var import_jsx_runtime576 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarFloatingRight.js
var import_jsx_runtime577 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarLeft.js
var import_jsx_runtime578 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarMenuMobile.js
var import_jsx_runtime579 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarMenuMobileBadgeCutout.js
var import_jsx_runtime580 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarOpenLeft.js
var import_jsx_runtime581 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarOpenLeftAlt.js
var import_jsx_runtime582 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarOpenRight.js
var import_jsx_runtime583 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarOpenRightAlt.js
var import_jsx_runtime584 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SidebarRight.js
var import_jsx_runtime585 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SimpleRelax.js
var import_jsx_runtime586 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SimpleSad.js
var import_jsx_runtime587 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SimpleSmile.js
var import_jsx_runtime588 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Skip.js
var import_jsx_runtime589 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Sleep.js
var import_jsx_runtime590 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Snorkle.js
var import_jsx_runtime591 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Snowflake.js
var import_jsx_runtime592 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SoraBasicPopcorn.js
var import_jsx_runtime593 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SoraProDirector.js
var import_jsx_runtime594 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SoundOffSimpleMute.js
var import_jsx_runtime595 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SoundOffSpeaker.js
var import_jsx_runtime596 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SoundOnReadOutLoudSpeaker.js
var import_jsx_runtime597 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Sparkle.js
var import_jsx_runtime598 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SparkleDouble.js
var import_jsx_runtime599 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SparkleFilledPlus.js
var import_jsx_runtime600 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SparklePlus.js
var import_jsx_runtime601 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Sparkles.js
var import_jsx_runtime602 = __toESM(require_jsx_runtime());
var Sparkles = (props) => (0, import_jsx_runtime602.jsxs)("svg", { width: "1em", height: "1em", viewBox: "0 0 24 24", fill: "currentColor", ...props, children: [(0, import_jsx_runtime602.jsx)("path", { fillRule: "evenodd", d: "M9.932 4.377A1.45 1.45 0 0 1 11.375 3c.8 0 1.403.638 1.443 1.377.205 3.787 3.003 6.59 6.784 6.794A1.474 1.474 0 0 1 21 12.636c0 .816-.655 1.428-1.406 1.465-3.775.187-6.571 2.985-6.776 6.772a1.45 1.45 0 0 1-1.443 1.377 1.45 1.45 0 0 1-1.443-1.377c-.205-3.787-3.002-6.585-6.777-6.772a1.472 1.472 0 0 1-1.405-1.464c0-.815.654-1.426 1.404-1.464 3.772-.187 6.573-3.004 6.778-6.796Zm1.443 2.87a8.875 8.875 0 0 1-5.395 5.389 8.847 8.847 0 0 1 5.395 5.369 8.847 8.847 0 0 1 5.41-5.374 8.884 8.884 0 0 1-5.41-5.384Z", clipRule: "evenodd" }), (0, import_jsx_runtime602.jsx)("path", { fillRule: "evenodd", d: "M19.25 3.75a1 1 0 1 0 0 2 1 1 0 0 0 0-2Zm-3 1a3 3 0 1 1 6 0 3 3 0 0 1-6 0Z", clipRule: "evenodd" })] });
var Sparkles_default = Sparkles;

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SparklesFilled.js
var import_jsx_runtime603 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Speak.js
var import_jsx_runtime604 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SpeechToText.js
var import_jsx_runtime605 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Speed.js
var import_jsx_runtime606 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SpeedometerLatencySpeed.js
var import_jsx_runtime607 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Spelling.js
var import_jsx_runtime608 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Spin.js
var import_jsx_runtime609 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SquareCheckboxUnchecked.js
var import_jsx_runtime610 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SquareCheckCheckboxChecked.js
var import_jsx_runtime611 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SquareCheckFilledCheckboxCheckedFilled.js
var import_jsx_runtime612 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SquareCode.js
var import_jsx_runtime613 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SquareFilledTableLegend.js
var import_jsx_runtime614 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SquareImage.js
var import_jsx_runtime615 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SquarePlus.js
var import_jsx_runtime616 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SquarePlusAlt.js
var import_jsx_runtime617 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SquareTableLegend.js
var import_jsx_runtime618 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SquareText.js
var import_jsx_runtime619 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Stack.js
var import_jsx_runtime620 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Star.js
var import_jsx_runtime621 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/StarFilled.js
var import_jsx_runtime622 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/StartStrokeMd.js
var import_jsx_runtime623 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Status.js
var import_jsx_runtime624 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Stethoscope.js
var import_jsx_runtime625 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/StickyNote.js
var import_jsx_runtime626 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Stop.js
var import_jsx_runtime627 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/StopCircle.js
var import_jsx_runtime628 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/StopCircleFilled.js
var import_jsx_runtime629 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/StopOutline.js
var import_jsx_runtime630 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/StopSm.js
var import_jsx_runtime631 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/StopStrokeMd.js
var import_jsx_runtime632 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Stopwatch.js
var import_jsx_runtime633 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Storage.js
var import_jsx_runtime634 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Storyboard.js
var import_jsx_runtime635 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/String.js
var import_jsx_runtime636 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Studio.js
var import_jsx_runtime637 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Stuff.js
var import_jsx_runtime638 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/StuffTools.js
var import_jsx_runtime639 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SubscriptionPlan.js
var import_jsx_runtime640 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SuggestEdit.js
var import_jsx_runtime641 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Suitcase.js
var import_jsx_runtime642 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SuitcaseFilledWorkBusiness.js
var import_jsx_runtime643 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SuitcaseWorkBusiness.js
var import_jsx_runtime644 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Sun.js
var import_jsx_runtime645 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/SystemMode.js
var import_jsx_runtime646 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TableCellFilled.js
var import_jsx_runtime647 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TableCellsFilled.js
var import_jsx_runtime648 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TableColumnFilled.js
var import_jsx_runtime649 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TableFilled.js
var import_jsx_runtime650 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TableRowFilled.js
var import_jsx_runtime651 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Tag.js
var import_jsx_runtime652 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Tap.js
var import_jsx_runtime653 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Tasks.js
var import_jsx_runtime654 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TBoneRaw.js
var import_jsx_runtime655 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Telescope.js
var import_jsx_runtime656 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Terminal.js
var import_jsx_runtime657 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TerminalLg.js
var import_jsx_runtime658 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Terms.js
var import_jsx_runtime659 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Text.js
var import_jsx_runtime660 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TextLonger.js
var import_jsx_runtime661 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TextPrompt.js
var import_jsx_runtime662 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TextShorter.js
var import_jsx_runtime663 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TextShorterConcise.js
var import_jsx_runtime664 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TextToSpeech.js
var import_jsx_runtime665 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ThumbDown.js
var import_jsx_runtime666 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ThumbDownFilled.js
var import_jsx_runtime667 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ThumbMixed.js
var import_jsx_runtime668 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ThumbnailLarge.js
var import_jsx_runtime669 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ThumbnailMedium.js
var import_jsx_runtime670 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ThumbnailSmall.js
var import_jsx_runtime671 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Thumbs.js
var import_jsx_runtime672 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ThumbUp.js
var import_jsx_runtime673 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ThumbUpFilled.js
var import_jsx_runtime674 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Timer.js
var import_jsx_runtime675 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Tools.js
var import_jsx_runtime676 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/ToolsSkills.js
var import_jsx_runtime677 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Translate.js
var import_jsx_runtime678 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Trash.js
var import_jsx_runtime679 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TrashRemove.js
var import_jsx_runtime680 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Trending.js
var import_jsx_runtime681 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TriangleExclamationErrorWarning.js
var import_jsx_runtime682 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TriangleExclamationFilledErrorWarning.js
var import_jsx_runtime683 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TrophyTop.js
var import_jsx_runtime684 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/TuningFork.js
var import_jsx_runtime685 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Unarchive.js
var import_jsx_runtime686 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Undo.js
var import_jsx_runtime687 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Unlink.js
var import_jsx_runtime688 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Unpin.js
var import_jsx_runtime689 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Upgrade.js
var import_jsx_runtime690 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/UpgradePlan.js
var import_jsx_runtime691 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/UploadDocuments.js
var import_jsx_runtime692 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Upscale.js
var import_jsx_runtime693 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/UpscaleXs.js
var import_jsx_runtime694 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Usage.js
var import_jsx_runtime695 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/User.js
var import_jsx_runtime696 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/UserAdd.js
var import_jsx_runtime697 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/UserGpts.js
var import_jsx_runtime698 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/UserHeart.js
var import_jsx_runtime699 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/UserLock.js
var import_jsx_runtime700 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Users.js
var import_jsx_runtime701 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/UserVoice.js
var import_jsx_runtime702 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Variation2v2.js
var import_jsx_runtime703 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VariationV21.js
var import_jsx_runtime704 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VariationV31.js
var import_jsx_runtime705 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VariationV32.js
var import_jsx_runtime706 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VariationV33.js
var import_jsx_runtime707 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VariationV41.js
var import_jsx_runtime708 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VariationV42.js
var import_jsx_runtime709 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VariationV43.js
var import_jsx_runtime710 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VariationV44.js
var import_jsx_runtime711 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VersionsV1.js
var import_jsx_runtime712 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Video.js
var import_jsx_runtime713 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VideoCaption.js
var import_jsx_runtime714 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VideoFilled.js
var import_jsx_runtime715 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VideoFilledOff.js
var import_jsx_runtime716 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VideoGrid.js
var import_jsx_runtime717 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VideoList.js
var import_jsx_runtime718 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Videos.js
var import_jsx_runtime719 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VideoToText.js
var import_jsx_runtime720 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Voice.js
var import_jsx_runtime721 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Voice4Bars.js
var import_jsx_runtime722 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Voice5BarsSoundwave.js
var import_jsx_runtime723 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VoiceBold.js
var import_jsx_runtime724 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VoiceInputAreaMobileFilledVoiceXs.js
var import_jsx_runtime725 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/VoiceLight.js
var import_jsx_runtime726 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Warning.js
var import_jsx_runtime727 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/WarningFilledWrapCenteredForCircle.js
var import_jsx_runtime728 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/WarningWrapCenteredForCircle.js
var import_jsx_runtime729 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Wave.js
var import_jsx_runtime730 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/WebsiteNetwork.js
var import_jsx_runtime731 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Whisk.js
var import_jsx_runtime732 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/WhisperAutoSubmit.js
var import_jsx_runtime733 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Widget.js
var import_jsx_runtime734 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/WidgetAdd.js
var import_jsx_runtime735 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Workspace.js
var import_jsx_runtime736 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/WorkWithApps.js
var import_jsx_runtime737 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Wreath.js
var import_jsx_runtime738 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/WriteAlt.js
var import_jsx_runtime739 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/WriteAlt2.js
var import_jsx_runtime740 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/Writing.js
var import_jsx_runtime741 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/X.js
var import_jsx_runtime742 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/XCircle.js
var import_jsx_runtime743 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/XCircleCrossedClose.js
var import_jsx_runtime744 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/XCircleFilled.js
var import_jsx_runtime745 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/XCircleFilledCrossedClose.js
var import_jsx_runtime746 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/XCrossed.js
var import_jsx_runtime747 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/XSquareCrossed.js
var import_jsx_runtime748 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/XSquareFilledCrossed.js
var import_jsx_runtime749 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/XXs.js
var import_jsx_runtime750 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Icon/svg/XXsCrossed.js
var import_jsx_runtime751 = __toESM(require_jsx_runtime());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/Animate.js
var import_jsx_runtime752 = __toESM(require_jsx_runtime());
var import_react11 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/AnimateLayout.js
var import_jsx_runtime753 = __toESM(require_jsx_runtime());
var import_react12 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/AnimateLayoutGroup.js
var import_jsx_runtime754 = __toESM(require_jsx_runtime());
var import_react13 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Transition/SlotTransitionGroup.js
var import_jsx_runtime755 = __toESM(require_jsx_runtime());
var import_react14 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Badge/index.js
var import_jsx_runtime757 = __toESM(require_jsx_runtime());
var import_react16 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Badge/Badge.module.css
var Badge_default = {
  Badge: "Badge_Badge"
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/Badge/index.js
var Badge = ({ children, className, variant = "soft", color = "secondary", size: size4 = "sm", pill, ...restMaybeAsChildProps }) => {
  return (0, import_jsx_runtime757.jsx)("div", { className: clsx_default(Badge_default.Badge, className), "data-color": color, "data-size": size4, "data-pill": pill ? "" : void 0, "data-variant": variant, ...restMaybeAsChildProps, children: wrapTextNodeSiblings(children) });
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/EmptyMessage/EmptyMessage.js
var import_jsx_runtime758 = __toESM(require_jsx_runtime());
var import_react17 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/components/EmptyMessage/EmptyMessage.module.css
var EmptyMessage_default = {
  EmptyMessage: "EmptyMessage_EmptyMessage",
  IconBadge: "EmptyMessage_IconBadge",
  Title: "EmptyMessage_Title",
  Description: "EmptyMessage_Description",
  ActionRow: "EmptyMessage_ActionRow"
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/EmptyMessage/EmptyMessage.js
var EmptyMessage = ({ children, className, fill = "static" }) => {
  return (0, import_jsx_runtime758.jsx)("div", { className: clsx_default(EmptyMessage_default.EmptyMessage, className), "data-fill": fill, children });
};
var Icon = ({ size: size4 = "md", color = "secondary", children, className }) => {
  return (0, import_jsx_runtime758.jsx)("div", { className: clsx_default(EmptyMessage_default.IconBadge, className), "data-size": size4, "data-color": color, children });
};
var Title = ({ children, className, color = "secondary" }) => {
  return (0, import_jsx_runtime758.jsx)("div", { className: clsx_default(EmptyMessage_default.Title, className), "data-color": color, children });
};
var Description = ({ children, className }) => {
  return (0, import_jsx_runtime758.jsx)("div", { className: clsx_default(EmptyMessage_default.Description, className), children });
};
var ActionRow = ({ children, className }) => {
  return (0, import_jsx_runtime758.jsx)("div", { className: clsx_default(EmptyMessage_default.ActionRow, className), children });
};
EmptyMessage.Icon = Icon;
EmptyMessage.Title = Title;
EmptyMessage.Description = Description;
EmptyMessage.ActionRow = ActionRow;

// node_modules/@openai/apps-sdk-ui/dist/es/components/Tooltip/CopyTooltip.js
var import_jsx_runtime769 = __toESM(require_jsx_runtime());

// node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var React7 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var React6 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// node_modules/@radix-ui/react-slot/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  Root: () => Slot,
  Slot: () => Slot,
  Slottable: () => Slottable,
  createSlot: () => createSlot,
  createSlottable: () => createSlottable
});
var React5 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-compose-refs/dist/index.mjs
var React4 = __toESM(require_react(), 1);
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i = 0; i < cleanups.length; i++) {
          const cleanup = cleanups[i];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return React4.useCallback(composeRefs(...refs), refs);
}

// node_modules/@radix-ui/react-slot/dist/index.mjs
var import_jsx_runtime759 = __toESM(require_jsx_runtime(), 1);
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot2 = React5.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = React5.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React5.Children.count(newElement) > 1) return React5.Children.only(null);
          return React5.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ (0, import_jsx_runtime759.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React5.isValidElement(newElement) ? React5.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ (0, import_jsx_runtime759.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot = /* @__PURE__ */ createSlot("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
  const SlotClone = React5.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (React5.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React5.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React5.cloneElement(children, props2);
    }
    return React5.Children.count(children) > 1 ? React5.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function createSlottable(ownerName) {
  const Slottable22 = ({ children }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime759.jsx)(import_jsx_runtime759.Fragment, { children });
  };
  Slottable22.displayName = `${ownerName}.Slottable`;
  Slottable22.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable22;
}
var Slottable = /* @__PURE__ */ createSlottable("Slottable");
function isSlottable(child) {
  return React5.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime760 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot2 = createSlot(`Primitive.${node}`);
  const Node2 = React6.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime760.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));
}

// node_modules/@radix-ui/react-visually-hidden/dist/index.mjs
var import_jsx_runtime761 = __toESM(require_jsx_runtime(), 1);
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME = "VisuallyHidden";
var VisuallyHidden = React7.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ (0, import_jsx_runtime761.jsx)(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
      }
    );
  }
);
VisuallyHidden.displayName = NAME;
var Root = VisuallyHidden;

// node_modules/@radix-ui/react-context/dist/index.mjs
var React8 = __toESM(require_react(), 1);
var import_jsx_runtime762 = __toESM(require_jsx_runtime(), 1);
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext32(rootComponentName, defaultContext) {
    const BaseContext = React8.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      const { scope, children, ...context } = props;
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const value = React8.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ (0, import_jsx_runtime762.jsx)(Context.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext22(consumerName, scope) {
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const context = React8.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext22];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return React8.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return React8.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext32, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return React8.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}

// node_modules/@radix-ui/primitive/dist/index.mjs
var canUseDOM2 = !!(typeof window !== "undefined" && window.document && window.document.createElement);
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React10 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs
var React9 = __toESM(require_react(), 1);
var useLayoutEffect22 = globalThis?.document ? React9.useLayoutEffect : () => {
};

// node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs
var React22 = __toESM(require_react(), 1);
var useInsertionEffect = React10[" useInsertionEffect ".trim().toString()] || useLayoutEffect22;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  if (true) {
    const isControlledRef = React10.useRef(prop !== void 0);
    React10.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = React10.useCallback(
    (nextValue) => {
      if (isControlled) {
        const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          onChangeRef.current?.(value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = React10.useState(defaultProp);
  const prevValueRef = React10.useRef(value);
  const onChangeRef = React10.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  React10.useEffect(() => {
    if (prevValueRef.current !== value) {
      onChangeRef.current?.(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction(value) {
  return typeof value === "function";
}
var SYNC_STATE = Symbol("RADIX:SYNC_STATE");

// node_modules/@radix-ui/react-presence/dist/index.mjs
var React23 = __toESM(require_react(), 1);
var React11 = __toESM(require_react(), 1);
function useStateMachine(initialState, machine) {
  return React11.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : React23.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef2(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? React23.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = React23.useState();
  const stylesRef = React23.useRef(null);
  const prevPresentRef = React23.useRef(present);
  const prevAnimationNameRef = React23.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  React23.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect22(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect22(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(CSS.escape(event.animationName));
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: React23.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function getElementRef2(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@radix-ui/react-id/dist/index.mjs
var React12 = __toESM(require_react(), 1);
var useReactId = React12[" useId ".trim().toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id, setId] = React12.useState(useReactId());
  useLayoutEffect22(() => {
    if (!deterministicId) setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id ? `radix-${id}` : "");
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var React15 = __toESM(require_react(), 1);

// node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs
var React13 = __toESM(require_react(), 1);
function useCallbackRef(callback) {
  const callbackRef = React13.useRef(callback);
  React13.useEffect(() => {
    callbackRef.current = callback;
  });
  return React13.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}

// node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs
var React14 = __toESM(require_react(), 1);
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);
  React14.useEffect(() => {
    const handleKeyDown2 = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown2, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown2, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}

// node_modules/@radix-ui/react-dismissable-layer/dist/index.mjs
var import_jsx_runtime763 = __toESM(require_jsx_runtime(), 1);
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = React15.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = React15.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = React15.useContext(DismissableLayerContext);
    const [node, setNode] = React15.useState(null);
    const ownerDocument = node?.ownerDocument ?? globalThis?.document;
    const [, force] = React15.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    React15.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    React15.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    React15.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ (0, import_jsx_runtime763.jsx)(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = React15.forwardRef((props, forwardedRef) => {
  const context = React15.useContext(DismissableLayerContext);
  const ref = React15.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  React15.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ (0, import_jsx_runtime763.jsx)(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);
  const isPointerInsideReactTreeRef = React15.useRef(false);
  const handleClickRef = React15.useRef(() => {
  });
  React15.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef(onFocusOutside);
  const isFocusInsideReactTreeRef = React15.useRef(false);
  React15.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}

// node_modules/@radix-ui/react-portal/dist/index.mjs
var React16 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime764 = __toESM(require_jsx_runtime(), 1);
var PORTAL_NAME = "Portal";
var Portal = React16.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = React16.useState(false);
  useLayoutEffect22(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? import_react_dom.default.createPortal(/* @__PURE__ */ (0, import_jsx_runtime764.jsx)(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal.displayName = PORTAL_NAME;

// node_modules/@radix-ui/react-use-size/dist/index.mjs
var React17 = __toESM(require_react(), 1);
function useSize(element) {
  const [size4, setSize] = React17.useState(void 0);
  useLayoutEffect22(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size4;
}

// node_modules/@radix-ui/react-popper/dist/index.mjs
var React20 = __toESM(require_react(), 1);

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
var yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
var lrPlacement = ["left", "right"];
var rlPlacement = ["right", "left"];
var tbPlacement = ["top", "bottom"];
var btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset4 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d) => getSideAxis(d.placement) === initialSideAxis ? d.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
var originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset4 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset4, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow2() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow2()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow2()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow2()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow2() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
var invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
var tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
var transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
var willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
var containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle2(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
var lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css = getComputedStyle2(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
var absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var hide2 = hide;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React18 = __toESM(require_react(), 1);
var import_react18 = __toESM(require_react(), 1);
var ReactDOM3 = __toESM(require_react_dom(), 1);
var isClient = typeof document !== "undefined";
var noop2 = function noop3() {
};
var index = isClient ? import_react18.useLayoutEffect : noop2;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  let length;
  let i;
  let keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length) return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      const key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React18.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React18.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React18.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = React18.useState(null);
  const [_floating, _setFloating] = React18.useState(null);
  const setReference = React18.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = React18.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React18.useRef(null);
  const floatingRef = React18.useRef(null);
  const dataRef = React18.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React18.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM3.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React18.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React18.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React18.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React18.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x = roundByDPR(elements.floating, data.x);
    const y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x + "px, " + y + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return React18.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var limitShift3 = (options, deps) => ({
  ...limitShift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var size3 = (options, deps) => ({
  ...size2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// node_modules/@radix-ui/react-arrow/dist/index.mjs
var React19 = __toESM(require_react(), 1);
var import_jsx_runtime765 = __toESM(require_jsx_runtime(), 1);
var NAME2 = "Arrow";
var Arrow = React19.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ (0, import_jsx_runtime765.jsx)(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ (0, import_jsx_runtime765.jsx)("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow.displayName = NAME2;
var Root2 = Arrow;

// node_modules/@radix-ui/react-popper/dist/index.mjs
var import_jsx_runtime766 = __toESM(require_jsx_runtime(), 1);
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = React20.useState(null);
  return /* @__PURE__ */ (0, import_jsx_runtime766.jsx)(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = React20.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = React20.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const anchorRef = React20.useRef(null);
    React20.useEffect(() => {
      const previousAnchor = anchorRef.current;
      anchorRef.current = virtualRef?.current || ref.current;
      if (previousAnchor !== anchorRef.current) {
        context.onAnchorChange(anchorRef.current);
      }
    });
    return virtualRef ? null : /* @__PURE__ */ (0, import_jsx_runtime766.jsx)(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);
var PopperContent = React20.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME, __scopePopper);
    const [content, setContent] = React20.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow4, setArrow] = React20.useState(null);
    const arrowSize = useSize(arrow4);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset3({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift3({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift3() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip3({ ...detectOverflowOptions }),
        size3({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow4 && arrow3({ element: arrow4, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide3({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef(onPlaced);
    useLayoutEffect22(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = React20.useState();
    useLayoutEffect22(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ (0, import_jsx_runtime766.jsx)(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ (0, import_jsx_runtime766.jsx)(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ (0, import_jsx_runtime766.jsx)(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME;
var ARROW_NAME = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = React20.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ (0, import_jsx_runtime766.jsx)(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime766.jsx)(
          Root2,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x = "";
    let y = "";
    if (placedSide === "bottom") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x = `${-arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x = `${rects.floating.width + arrowHeight}px`;
      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x, y } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root22 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow2 = PopperArrow;

// node_modules/@radix-ui/react-tooltip/dist/index.mjs
var dist_exports3 = {};
__export(dist_exports3, {
  Arrow: () => Arrow22,
  Content: () => Content2,
  Portal: () => Portal2,
  Provider: () => Provider,
  Root: () => Root3,
  Tooltip: () => Tooltip,
  TooltipArrow: () => TooltipArrow,
  TooltipContent: () => TooltipContent,
  TooltipPortal: () => TooltipPortal,
  TooltipProvider: () => TooltipProvider,
  TooltipTrigger: () => TooltipTrigger,
  Trigger: () => Trigger,
  createTooltipScope: () => createTooltipScope
});
var React21 = __toESM(require_react(), 1);
var import_jsx_runtime767 = __toESM(require_jsx_runtime(), 1);
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var PROVIDER_NAME = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);
var TooltipProvider = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const isOpenDelayedRef = React21.useRef(true);
  const isPointerInTransitRef = React21.useRef(false);
  const skipDelayTimerRef = React21.useRef(0);
  React21.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayedRef,
      delayDuration,
      onOpen: React21.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        isOpenDelayedRef.current = false;
      }, []),
      onClose: React21.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => isOpenDelayedRef.current = true,
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: React21.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider.displayName = PROVIDER_NAME;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope(__scopeTooltip);
  const [trigger, setTrigger] = React21.useState(null);
  const contentId = useId();
  const openTimerRef = React21.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = React21.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange?.(open2);
    },
    caller: TOOLTIP_NAME
  });
  const stateAttribute = React21.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = React21.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = React21.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = React21.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  React21.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(Root22, { ...popperScope, children: /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger,
      onTriggerChange: setTrigger,
      onTriggerEnter: React21.useCallback(() => {
        if (providerContext.isOpenDelayedRef.current) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
      onTriggerLeave: React21.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip.displayName = TOOLTIP_NAME;
var TRIGGER_NAME = "TooltipTrigger";
var TooltipTrigger = React21.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const ref = React21.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = React21.useRef(false);
    const hasPointerMoveOpenedRef = React21.useRef(false);
    const handlePointerUp = React21.useCallback(() => isPointerDownRef.current = false, []);
    React21.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          if (context.open) {
            context.onClose();
          }
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME2 = "TooltipPortal";
var [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME2, {
  forceMount: void 0
});
var TooltipPortal = (props) => {
  const { __scopeTooltip, forceMount, children, container } = props;
  const context = useTooltipContext(PORTAL_NAME2, __scopeTooltip);
  return /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(PortalProvider, { scope: __scopeTooltip, forceMount, children: /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(Portal, { asChild: true, container, children }) }) });
};
TooltipPortal.displayName = PORTAL_NAME2;
var CONTENT_NAME2 = "TooltipContent";
var TooltipContent = React21.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME2, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME2, props.__scopeTooltip);
    return /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = React21.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME2, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME2, props.__scopeTooltip);
  const ref = React21.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = React21.useState(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = React21.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = React21.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  React21.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  React21.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
  React21.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var Slottable2 = createSlottable("TooltipContent");
var TooltipContentImpl = React21.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME2, __scopeTooltip);
    const popperScope = usePopperScope(__scopeTooltip);
    const { onClose } = context;
    React21.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    React21.useEffect(() => {
      if (context.trigger) {
        const handleScroll = (event) => {
          const target = event.target;
          if (target?.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll, { capture: true });
      }
    }, [context.trigger, onClose]);
    return /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ (0, import_jsx_runtime767.jsxs)(
          Content,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(Slottable2, { children }),
              /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(Root, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent.displayName = CONTENT_NAME2;
var ARROW_NAME2 = "TooltipArrow";
var TooltipArrow = React21.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME2,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ (0, import_jsx_runtime767.jsx)(Arrow2, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME2;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x, y } = point;
  let inside = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const ii = polygon[i];
    const jj = polygon[j];
    const xi = ii.x;
    const yi = ii.y;
    const xj = jj.x;
    const yj = jj.y;
    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a, b) => {
    if (a.x < b.x) return -1;
    else if (a.x > b.x) return 1;
    else if (a.y < b.y) return -1;
    else if (a.y > b.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    while (upperHull.length >= 2) {
      const q = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q.x - r2.x) * (p.y - r2.y) >= (q.y - r2.y) * (p.x - r2.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i = points.length - 1; i >= 0; i--) {
    const p = points[i];
    while (lowerHull.length >= 2) {
      const q = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q.x - r2.x) * (p.y - r2.y) >= (q.y - r2.y) * (p.x - r2.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider = TooltipProvider;
var Root3 = Tooltip;
var Trigger = TooltipTrigger;
var Portal2 = TooltipPortal;
var Content2 = TooltipContent;
var Arrow22 = TooltipArrow;

// node_modules/@openai/apps-sdk-ui/dist/es/components/Tooltip/CopyTooltip.js
var import_react22 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/components/Tooltip/Tooltip.js
var import_jsx_runtime768 = __toESM(require_jsx_runtime());
var import_react21 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/hooks/useEscCloseStack.js
var import_react20 = __toESM(require_react());

// node_modules/@openai/apps-sdk-ui/dist/es/hooks/useLatestValue.js
var import_react19 = __toESM(require_react());
function useLatestValue(value) {
  const ref = (0, import_react19.useRef)(value);
  ref.current = value;
  return ref;
}

// node_modules/@openai/apps-sdk-ui/dist/es/hooks/useEscCloseStack.js
var handlers = [];
var listenerBound = false;
var handleKeyDown = (evt) => {
  if (evt.key === "Escape") {
    const [firstHandler] = handlers;
    if (firstHandler) {
      evt.preventDefault();
      firstHandler.callback.current?.();
    }
  }
};
var managerListener = () => {
  if (handlers.length > 0 && !listenerBound) {
    document.body.addEventListener("keydown", handleKeyDown);
    listenerBound = true;
  } else if (handlers.length === 0 && listenerBound) {
    document.body.removeEventListener("keydown", handleKeyDown);
    listenerBound = false;
  }
};
var registerHandler = (handler) => {
  handlers.unshift(handler);
  managerListener();
};
var unregisterHandler = ({ id }) => {
  handlers = handlers.filter((h) => h.id !== id);
  managerListener();
};
var useEscCloseStack = (listening, cb) => {
  const id = (0, import_react20.useId)();
  const latestCallback = useLatestValue(cb);
  (0, import_react20.useEffect)(() => {
    if (!listening) {
      return;
    }
    const handler = { id, callback: latestCallback };
    registerHandler(handler);
    return () => unregisterHandler(handler);
  }, [id, listening, latestCallback]);
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/Tooltip/Tooltip.module.css
var Tooltip_default = {
  Tooltip: "Tooltip_Tooltip",
  "scale-in": "Tooltip_scale-in",
  "scale-out": "Tooltip_scale-out",
  TriggerDecorator: "Tooltip_TriggerDecorator"
};

// node_modules/@openai/apps-sdk-ui/dist/es/components/Tooltip/Tooltip.js
var Tooltip2 = (props) => {
  const { ref: forwardedRef, children, content, forceOpen = content === null ? false : void 0, maxWidth = 300, openDelay = 150, interactive = false, compact = false, preventUnintentionalClickToClose, align, alignOffset = 0, side, sideOffset = 5, gutterSize = "md", contentClassName, onPointerDown, onClick, ...restProps } = props;
  const [visible, setVisible] = (0, import_react21.useState)(false);
  const [temporarilyPreventClickToClose, setTemporarilyPreventClickToClose] = (0, import_react21.useState)(false);
  useTimeout(() => setTemporarilyPreventClickToClose(false), temporarilyPreventClickToClose ? 400 : null);
  const open = forceOpen ?? visible;
  const handleOpenChange = (nextState) => {
    if (typeof forceOpen === "boolean")
      return;
    setVisible(nextState);
    if (preventUnintentionalClickToClose) {
      setTemporarilyPreventClickToClose(nextState);
    }
  };
  const maybePreventClickClose = (evt) => {
    if (preventUnintentionalClickToClose && temporarilyPreventClickToClose) {
      evt.preventDefault();
      evt.stopPropagation();
    }
  };
  return (0, import_jsx_runtime768.jsxs)(Root4, { open, delayDuration: openDelay, onOpenChange: handleOpenChange, disableHoverableContent: !interactive, children: [(0, import_jsx_runtime768.jsx)(dist_exports3.Trigger, { asChild: true, children: (0, import_jsx_runtime768.jsx)(dist_exports.Root, { ...restProps, ref: forwardedRef, onPointerDown: (evt) => {
    maybePreventClickClose(evt);
    onPointerDown?.(evt);
  }, onClick: (evt) => {
    maybePreventClickClose(evt);
    onClick?.(evt);
  }, children }) }), (0, import_jsx_runtime768.jsx)(Content3, { maxWidth, compact, align, alignOffset, side, sideOffset, gutterSize, className: contentClassName, children: content })] });
};
var Root4 = ({ children, open, onOpenChange, ...restProps }) => {
  useEscCloseStack(open, () => {
    onOpenChange(false);
  });
  return (0, import_jsx_runtime768.jsx)(dist_exports3.Provider, { children: (0, import_jsx_runtime768.jsx)(dist_exports3.Root, { open, onOpenChange, ...restProps, children }) });
};
var Content3 = ({ children, maxWidth = 300, compact = false, clickable = void 0, alignOffset = 0, sideOffset = 5, gutterSize = "md", className, style, ...restProps }) => {
  return (0, import_jsx_runtime768.jsx)(dist_exports3.Portal, { children: (0, import_jsx_runtime768.jsx)(dist_exports3.Content, { ...restProps, className: clsx_default(Tooltip_default.Tooltip, className), "data-compact": compact, "data-clickable": clickable, "data-gutter-size": gutterSize, alignOffset, sideOffset, collisionPadding: 15, hideWhenDetached: true, style: {
    ...style,
    maxWidth
  }, onEscapeKeyDown: preventDefaultHandler, children }) });
};
var Trigger2 = ({ children, asChild = true, ...restProps }) => {
  return (0, import_jsx_runtime768.jsx)(dist_exports3.Trigger, { asChild, ...restProps, children });
};
var TriggerDecorator = (props) => {
  const { children, className, focusable = true, ref, ...restProps } = props;
  const isPlainText = typeof children === "string";
  return (0, import_jsx_runtime768.jsx)(dist_exports.Root, { ref, ...restProps, className: clsx_default(Tooltip_default.TriggerDecorator, className), tabIndex: focusable ? 0 : void 0, children: isPlainText ? (0, import_jsx_runtime768.jsx)("span", { children }) : children });
};
Tooltip2.Root = Root4;
Tooltip2.Content = Content3;
Tooltip2.Trigger = Trigger2;
Tooltip2.TriggerDecorator = TriggerDecorator;

// src/apps/multiversx-delegations/index.tsx
var import_react25 = __toESM(require_react(), 1);
var import_client = __toESM(require_client(), 1);

// src/lib/hooks/useOpenAiGlobal.ts
var import_react23 = __toESM(require_react(), 1);

// src/lib/hooks/types.ts
var SET_GLOBALS_EVENT_TYPE = "openai:set_globals";

// src/lib/hooks/useOpenAiGlobal.ts
function useOpenAiGlobal(key) {
  const onChangeRef = (0, import_react23.useRef)(null);
  const value = (0, import_react23.useSyncExternalStore)(
    (onChange) => {
      onChangeRef.current = onChange;
      const handleSetGlobal = (event) => {
        const value2 = event.detail.globals[key];
        if (value2 === void 0) {
          return;
        }
        onChange();
      };
      window.addEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobal, {
        passive: true
      });
      return () => {
        window.removeEventListener(SET_GLOBALS_EVENT_TYPE, handleSetGlobal);
        onChangeRef.current = null;
      };
    },
    () => {
      try {
        return window.openai?.[key] ?? void 0;
      } catch (error) {
        console.error("Error accessing window.openai:", error);
        return void 0;
      }
    },
    () => {
      return void 0;
    }
  );
  (0, import_react23.useEffect)(() => {
    const handleMessage = (event) => {
      if (event.data && event.data.type === "openai:set_globals" && event.data.globals) {
        const value2 = event.data.globals[key];
        if (value2 !== void 0 && onChangeRef.current) {
          onChangeRef.current();
        }
      }
    };
    window.addEventListener("message", handleMessage);
    if (!window.openai) {
      let checkCount = 0;
      const maxChecks = 100;
      const checkTimer = setInterval(() => {
        checkCount++;
        if (window.openai && onChangeRef.current) {
          onChangeRef.current();
          clearInterval(checkTimer);
        } else if (checkCount >= maxChecks) {
          clearInterval(checkTimer);
        }
      }, 50);
      return () => {
        clearInterval(checkTimer);
        window.removeEventListener("message", handleMessage);
      };
    }
    return () => {
      window.removeEventListener("message", handleMessage);
    };
  }, [key]);
  return value;
}

// src/lib/hooks/useToolOutput.ts
function useToolOutput() {
  const toolOutput = useOpenAiGlobal("toolOutput");
  return toolOutput;
}

// src/lib/hooks/useWidgetState.ts
var import_react24 = __toESM(require_react(), 1);

// src/apps/multiversx-delegations/helpers.ts
function formatEgld(value) {
  if (typeof value === "number") {
    return value.toFixed(4);
  }
  const num = BigInt(value);
  const divisor = BigInt(10 ** 18);
  const whole = num / divisor;
  const remainder = num % divisor;
  const decimal = remainder.toString().padStart(18, "0").slice(0, 4);
  return `${whole}.${decimal}`;
}
function shortenAddress(address) {
  if (address.length <= 16) return address;
  return `${address.slice(0, 8)}...${address.slice(-6)}`;
}

// src/apps/multiversx-delegations/index.tsx
var import_jsx_runtime770 = __toESM(require_jsx_runtime(), 1);
function DelegationCard({ delegation }) {
  const [expanded, setExpanded] = (0, import_react25.useState)(false);
  const activeStake = formatEgld(delegation.userActiveStake);
  const rewards = formatEgld(delegation.claimableRewards);
  const unbondable = formatEgld(delegation.userUnBondable);
  const hasUndelegated = delegation.userUndelegatedList.length > 0;
  const hasUnbondable = BigInt(delegation.userUnBondable) > 0;
  return /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("div", { className: "rounded-2xl border border-default bg-surface p-4", children: [
    /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("div", { className: "flex justify-between items-start mb-3", children: [
      /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("div", { className: "flex-1 min-w-0", children: [
        /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("p", { className: "text-secondary text-sm", children: "Provider" }),
        /* @__PURE__ */ (0, import_jsx_runtime770.jsx)(Tooltip2, { content: delegation.contract, children: /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("p", { className: "font-mono text-sm truncate cursor-help", children: shortenAddress(delegation.contract) }) })
      ] }),
      hasUndelegated && /* @__PURE__ */ (0, import_jsx_runtime770.jsx)(Badge, { color: "warning", className: "ml-2 shrink-0", children: "Pending" })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("dl", { className: "grid grid-cols-2 gap-4 mb-3", children: [
      /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("dt", { className: "flex items-center gap-1.5 text-secondary text-sm", children: [
          /* @__PURE__ */ (0, import_jsx_runtime770.jsx)(DollarCircle_default, { className: "size-4" }),
          "Active Stake"
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("dd", { className: "text-lg font-semibold text-primary mt-1", children: [
          activeStake,
          " ",
          /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("span", { className: "text-sm text-secondary", children: "EGLD" })
        ] })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("div", { children: [
        /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("dt", { className: "flex items-center gap-1.5 text-secondary text-sm", children: [
          /* @__PURE__ */ (0, import_jsx_runtime770.jsx)(Sparkles_default, { className: "size-4" }),
          "Rewards"
        ] }),
        /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("dd", { className: "text-lg font-semibold text-success mt-1", children: [
          rewards,
          " ",
          /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("span", { className: "text-sm text-secondary", children: "EGLD" })
        ] })
      ] })
    ] }),
    (hasUndelegated || hasUnbondable) && /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("div", { className: "border-t border-subtle pt-3 mt-3", children: [
      /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)(
        "button",
        {
          onClick: () => setExpanded(!expanded),
          className: "text-sm text-link hover:underline flex items-center gap-1",
          children: [
            expanded ? /* @__PURE__ */ (0, import_jsx_runtime770.jsx)(ChevronDown_default, { className: "size-4" }) : /* @__PURE__ */ (0, import_jsx_runtime770.jsx)(ChevronRight_default, { className: "size-4" }),
            "Unbonding Details"
          ]
        }
      ),
      expanded && /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("dl", { className: "mt-3 space-y-2", children: [
        hasUnbondable && /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("div", { className: "flex justify-between text-sm", children: [
          /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("dt", { className: "flex items-center gap-1.5 text-secondary", children: [
            /* @__PURE__ */ (0, import_jsx_runtime770.jsx)(Clock_default, { className: "size-4" }),
            "Ready to withdraw"
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("dd", { className: "font-medium", children: [
            unbondable,
            " EGLD"
          ] })
        ] }),
        delegation.userUndelegatedList.map((item, idx) => /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("div", { className: "flex justify-between text-sm", children: [
          /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("dt", { className: "text-secondary", children: [
            "Undelegating ",
            item.seconds === 0 ? "(ready)" : `(${item.seconds}s remaining)`
          ] }),
          /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("dd", { className: "font-medium", children: [
            formatEgld(item.amount),
            " EGLD"
          ] })
        ] }, idx))
      ] })
    ] })
  ] });
}
function App() {
  const toolData = useToolOutput();
  if (!toolData || !toolData.DELEGATIONS) {
    return /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("div", { className: "p-8", children: /* @__PURE__ */ (0, import_jsx_runtime770.jsx)(
      EmptyMessage,
      {
        title: "No delegations found",
        description: "You don't have any active delegations to display."
      }
    ) });
  }
  const { DELEGATIONS, TOTAL_STAKED_EGLD, TOTAL_REWARDS_EGLD, PROVIDER_COUNT } = toolData;
  return /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("div", { className: "flex flex-col gap-4 p-4 max-w-lg mx-auto", children: [
    /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("div", { className: "text-center mb-2", children: [
      /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("h1", { className: "heading-lg", children: "MultiversX Delegations" }),
      /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("p", { className: "text-secondary text-sm mt-1", children: [
        PROVIDER_COUNT,
        " provider",
        PROVIDER_COUNT !== 1 ? "s" : ""
      ] })
    ] }),
    /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("div", { className: "rounded-2xl border border-default bg-surface-secondary p-4", children: /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("dl", { className: "grid grid-cols-2 gap-4", children: [
      /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("div", { className: "text-center", children: [
        /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("dt", { className: "text-secondary text-xs uppercase tracking-wide", children: "Total Staked" }),
        /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("dd", { className: "text-2xl font-bold text-primary mt-1", children: TOTAL_STAKED_EGLD.toFixed(2) }),
        /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("dd", { className: "text-secondary text-xs", children: "EGLD" })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("div", { className: "text-center", children: [
        /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("dt", { className: "text-secondary text-xs uppercase tracking-wide", children: "Total Rewards" }),
        /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("dd", { className: "text-2xl font-bold text-success mt-1", children: TOTAL_REWARDS_EGLD.toFixed(2) }),
        /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("dd", { className: "text-secondary text-xs", children: "EGLD" })
      ] })
    ] }) }),
    /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)(
      Button,
      {
        color: "success",
        block: true,
        onClick: () => window.openai?.sendFollowUpMessage({ prompt: "Claim all my staking rewards" }),
        children: [
          /* @__PURE__ */ (0, import_jsx_runtime770.jsx)(Sparkles_default, {}),
          "Claim All Rewards"
        ]
      }
    ),
    /* @__PURE__ */ (0, import_jsx_runtime770.jsxs)("div", { className: "space-y-3", children: [
      /* @__PURE__ */ (0, import_jsx_runtime770.jsx)("h2", { className: "text-secondary text-sm font-semibold uppercase tracking-wide", children: "Delegations" }),
      DELEGATIONS.map((delegation, idx) => /* @__PURE__ */ (0, import_jsx_runtime770.jsx)(DelegationCard, { delegation }, `${delegation.contract}-${idx}`))
    ] })
  ] });
}
var rootElement = document.getElementById("root");
if (rootElement) {
  import_client.default.createRoot(rootElement).render(
    /* @__PURE__ */ (0, import_jsx_runtime770.jsx)(import_react25.default.StrictMode, { children: /* @__PURE__ */ (0, import_jsx_runtime770.jsx)(App, {}) })
  );
}

/* __CHATGPT_APP_JS_END__ */